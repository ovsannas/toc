
# Կոնցեպտներ և ընդհանրացված ծրագրավորում

## Ներածություն

Ինչի՞ համար են կաղապարները (template)։ Այլ կերպ ասած՝ երբ օգտագործում եք կաղապարները, ծրագրավորման ո՞ր տեխնիկաներն են ավելի արդյունավետ։ Կաղապարները տալիս են.

* Տիպերը (ինչպես նաև արժեքներն ու կաղապարները) որպես արգումենտ փոխանցելու հնարավորություն՝ առանց ինֆորմացիայի կորստի։ This implies excellent opportunities for inlining, of which current implementations take great advantage.
* Օբյեկտի ստեղծման ժամանակ տարբեր ենթատեքստերից ստացված ինֆորմացիայի միահյուսման հնարավորություն։ Սա նաև ենթադրում է օպտիմիզացիայի հնարավորություն։
* Հաստատուն արժեքները որպես արգումենտներ փոխանցելու հնարավորություն։ Սա ենթադրում է կոմպիլյացիայի ժամանակի հաշվարկների հնարավորություն։

Այլ կերպ ասած՝ կաղապարները տրամադրում են կոմպիլյացիայի ժամանակի հաշվարկների և տիպերի մանիպույացիայի? հզոր միջոց, որը կարող է հանգեցնել շատ կոմպակտ և արդյունավետ ծրագրային կոդի։ (?) Հիշեք, որ տիպերը (դասերը) կարող են պարունակել և՛ կոդ (§6.3.2), և՛ տվյալներ (§6.2.2)։

Կաղապարների առաջին և ամենասովորական օգտագործումը _ընդհանրացված ծրագրավորման_, այսինքն, ընդհանրացված ալգորիթմների նախագծմանն ու իրականացմանը միտված ծրագրավորման (generic programming) ապահովումն է։ Այստեղ «ընդհանրացված» բառը ցույց է տալիս ալգորիթմը կարող է նախագծվել տիպերի մեծ բազմության հետ օգտագործման համար՝ քանի դեռ այդ տիպերը բավարարում են ալգորիթմների արգումենտների վրա գրված պահանջները։ (?) Կոնցեպտներն ու կաղապարները ընդհանրացված ծրագրավորումը ապահովող C++-ի կարևոր միջոցներն են։ Կողապարները ապահովում են (կոմպիլյացաիյի ժամանակի) պարամետրիկ պոլիմորֆիզմ (բազմաձևություն?)։ (?)

## Կոնցեպտներ (C++20)

Դիտարկենք §6.3.1-ի `sum()` ֆունկցիան.

````C++
template<typename Seq, typename Num>
Num sum(Seq s, Num v)
{
    for (const auto& x : s)
        v += x;
    return v;
}
````

Այն կարելի է կիրառել ցանկացած տվյալների կառուցվածքի հետ, որի `begin()`-ը և `end()`-ը  ապահովում են range-for-ի աշխատանքը։ Այդպիսի կառուցվածքներից են ստանդարտ գրադարանի `vector`-ը, `list`-ը և `map`-ը։ Բացի այդ, տվյալների կառուցվածքի տարրի տիպը սահմանափակված է միայն իր օգտագործմամբ. այն պիտի լինի այնպիսի տիպի, որը կարողանանք գումարել `v` արգումենտին։ Այդպիսիք են, օրինակ, `int`, `double` և `Matrix` տիպերը (`Matrix` մի որևէ ընդունելի իրականացման պայմանով)։ Կարող ենք ասել, որ `sum()` ալգորիթմը ընդհանրացված է (is generic) երկու չափողականություններով՝ տարրերը պահելու տվյալների կառուցվածքի («հաջորդականության») տիպով և տարրերի տիպով։

Այսպիսով, `sum()`-ը պահանջում է, որ իր կաղապարի առաջին արգումենտը լինի ինչ-որ հաջորդականություն, իսկ կաղապարի երկրորդ արգումենտը՝ ինչ-որ թիվ։ Այսպիսի պահանջներն անվանում ենք _կոնցեպտներ_ (concepts)։

Կոնցեպտները դեռ լեզվի ISO C++ ստանդարտի մաս չէ, բայց այն ներկայացված է որպես ISO Technical Specification [ConceptsTS]։ Իրականացումներ արդեն կան, և ես համարձակվում եմ կոնցեպտները ներկայացնել այս գրքում, չնայած, որ ինչ-որ հատկություններ դեռ կփոփոխվեն և հնարավոր է շատ տարիներ պահանջվեն, մինչև ամեն ոք կարող է դրանք օգտագործել արտադրական ծրագրերում։ (?)

### Կոնցեպտների օգտագործումը

Կաղապարները պատշաճ կոմպիլյացաիյի և գեներացված կոդի պատշաճ կատարման համար կաղապարների արգումենտներից շատերը պետք է բավարարեն տվյալ կաղապարին հատուկ ինչ-որ պայմանների։ Այսինքն՝ կաղապարներից շատերը պետք է ունենան սահմանափակումներ (constraints) (§6.2.1)։ Տիպի անունը բնորոշող `typename` բառը նվազագույն սահմանափակում է, որ պահանջում է միայն արգումենտի տիպ լինելը։ Սովարաբար կարող ենք դրանից ավելի անել։ Նորից դիտարկենք այն `sum()` ֆունկցիան.

````C++
template<Sequence Seq, Number Num>
Num sum(Seq s, Num v)
{
    for (const auto& x : s)
        v += x;
    return v;
}
````

Ահա արդեն ավելի հստակ է։ Հենց որ սահմանենք, թե ինչ են նշանակում `Sequence` և `Number` կոնցեպտները, կոմպիլյատորը կարող է մերժել սխալ կանչերը՝ միայն `sum()`-ի ինտերֆեյսին, այլ ոչ թե նրա իրականացմանը, նայելով։ Սա բարելավում է սխալների մասին ազդարարումը։

Սակայն `sum()`-ի ինտերֆեյսը դեռ լրիվ չէ. Ես «մոռացա» ասել, որ պետք է կարողանանք `Sequence`-ի տարրերը գումարել `Number`-ին։ Դա էլ կարող ենք անել.

````C++
template<Sequence Seq, Number Num>
    requires Arithmetic<Value_type<Seq>,Num>
Num sum(Seq s, Num n);
````
