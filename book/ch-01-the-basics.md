
# 1 Հիմունքները

Մեր առաջին գործը այն կլինի, որ սպանենք բոլոր օրենսգետներին։

Հենրի VI, Մաս II, Արարված չորրորդ, Տեսարան երկրորդ

* Ներածություն
* Ծրագրեր
* Hello, World!
* Ֆունկցիաներ
* Տիպեր, փոփոխականներ և թվաբանություն
* Տեսանելիության տիրույթ և կյանքի տևողություն
* Հաստատուններ
* Ցուցիչներ, զանգվածներ և հղումներ
* Պայմանների ստուգում
* Խորհուրդներ

## 1.1 Ներածություն

Այս գլուխը ոչ խիստ ձևով ներկայացնում է C++ լեզուն, C++-ի հիշողության և հաշվարկման մոդելները, և ծրագրերում կոդի կազմակերպման հիմնական մեխանիզմները։ Դրանք լեզվի այն հնարավորություններն են, որոնք ավելի հաճախ հանդիպում են C լեզվում և այդ ոճը երբեմն կոչվում է _պրոցեդուրային ծրագրավորում_։

## 1.2 Ծրագրեր

C++-ը կոմպիլյացվող (թարգմանվող) լեզու է։ Գործարկվող ծրագրի սկզբնական տեքստը պետք է մշակվի կոմպիլյատորով, որը ստեղծում է օբյեկտային ֆայլերը, վերջիններս էլ միավորվում են կապակցող ծրագրով և ստեղծվում է կատարվող ծրագիրը։ Սովորաբար C++ լեզվով գրված ծրագիրը բաղկացած է մի քանի սկզբնական ֆայլերից (ավելի հաճախ պարզապես՝ ֆայլեր)։ ?? 

   նկար

Կատարվող ծրագիրը ստեղծվում է որոշակի ապարատ-համակարգ զույգի համար․ այն տեղափոխելի չէ, ասենք, Mac-ից Windows-ի։ Երբ խոսում ենք C++ ծրագրերի տեղափոխելիության մասին, սովորաբար նկատի ունենք ծրագրային տեքստերի տեղափոխելիությունը, այսինքն՝ նախնական տեքստերը կարող են հաջողությամբ կոմպիլյացվել և կատարվել տարբեր համակարգերում։

ISO C++ ստանդարտը սահմանում է էությունների (իրերի) երկու տեսակ․
* Լեզվի միջուկի հատկություններ, ինչպիսիք են ներդրված տիպերը (օրինակ՝ `char` և `int`) և ցիկլերը (օրինակ՝ `for` և `while` հրամանները)։
* Ստանդարտ գրադարանի բաղադրիչներ, ինչպիսիք են կոնտեյներները (օրինակ՝ `vector` և `map`) և ներմուծման/արտածման գործողությունները (օրինակ՝ `<<` և `getline()`)։ 

Ստանդարտ գրադարանի բաղադրիչները գերազանցախես C++ լեզվի ծրագրեր են, որոնցով հարստացված է C++ լեզվի ցանկացած տարբերակ (իրականացում)։ ?? յսինքն՝ C++ լեզվի ստանդարտ գրադարանը կարող է իրականացվել և իրականացված է հենց C++ լեզվով մեջ (մեքենայական կոդի չնչին օգտագործմամբ, այնպիսի դեպքերում, ինչպիսին է հոսքի կոնտեքստի փոփոխումը): Սրանից հետևում է, որ C++-ը բավականաչափ արտահայտիչ և արդյունավետ է ամենախստապահանջ համակարգային ծրագրավորման խնդիրների համար։

C++-ը ստատիկ տիպիզացվող լեզու է։ Այսինքն, ծրագրում մասնակցող ամեն մի առարկայի (օբյեկը, արժեք, կամ արտահայտություն) տիպը կոմպիլյատորին պետք է հայտնի լինի հենց իր օգտագործման կետում։ Օբյեկտի տիպով որոշվում է դրան կիրառելի գործողությունների բազմությունը։


### Hello, World!

C++ լեզվով գրված ամենափոքր ծրագիրը հետևյալն է՝

````C++
int main() {}    // C++-ով գրված ամենակարճ ծրագիրը
````

Այստեղ սահմանվում է `main` ֆունկցիան, որը ոչ մի արգումենտ չի ստանում և ոչ մի գործողություն չի կատարում։

C++-ում ձևավոր փակագծերը՝ `{}`, ցույց են տալիս խմբավորում։ Այստեղ նրանք ցույց են տալիս ֆունկցիայի մարմնի սկիզբն ու վերջը։ Երկու թեք գծերով՝ `//`, սկսվում է մեկնաբանություն, որը շարունակվում է մինչև տողի վերջը։ Մեկնաբանությունը գրվում է ընթերցողի համար, կոմպիլյատորն այն անտեսում է։ 

C++-ով գրված ցանկացած ծրագիր պետք է ունենա `main()` անունով ճիշտ մեկ գլոբալ ֆունկցիա։ Ծրագիրն սկսվում է այդ ֆունկցիայի կատարումով։ `main()` ֆունկցիայի վերադարձրած `int` արժեքը, եթե այդպիսին կա, ծրագրի վերադարձրած արժեքն է «համակարգին»։ Եթե ոչ մի արժեք չի վերադարձվում, համակարգը կստանա բարեհաջող ավարտ նշանակող որևէ արժեք։ `main()` ֆունկցիայից վերադարձվող զրոյից տարբեր արժեքը նշանակում է ծրագրի կատարման ձախողում։ Ոչ բոլոր օպերացիոն համակարգերն ու կատարման միջավայրերն են օգտագործում այդ վերադարձված արժեքը. Linux/Unix-ի վրա հիմնված միջավայրերը հաճախ օգտագործում են, իսկ Windows-ի վրա հիմնված համակարգերը՝ երբեմն։

Որպես կանոն ծրագիրն ինչ-որ բան է արտածում։ Ստորև բերված է ծրագիր, որն էկրանին տպում է Hello, World! արտահայտությունը։

````C++
#include <iostream>
int main()
{
    std::cout << "Hello, World!\n";
}
````

`#include <iostream>` տողը կոմպիլյատորին հրահանգում է `iostream` ֆայլից ծրագրին _կցել_ ստանդարտ ներմուծման/արտածման միջոցների սահմանումները։ Առանց այդ սահմանումների

````C++
std::cout << "Hello, World!\n"
````

արտահայտությունը իմաստ չի ունենա։ `<<` (ուղարկել) օպերատորն իր երկրորդ արգումենտը գրում է առաջինի մեջ։ Այս դեպքում `"Hello World!\n"` տեքստային լիտերալը գրվում է `std::cout` ստանդարտ արտածման հոսքի մեջ։ Տողը սիմվոլների հաջորդականություն է՝ ներառված կրկնակի չակերտներում։ Տողի մեջ հակառակ թեք գիծը՝ `\`, իրենից հետո մեկ այլ նիշի հետ միասին նշանակում է «հատուկ սիմվոլ»։ Այս դեպքում `\n`֊ը նոր տողի սիմվոլն է. այսինքն՝ գրված են `Hello, World!` նիշերը և դրանց հաջորդող նոր տողի նիշը։

`std::` նախդիրը ցույց է տալիս, որ `cout` անունը գտնվում է ստանդարտ գրադարանի անունների տիրույթում (§3.4)։ Ստանդարտ գրադարանի հնարավորությունները քննարկելիս ես սովորաբար բաց եմ թողնում `std::`-ն։ §3.4 բաժնում ցույց է տրվում, թե ինչպես մի որևէ անունների տիրույթի անունները դարձնել տեսանելի՝ առանց անունների տիրույթը բացահայտ նշելու։

Ընդհանրապես ամբողջ կատարվող կոդը բաշխվում է ֆունկցիաների մեջ և ուղղակիորեն կամ անուղղակիորեն կանչվում է `main()` ֆունկցիայից։ Օրինակ․

````C++
#include <iostream>  // կցել Ն/Ա գրադարանի սահմանումները

using namespace std; // `std` անունների տիրույթի անունները դարձնում է տեսանելի առանց `std::`֊ի (§3.4)

double square( double x ) // կրկնակի ճշտության իրական թվի քառակուսին
{
    return x * x;
}

void print_square( double x )
{
    cout << x << "-ի քառակուսին " << square( x ) << "է \n";
}

int main()
{
    print_square( 1.234 );  // արտածում է. 1.234-ի քառակուսին 1.52276 է
}
````

Վերադարձվող արժեքի `void` տիպը ցույց է տալիս, որ ֆունկցիան որևէ արժեք չի վերադարձնում։


## 1.4 Ֆունկցիաներ

C++ ծրագրով ինչ-որ բան անելու միակ եղանակը համապատասխան ֆունկցիան կանչելն է։ Ֆունկցիայի սահմանումն է այն ճանապարհն է, որով նկարագրում ենք կատարվելիք գործողությունը։ Ֆունկցիան հնարավոր չէ կանչել, եթե նախապես այն չի հայտարարվել։

Ֆունկցիայի հայտարարությամբ տրվում են ֆունկցիայի անունը, վերադարձվող արժեքի տիպը (եթե այն կա) և կանչի ժամանակ տրվող արգումենտների քանակն ու տիպերը։ Օրինակ․

````C++
Elem* next_elem();   // արգումենտներ չկան, վերադարձնում է Elem֊ի ցուցիչ (Elem*)
void exit(int);      // ստանում է int տիպի արգումենտ, ոչինչ չի վերադարձնում
double sqrt(double);  // double արգումենտ, վերադարձնում է double
````

Ֆունկցիայի հայտարարության մեջ վերադարձվող արժեքի տիպը գրվում է ֆունկցիայի անունից առաջ, իսկ արգումենտների տիպերը՝ ֆունկցիայի անունից հետո՝ փակագծերի մեջ։ 

Արգումենտների փոխանցման սեմանտիկան նույնական է սկզբնարժեքավորման (initialization) սեմանտիկային (§3.6.1)։ Այսինքն, ստուգվում են արգումենտների տիպերը և անհրաժեշտության դեպքում կատարվում է տիպերի ոչ բացահայտ ձևափոխություն (§1.4)։ Օրինակ․

````C++
double s2 = sqrt(2);  // կանչել sqrt() ֆունկցիան double{2} արգումենտով
double s3 = sqrt("three");  // սխալ․ sqrt()֊ը պահանջում է double տիպի արգումենտ
````

Կոմպիլյացիայի ժամանակ կարարվող այսպիսի ստուգումն ու տիպերի ձևափոխությունը պետք չէ թերագնահատել։

Ֆունկցիայի հայտարարությունը կարող է պարունակել նաև արգումենտների անունները։ Սա կարող է օգնել ծրագիրը կարդացողին, բայց եթե ֆունկցայի հայտարարությունը նաև ֆունկցիայի սահմանում չէ, կոմպիլյատորը պարզապես անտեսում է այդ անունները։ Օրինակ․

````C++
double sqrt(double d);   // վերադարձնում է d֊ի քառակուսի արմատը
double square(double);   // վերադարձնում է արգումենտի քառակուսի արմատը
````

Ֆունկցիայի տիպը բաղկացած է վերադարձվող արժեքի տիպից և արգումենտների տիպերի հաջորդականությունից։ Օրինակ․

````C++
double get(const vector<double>& vec, int index);  // տիպը՝ double(const vector<double>&, int)
````

Ֆունկցիան կարող է լինել նաև հասի անդամ (member of a class) (§2.3, §4.2.1)։ Այդպիսի _անդամ-ֆունկցիայի_ համար իր դասի անունը նույնպես ֆունկցիայի տիպի մաս է։ Օրինակ.

```C++
char& String::operator[](int index);   // տիպը՝ char& String::(int)
```

Ցանկալի է, որ մեր ծրագիրը լինի հասկանալի, ընթեռնելի քանի որ դա կոդի սպասարկելիության (maintainability) առաջին նախապայմանն է։ Ընթեռնելոիթյան հասնելու առաջին քայլը հաշվարկային խնդիրը իմաստալից կտորների` որպես ֆունկցիաներ ու դասեր բաժանելն է ու դրանց անուններ տալն է։ Այդպիսի ֆունկցիաներն այնուհետև կազմում են հաշվարկման հիմնական բառապաշարը, ճիշտ այնպես, ինչպես տիպերն են ապահովում (ներդրված և օգտագործողի սահմանված) տվյալների հիմնական բառապաշարը։ ?? C++ լեզվի ստանդարտ ալգորիթմները (օր․ `find`, `sort` և `iota`) լավ սկիզբ են (Գլուխ 12)։ Դրանք օգտագործելով կարող ենք կառուցել ֆունկցիաներ, որոնք ընդհանուր կամ հատուկ խնդիրները ներկայացնում են ավելի մեծ հաշվարկների մեջ։ ??

Կոդի մեջ սխալների քանակը խիստ փոխկապակցված է կոդի մեծության և բարդության հետ։ Այս երկու խնդիրներն էլ կարող են լուծվել ավելի շատ ու ավելի կարճ ֆունկցիաների օգտագործմամբ։ Ֆունկցիայի օնգությաբ ինչ-որ առանձին գործ անելը մեզ զերծ է պահում արդեն գոյություն ունեցող կոդի մեջ ինչ-որ հատուկ կոդ գրելուց։ Նոր կոդը ձևակերպելով որպես ֆունկցիա՝ ստիպված ենք լինում անուն տալ այդ գործողությանը և նկարագրել դրա կախվածությունները։

Եթե երկու ֆունկցիա սահմանված են միևնույն անունով, բայց տարբեր տիպի արգումենտներով, ապա կոմպիլյատորն ամեն մի կանչի համար կընտրի առավել համապատասխան ֆունկցիան։ Օրինակ․

````C++
void print(int);     // ստանում է ամբողջ տիպի արգումենտ 
void print(double);  // ստանում է սահող ստորակետով տիպի արգումենտ
void print(string);  // ստանում է տող արգումենտ

void user()
{
   print(42);                   // կանչվում է print(int)֊ը
   print(9.65);                 // կանչվում է print(double)֊ը
   print("D is for Digital");   // կանչվում է print(string)֊ը
}
````

Եթե ֆունկցիայի երկու տարբերակներն էլ կարող են կանչվել, բայց նրանցից ոչ մեկն ավելի նախընտրելի չէ քան մյուսը, ապա կանչը համարվում է ոչ միանշանակ, և կոմպիլյատորն ազդարարում է սխալի մասին։ Օրինակ․

````C++
void print(int, double);
void print(double, int);

void user2()
{
  print(0, 0);  // սխալ․ անորոշություն
}
````

Նույն անունով մի քանի ֆունկցիաների սահմանումը կոչվում է _ֆունկցիայի գերաբեռնում_ (function overloading). այն ընդհանրացված ծրագրավորման հիմնարար հասկացություններից (§7.2)։ Երբ ֆունկցիան գերաբեռնված է, ապա միևնույն անունով բոլոր ֆունկցիաները պետք է ներկայացնեն միևնույն սեմանտիկան (իմաստը)։ Օրինակ՝ վերը բերված `print()` ֆունցիաներ. դրանք բոլորն էլ տպում են իրենց արգումենտը։


## 1.4 Տիպեր, փոփոխականներ և թվաբանություն

Յուրաքանչյուր անուն և յուրաքանչյուր արտահայտություն ունի տիպ, որով որոշվում են նրան կիրառելի գործողությունները։ Օրինակ.

````C++
int inch;
````
հայտարարությունը նշում է, որ `inch`-ը `int` տիպի է, այսինքն `inch`֊ը ամբողջ տիպի փոփոխական է։

_Հայտարարությունը_ մի հրաման է, որը անունը ներկայացնում է ծրագրի մեջ։ Այն սահմանում է անվանված էության տիպը․

* _Տիպը_ սահմանում է հնարավոր արժեքների և հնարավոր գործողությունների բազմությունը (օբյեկտի համար)։ 
* _Օբյեկտը_ հիշողության տիրույթ է, որը պահում է որևէ տիպի արժեք։
* _Արժեքը_ բիթերի շարք է, որը մեկնաբանվում է ըստ իր տիպի։
* _Փոփոխականը_ անվանված օբյեկտ է։

C++ լեզուն առաջարկում է ֆունդամենտալ տիպերի մի փոքր գազանանոց, բայց քանի որ ես կենդանաբան չեմ՝ դրանց բոլորին չեմ թվարկի։ Բոլոր տիպերի մասին կարող եք կարդալ տեղեկատուներում, օրինակ, [Stroustrup, 2003] կամ [cppreference]։ Ահա մի քանի օրինակներ․

````C++
bool       // տրամաբանական տիպ, հնարավոր արժեքներն են true և false
char       // նիշ, օրինակ 'a', 'z' կամ '9'
int        // ամբողջ թիվ, օրինակ -273, 42 կամ 1066
double     // կրկնակի ճշտությամբ սահող ստորակետով թիվ, օրինակ -273.15, 3.14 կամ 299793.0
unsigned   // ոչ բացասական ամբողջ թիվ, օրինակ 0, 1 կամ 999
````

Ամեն մի ֆունդամենտալ տիպ ուղղակիորեն արտապատկերվում ապարատային հնարավորություններին և ունի կոնկրետ չափ, որով և սահմանվում է նրա արժեքների բազմությունը։

    նկար 1.5.1

`char` տիպի փոփոխականի չափն այնպիսին է, որը տվյալ մեքենայում կարող է պահել մեկ նիշ (որպես կանոն դա 8 բիթ է), մյուս տիպերի չափերը պատիկ են `char`֊ի չափին։ Տիպի չափը կախված է իրականացումից (այսինքն այն կարող է տարբեր մեքենաներում տարբեր լինել) և ստանալ `sizeof` օպերատորի միջոցով, օրինակ, `sizeof(char)`֊ը հավասար է `1`֊ի, իսկ `sizeof(int)`֊ը սովորաբար `4` է։

Թվերը կարող են լինել սահող կետով (floating-point) կամ ամբողջաթիվ (integer).

* Սահող կետով թվերը կարելի է տարբերել տասնորդական կետով (օր., `3.14`) կամ ցուցիչով (օր., `3e-2`)։
* Ամբողջաթիվ լիտերալները լռելությամբ տեսական են (օր., `42`-ը նշանակում է քառասուներկու)։ `0b` նախածանցով գրառվում են երկուական (2 հիմքով) ամբողջաթիվ լիտերալները (օր., `0b10101010`): `0x` նախածանցով գրառվում են տասնվեցական (16 հիմքով) ամբողջաթիվ լիտերալները (օր., `0xBAD1234`)։ `0` նախածանցով գրառվում են ութական (8 հիմքով) ամբողջաթիվ լիտերալները (օր., `0334`)։

Երկար լիտերալները մարդկանց համար ընթեռնելի դարձնելու համար կարող ենք օգտագործել ապաթարցը (`'`) որպես թվերի բաժանիչ։ Օրինակ, π-ն մոտավորապես `3.14159'26535'89793'23846'26433'83279'50288`, կամ եթե նախընտրում եք տասնվեցական գրառումը՝ `0x3.243F'6A88'85A3'08D3`։


### 1.4.1 Թվաբանություն

Թվաբանական գործողությունները կարող են օգտագործվել նիմնական տիպերի համապատասխան կոմբինացիաներում․

````C++
x+y    // գումարում
+x     // ունար գումարում
x-y    // հանում
-x     // ունար հանում
x*y    // բազմապատկում
x/t    // բաժանում
x%y    // ամբողջ թվերից ստացված մնացորդ (մոդուլուս)
````

Նույն ձևով կարող են օգտագործվել նաև համեմատության գործողությունները․

````c++
   x==y	// հավասար է
   x!=y	// հավասար չէ
   x<y	// փոքր է
   x>y	// մեծ է
   x<=y	// փոքր է կամ հավասար
   x>=y	// մեծ է կամ հավասար
````

Դեռ ավելին, ապահովված են նաև տրամաբանական գործողություններ․

````c++
   x&y       // բիթային և
   x|y	// բիթային կամ
   x^y	// բիթային բացառող կամ
   ~x	// բիթային լրացում
   x&&y     // տրամաբանական և
   x||y	// տրամաբանական կամ
````

Բիթային տրամաբանական գործողության արդյունքն իր այն օպերանդի տիպի է, որի բիթերի համար կատարվել է գործղությունը։ ?? Տրամաբանական `&&` և `||` գործողությունները պարզապես վերադարձնում են `true` կամ `false`՝ կախված իրենց օպերանդների արժեքներից։

Վերագրման և թվաբանական գործողություններում C++ լեզուն կատարում է հիմնական տիպերի միջև բոլոր իմաստալից ձևափոխումներն այնպես, որ դրանք կարելի է համատեղ օգտագործել․

````C++
void some_function()   // ֆունկցիան ոչի մի արժեք չի վերադարձնում
{
    double d = 2.2;  // սահող կետով թվի սկզբնարժեքավորում
    int i = 7;       // ամբողջ թվի սկզբնարժեքավորում
    d = d + i;       // d֊ին վերագրել գումարը
    i = d * i;       // i֊ին վերագրել արտադրյալը (զգուշացեք, d*i իրական արժեքը կրճատվում է int-ի)
}
````

Արտահայտությունների մեջ օգտագործված ձևափոխությունները կոչվում են _սովորական թվաբանական ձևափոխություններ_ և երաշխավորում են, որ արտահայտությունները հաշվարկվում են իրենց օպերանդների բարձր ճշտությամբ։ ?? Օրինակ, `double` և `int` թվերի գումարումը կատարվում է կրկնակի ճշտությամբ սահող ստորակետով թվերի թվաբանության կանոններով։

Նշենք, որ `=`֊ը վերագրման գործողությունն է, իսկ `==`֊ը՝ հավասարության։

Բացի սովորական թվաբանական և տրամաբանական օպերատորներից C++ լեզուն պարունակում է փոփոխականի արժեքը փոխելու ևս մի քանի գործողություններ.

````c++
x+=y   // x = x+y
++x    // ինկրեմենտ՝ x = x+1
x-=y   // x = x-y
--x    // դեկրեմենտ՝ x = x-1
x*=y   // x=x*y 
x/=y   // x=x/y
x%=y   // x=x%y
````

Այս օպերատորները հակիրճ են, հարմար և շատ տարածված։

Արտահայտությունների հաշվարկման կարգը ձախից-աջ է, բացառությամբ վերագրման գործողության, որում հաշվարկումը աջից-ձախ է։ Ֆունկցիայի արգումենտների հաշվարկման կարգը ցավոք սահմանված չէ։


### 1.4.2 Սկզբնարժևորում

Օգտագործվելուց առաջ օբյեկտը պետք է արժեք ստանա։ C++-ում կա օբյեկտը սկզբնարժևորելու մի քանի ձև, դրանցից մեկն, օրինակ, վերն օգտագործված `=` նշանի միջոցով է։ Սահմանված է նաև սկզբնարժևորման ունիվերսալ եղանակ՝ ձևավոր փակագծերի մեջ առնված արժեքների ցուցակի կիրառմամբ։ ??

````C++
double d1 = 2.3;             // d1֊ին տրվում է 2.3 սկզբնական արժեքը
double d2 {2.3};             // d2-ին տրվում է 2.3 սկզբնական արժեքը
comples<double> z = 1;       // կոմպլեքս թիվ` կրկնակի ճշտությամբ սահող կետով թվի սկալյարներով
complex<double> z2 {d1,d2};
complex<double> z3 = {1,2};  // =֊ը {}֊ի հետ պարտադիր չէ
vector<int> v{1,2,3,4,5,6};  // int֊երի վեկտոր
````

Վերագրման (`=`) ավանդական ձևը եկել է C-ից։ Եթե կասկածում եք՝ որն ընտրել, ապա ընտրեք ձևավոր փակագծերը՝ `{}`։ Նվազագույնը՝ այն կփրկի ձեզ ինֆորմացիան կորցնող ձևափոխություններից։ Օրինակ․

````C++
int i1 = 7.2;    // i1-ը ստանում է 7 արժեքը (զարմանալի՞ է)
int i2{7.2};	     // սխալ՝ սահող կետով թվի ձևափոխություն ամբողջ թվի
````

Դժբախտաբար, ինֆորմացիան կորցնող ձևափոխությունները՝ արժեքների տիրույթը _նեղացող ձևափոխումները_, ինչպիսիք են, օրինակ, `double`֊ից `int`, `int`֊ից `char`, թույլատրելի են և անբացահայտ կատարվում են։ Դա այն գինն է, որ վճարվում է C լեզվի հետ համատեղելիության համար (§14.6)։

Հաստատունը (§1.6) չի կարելի թողնել առանց սկզբնական արժեքի, նույնիսկ փոփոխականն առանց սկզբնական արժեքի կարելի է թողնել միայն բացառից դեպքերում։ Մի ներմուծեք նոր անուն, քանի դեռ դրա համար համապատասխան արժեք չունեք։ Օգտագործողի կողմից սահմանված տիպերը (ինչպիսիք են՝ `string`, `vector`, `Matrix`, `Motor_controller` կամ `Orc_warrior`) կարող են սահմանվել անուղղակի սկզբնարժեքավորմամբ (§4.2.1)։

Որևէ փոփոխական հայտարարելիս կարիքը չկա բացահայտ նծել նրա տիպը՝ եթե վերջինս հնարավոր է դուրս բերել սկզբնարժեքավորման ժամանակ։

````C++
auto b = true;     // bool
auto ch = 'x';     // char
auto i = 123;      // int
auto d = 1.2;      // double
auto z = sqrt(y);  // z-ի տիպը sqrt(y)-ի վերադարձրած արժեքի տիպն է
````

`auto` բառի հետ հակված ենք օգտագործել `=` գործողությունը, քանի որ այդտեղ տիպի ձևափոխության վտանգ չկա, բայց եթե նախընտրում եք ամենուրեք օգտագործել `{}`, ապա կարող եք վարվել այդպես:

`auto` բառն օգտագործում ենք այն դեպքերում, երբ տիպը բացահայտ նշելու որևէ հատուկ պատճառ չկա։ «Հատուկ պատճառ» կարող է համարվել.

* Սահմանումն այնպիսի մեծ տեսանելիության տիրույթում է, որ անպայման ուզում ենք տիպը հստակ տեսանելի լինի կոդը կարդացողին։
* Ցանկանում ենք հստակ նշել փոփոխականի արժեքների տիրույթը կամ ճշտությունը (օր․, `double`, թե՞ `float`)։

Օգտագործելով `auto` բառը, շատ անգամ խուսափում ենք ավելորդություններից և տիպերի երկար անուններ գրելուց։ Սա հատկապես կարևոր է ընդհանրացված ծրագրավորման մեջ, որտեղ ծրագրավորողը կարող է չիմանալ օբյեկտի հստակ տիպը, իսկ տիպերի անունները կարող են շատ երկար լինել (§12.2)։



## 1.5 Տեսանելիության տիրույթ և կյանքի տևողություն

Հայտարարութունը տեսանելիության տիրույթ (scope) է ներմուծում նոր անուն․

* _Լոկալ տիրույթ_։ Ֆունկցիայի (§1.3) կամ լամբդա արտահայտության (§6.3.2) մեջ հայտարարված անունը կոչվում է _լոկալ անուն_։ Նրա տեսանելիության տիրույթը տարածվում է նրա հայտարարության կետից մինչև այն բլոկի վերջը, որտեղ գործում է այդ հայտարարությունը։ _Բլոկը_ սահմանափակված է մեկ զույգ `{}` ձևավոր փակագծերի միջև։ Ֆունկցիայի արգումենտների անունները համարվում են լոկալ անուններ։
* _Դասի տիրույթ_։ Անունը կոչվում է _անդամ անուն_ (կամ _դասի անդամ անուն_), եթե այն սահմանվել է դասի ներսում (§2.2, §2.3, գլուխ 4)՝ որևէ ֆունկցիայի (§1.3), լամբդա արտահայտության (§6.3.2) կամ `enum class`-ի (§2.5) սահմաններից դուրս։ Նրա տեսանելիության տիրույթը տարածվում է իր հայտարարությունն ընդգրկող բլոկի `{` բացող փակագծից մինչև այդ հայտարարության վերջը։
* _namespace-ի տիրույթ_։ Անունը կոչվում է _անունների տիրույթի անդամ անուն_, եթե այն սահմանվել է այդ անունների տիրությում (§3.4)՝ դուրս ցանկացած ֆունկցիայի, լամբդա արտահայտության (§6.3.2), դասի (§2.2, §2.3, գլուխ 4) կամ `enum class`֊ի սահմաններից (§2.5)։ Նրա տեսանելիության տիրույթը տարածվում է իր հայտարարության կետից մինչև իր անունների տիրույթի վերջը։ 

Այն անունը, որը չի հայտարարվել որևէ կառուցվածքի ներսում, կոչվում է _գլոբալ անուն_, և ասում են, որ այն գտնվում է _անունների գլոբալ տիրույթում_։

Ի հավելումն ասվածի՝ կարող ենք ունենալ առանց անունների օբյեկտներ, ինչպիսիք են, օրինակ, ժամանակավոր և `new` օպերատորով (§4.2.2) ստեղծված օբյեկտները: Օրինակ․

````C++
vector<int> vec;  // vec-ը գլոբալ է (ամբողջ թվերի գլոբալ վեկտոր)

struct Record {
    string name; // name-ը Record-ի անդամ է (string տիպի անդամ)
    //...
};

void fct(int arg) // fct-ն գլոբալ է (գլոբալ ֆունկցիա)
                  // arg֊ը լոկալ է (ամբողջ տիպի արգումենտ)
{
    string motto{"Who dares win"}; // motto֊ն լոկալ է
    auto p = new Record{"Hume"};   // p֊ն ցուցիչ է (new-ով ստեղծված) անանուն Record֊ի
    // ...
}
````

Օբյեկտը պետք է կառուցվի (սկզբնարժևորվի) մինչև օգտագործվելը և պետք է քանդվի իր տեսանելիության տիրույթի վերջում։ Անունների տիրույթի օբյեկտի համար ոչնչացման կետը ծրագրի ավարտն է։ Անդամ անունների համար ոչնչացման կետը որոշվում է այն օբյեկտի ոչնչացման կետով, որի անդամն է համարվում տվյալ անունը։ `new` օպերատորի միջոցով ստեղծված օբյեկտներն «ապրում են» մինչև `delete` (§4.2.2) օպերատորով ոչնչացվելը։


## 1.6 Հաստատուններ

C++ լեզվում նախատեսված է օբյեկտի անփոփոխելիության (immutability) երկու գրառում.

* `const` — որը, պատկերավոր ասած, նշանակում է․ «Ես խոստանում եմ չփոփոխել այս արժեքը»։ Սա հիմնականում օգտագործվում է ինտերֆեյսները սահմանելիս, ցույց տալու համար, որ տվյալները ցուցիչների կամ հղումների միջոցով ֆունկցիաներին փոխանցելիս կարող ենք համոզված լինել, որ դրանք չեն փոփոխվելու։ Կոմպիլյատորը նախապատվություն է տալիս `const`-ով նշված խոստմանը։ `const`-ի արժեքը կարող է հաշվարկվել կատարման ժամանակ։
* `constexpr` — նշանակում է. «պետք է հաշվարկվի կոմպիլյացաիայի ժամանակ»։ Սա օգտագործվում է հաստատունները սահմանելու, դրանք միայն կարդալու համար նախատեսված հիշողության մեջ գրանցելու համար (որտեղ քիչ հավանական է դրա վնասվելը), և արտադրողականության համար։

Օրինակ․

````C++
constexpr int dmv = 17; // dmv-ն անվանված հաստատուն է
int var = 17;           // var-ը հաստատուն չէ
const double sqv = sqrt(var); // sqv-ը անվանված հաստատուն է, միգուցե հաշվարկված կոմպիլյացիայի ժամանակ
double sum(const vector<double>&); // sum-ը չի փոխի իր արգումենտը (§1.7)
vector<double> v{1.2, 3.4, 4.5}; // v-ն հաստատուն չէ
const double s1 = sum(v); // OK, sum(v)-ն հաշվարկվում է կատարման ժամանակ
constexpr double s2 = sum(v); // սխալ, sum(v)-ն հաստատուն արտահայտություն չէ
````

Որպեսզի ֆունկցիան հնարավոր լինի օգտագործել _հաստատուն արտահայտության_ մեջ, այսինքն՝ կոմպիլյացիայի ժամանակ հաշվարկվող արտահայտության մեջ, այն պետք է սահմանվի որպես `consexpr`։ Օրինակ.

```C++
constexpr double square(double x) { return x*x; }

constexpr double max1 = 1.4*square(17);       // OK, 1.4*square(17)-ը հաստատուն արտահայտություն է
constexpr double max2 = 1.4*square(var);      // սխալ, var-ը հաստատուն արտահայտություն չէ
const double max3 = 1.4*square(var);          // OK, կարող է հաշվարկվել կատարման ժամանակ
```

`constexpr` ֆունկցիան կարող է օգտագործվել ոչ-հաստատուն արգումենտների համար, սակայն այդ դեպքում արդեն արդյունքը հաստատուն արտահայտություն չէ։ Մենք թույլատրում ենք `constexpr` ֆունկցիան կանչել ոչ-հաստատուն-արտահայտություն արգումենտներով այնպիսի կոնտեքստում, որը չի պահանջում հաստատուն արտահայտություն։ Այդ կերպ ստիպված չենք լինում նույն ֆունկցիան սահմանել երկու անգամ. մեկը՝ հաստատուն արտահայտությունների, մյուսը՝ փոփոխականների համար։


`constexpr` լինելու համար ֆունկցիան պետք է լինի իսկապես հասարակ, չի կարող ունենալ կողմնակի էֆեկտ և կարող է օգտագործել միայն իր արգումենտներով տրված ինֆորմացիան։ Մասնավորապես, այն չի կարող փոփոխել ոչ-լոկալ փոփոխականները, բայց կարող է ունենալ ցիկլեր և կարող է օգտագործել իր սեփական փոփոխականները։ Օրինակ.

```C++
constexpr double nth(double x, int n)   // ենթադրվում է, որ 0 <= n
{
    double res = 1;
    int i = 0;
    while (i<n) {   // while-ցիկլ: կատարել, քանի դեռ պայմանը true է (§1.7.1)
         res*=x;
         ++i;
    }
    return res;
}
```

Որոշ տեղերում լեզվի կանոններն են պահանջում հաստատուն արտահայտություններ (օր., զանգվածի սահմանները (§1.7), `case`-ի պիտակները (§1.8), կաղապարների արժեք արգումենտները (§6.2) և `constexpr`-ով հայտարարված հաստատունները)։ Որոշ այլ դեպքերում կոմպիլյացիայի ժամանակ կատարվող հաշվարկը կարևոր է արտադրողականության համար։ Բյաց, անկախ արտադրողականության հարցերից, անփոփոխելիության գաղափարը (օբյեկտ՝ չփոփոխվող վիճակով) նախագծման կարևոր բաղադրիչ է։ ??


## 1.7 Ցուցիչներ, զանգվածներ և հղումներ

Տվյալների ամենահիմնարար հավաքածուն հերթականությամբ դասավորված նույնատիպ տարրերի հաջորդականությունն է. այն կոչվում է _զանգված_ (array)։ Սա ապարատային ասի կողմից առաջարկվող նվազագույնն է։ `char` տիպի տարրերի զանգվածը կարող է հայտարարվել հետևյալ կերպ․

````C++
char v[6];      // 6 նիշերի զանգված 
````

Նմանապես ցուցիչը կարող է հայտարարվել հետևյալ կերպ․

````C++
char* p; // որևէ նիշի ցուցիչ
````

Հայտարարություններում `[]` փակագծերը նշանակում են «զանգված», իսկ `*`-ը՝ ցուցիչ։ Բոլոր զանգվածներում ստորին սահմանը `0`֊ն է, այսինքն՝ `v`֊ն ունի վեց տարր՝ `v[0]`֊ից `v[5]`։ Զանգվածի  չափը պետք է լինի հաստատուն արտահայտություն (§1.6)։ Ցուցիչ փոփոխականը կարող է պահել համապատասխան տիպի օբյեկտի հասցեն․

````C++
char* p = &v[3];      // p-ն ցույց է տալիս v֊ի չորրորդ էլեմենտին
char x = *p;      // *p-ն այն օբյեկտն է, որին ցույց է տալիս p-ն
````

Արտահայտության մեջ նախածանցային ունար `*`֊ը նշանակում է «պարունակություն», իսկ նախածանցային ունար `&`֊ը՝ «հասցե»։ Կարող ենք այդ արժեքավորված սահմանման արդյունքը ներկայացնել գրաֆիկորեն․

   նկար 1.8

Դիտարկենք տաս տարրերի պատճենումը մի զանգվածից մյուսի մեջ․

````C++
void copy_fct()
{
    int v1[10] = {0,1,2,3,4,5,6,7,8,9};
    int v2[10];       // դառնալու է v1-ի պատճենը

    for( auto i = 0; i != 10; ++i )   // պատճենել տարրերը
        v2[i] = v1[i];
        //...
}
````

Այս `for` հրամանը կարող է կարդացվել այսպես․ «`i`֊ին վերագրել զրո, քանի դեռ `i`֊ն `10` չէ, պատճենել `i`֊րդ տարրը և ավելացնել `i`֊ն մեկով»։ Ամբողջ տիպի կամ սահող կետով փոփոխականի նկատմամբ կիրառելիս `++` ավելացման օպերատորը փոփոխականի արժեքն ավելացնում է մեկով։ C++ լեզուն առաջարկում է նաև ավելի պարզ `for` հրաման, որ կոչվում է միջակայքի-`for` (range-`for`), այն իտերացիաների կամար, որոնք հաջորդականության տարրերեվ անցնում են ամենապարզ եղանակով․ ??

````C++
void print()
{
    int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

    for(auto x : v) // յուրաքանչյուր x֊ի համար v֊ից
        cout << x << '\n';

    for(auto x: {10, 21, 32, 43, 54, 65})
        cout << x << '\n';
    //....
}
````

Առաջին range-`for` կարող է կարդացվել այսպես․ «`v`֊ի յուրաքանչյուր տարրի համար, առաջինից՝ վերջինը, պատճենել արժեքն `x`-ի մեջ և տպել այն»։ Նկատենք, որ մենք պարտավոր չենք նշել զանգվածի սահմանները, երբ այն սկզբնարժևորում ենք ցուցակի միջոցով։ Range-`for` հրամանը կարող է օգտագործվել էլեմենտների ցանկացած հաջորդականության համար (§12.1): ??

Եթե չցանկանայինք արժեքները `v`֊ից պատճենել `x`-ի մեջ, այլ պարզապես `x`֊ը դարձնել `v`-ի տարրի հղում, կարող էինք գրել․ ??

````C++
void increment()
{
    int v[] = {0,1,2,3,4,5,6,7,8,9};

    for (auto& x : v)
        ++x;
    // ...
}
````

Հայտարարության մեջ `&` ունար վերջածանցը նշանակում է «հղում»։ Հղումը նման է ցուցիչին, այն տարբերությամբ, որ կարիք չկա հղվող օբյեկտի արժեքը ստանալու համար օգտագործել `*` նախածանցը։ Բացի այդ՝ սկզբնարժեքավորումից հետո հղումը չի կարելի փոխել այլ օբյեկտի վրա։ ??

Հղումները հատկապես օգտակար են ֆունկցիայի արգումենտներ նշելիս։ Օրինակ․

````C++
void sort(vector<double>& v); // կարգավորել v֊ն
````

Հղում օգտագործելով հղում վստահ ենք, որ `sort(my_vec)` կանչի համար `my_vec`-ը չի պատճենվում և կարգավորվում է ոչ թե `my_vec`֊ի պատճենը, այլ հենց սկզբնական օբյեկտը։

Երբ չենք ցանկանում փոփոխել ֆունկցիայի արգումենտը, բայց նաև չենք ուզում այն պատճենել, ապա օգտագործում ենք `const` հղում։ Օրինակ․

````C++
double sum(const vector<double>&)
````

`const` հղում պարամետրերով ֆունկցիաները շատ տարածված են։

Հայտարարությունների մեջ օգտագործված օպերատորները (ինչպիսիք են `&`, `*` և `[]`) կոչվում են _հայտարարման օպերատորներ_։

````C++
T a[n];   // T[n], n հատ T֊երի զանգված
T* p;     // T*, T֊ի ցուցիչ
T& r;     // T&, T֊ի հղում
T f(A);   // T(A), ֆունկցիա, որը ստանում է A տիպի արգումենտ և վերադարձնում է T տիպի արդյունք
````

### 1.7.1 Զրոյական ցուցիչ

Որպեսզի ապահասցեավորման գործողությունն իմաստալից լինի, ձգտում ենք, որ ցուցիչը միշտ ցույց տա որևէ օբյեկտի։ Երբ բացակայում է այն օբյեկտը, որպին պետք է կապվի ցուցիչը, կամ եթե պետք է «օբյեկտը հասանելի չէ» իրավիճակը, ցուցիչին տալիս ենք `nullptr` («զրոյական ցուցիչ») արժեքը։ Ցուցիչների բոլոր տիպերի համար գոյություն ունի միայն մեկ համատեղ օգտագործելի `nullptr` արժեք.

````C++
double* pd = nullptr;
Link<Record>* lst = nullptr;  // Record֊ի Link֊ի ցուցիչ
int x = nullptr;              // սխալ․ nullptr֊ն ցուցիչ է, ոչ թե ամբողջ թիվ
````

Հաճախ նպատակահարմար է ստուգել, որ ցուցիչն իսկապես կապցած է ինչ-որ օբյեկտի.

````C++
int count_x(char* p, char x)
  // հաշվում է x-ի՝ p[]-ի մեջ հանդիպելու քանակը
  // ենթադրվում է, որ p֊ն ցույց է տալիս զրոյով
  // վերջացող սիմվոլների զանգվածի (կամ ոչ մի բանի վրա)
{
    if (p == nullptr)
        return 0;
    int count = 0;
    for (; *p != 0; ++p)
        if (*p == x)
            ++count;
    return count
}
````

Ուշադրություն դարձրեք, թե ինչպես կարելի է `++` գործողությամբ ցուցիչը տեղափոխել զանգվածի հաջորդ տարրին, և թե ինչպես կարելի է բաց թողնել `for` հրամանի սկզբնարժեքավորման բլոկը, եթե դրա կարիքը չկա։

`count_x()`֊ի սահմանումը ենթադրում է, որ `char*`֊ը _C֊ոճոի տող_ է, այսինքն՝ ցուցիչը ցույց է տալիս `char`֊երի զրոյով վերջացող զանգվածի վրա։

Հին կոդերում `nullptr`֊ի փոխարեն սովորաբար օգտագործված է `0` կամ `NULL`։ Սակայն `nullptr`֊ի օգտագործումը բացառում է ամբողջ թվերի (ինչպիսիք են, օրինակ, `0`֊ն կամ `NULL`֊ը) և ցուցիչների (ինչպիսին է օրինակ `nullptr`֊ը) միջև հնարավոր շփոթությունը։

`count_if()` օրինակում `for` հրամանի սկզբնարժեքավորման բլոկը դատարկ է թողնված, այսինքն՝ կարող ենք օգտագործել ավելի պարզ `while` հրամանը։

```C++
int count_x(const char* p, char x)
  // հաշվում է x-ի՝ p[]-ի մեջ հանդիպելու քանակը
  // ենթադրվում է, որ p֊ն ցույց է տալիս զրոյով
  // վերջացող սիմվոլների զանգվածի (կամ ոչ մի բանի վրա)
{
    if (p==nullptr)
        return 0;
    int count = 0;
    while (*p) {
        if (*p==x)
            ++count;
        ++p;
    }
    return count;
}
```

`while` հրամանը կատարվում է այնքան ժամանակ, քանի դեռ նրա պայմանը `false` չէ։

Թվային արժեքը որպես պայման օգտագործելը (`while (*p)`-ն `count_x()`-ում) համարժեք է այդ արժեքը զրոյի հետ համեմատելուն (`while (*p!=0)`)։ Պայմանում ցուցիչի արժեքն օգտագործելը (`if (p)`) համարժեք է այդ արժեքը `nullptr`-ի հետ համեմատելուն (`if (p!=nullptr)`)։

Գոյություն չունի «զրոյական հղում»։ Հղումը պետք է հղվի վավեր օբյեկտի (և իրականացումները երաշխավորում են դա)։ Կան այս կանոնը խախտելու մութ ու խորամանկ ճանապարհներ. մի՛ արեք դա։


## 1.8 Պայմանների ստուգում

C++ լեզուն առաջարկում է ճյուղավորման ու կրկնությունների կազմակերպման սովորական դարձած հրամանները, ինչպիսիք են `if` հրամանը, `switch` հրամանը, `while` ցիկլը և `for` ցիկլը։ Օրինակ, ստորև սահմանված է ֆունկցիա, որն օգտագործողին մի հարց է տալիս և վերադարձնում է պատասխանն արտահայտող տրամաբանական արժեքը։

````C++
bool accept()
{
    cout << "Do you want to proceed (y or n)?\n"; // արտածել հարցը

    char answer = 0; // տալ արժեք, որը չի հանդիպելու պատասխանի մեջ
    cin >> answer;    // կարդալ պատասխանը

    if(answer == 'y')
        return true;
    return false;
}
````

`<<` (տեղադրել) արտածման օպերատորին պատասխանելու համար օգտագործվել է `>>` (ստանալ) ներմուծման օպերատորը; `cin`֊ը ներմուծման ստանդարտ հոսքն է (գլուխ 8)։ `>>` օպերատորի աջակողմյան օպերանդը որոշում է, թե ինչ է պետք ներմուծել և այդ աջակողմյան օպերանդը նշան է ներմուծման գործողության համար։ `\n` սիմվոլը արտածվող տողի վերջում ցույց է տալիս նոր տող (§1.3)։

Ուշադրություն դաձրեք, որ `answer` փոփոխականի սահմանումը appears where it is needed (and not before that). A declaration can appear anywhere a statement can.

Օրինակը ավելի լավը կդառնա ստանանք նաև `n` («ոչ»֊ համար) պատասխանը․

````c++
bool accept2()
{
    cout<<"Ցանկանու՞մ եք շարունակել (y կամ n)?\n";    //գրում ենք հարցը
    char answer = 0;
    cin>>answer;

    switch(answer){
    case 'y':
        return true;
    case 'n':
        return false;
    default:
        cout<<"Այս պատասխանն ընդունվում է որպես «ոչ»։\n";
        return false;
    }
}
````
 
`switch`-արտահայտությունը ստուգում է արժեքը մի քանի հաստատունների հետ։ Հաստատունների տարբերակները տարբեր են, և եթե ստուգվող արժեքը չի համընկնում ոչ մեկի հետ, ընտրվում է `default` մասը։ Եթե `default` մասը բացակայում է, ոչ մի գործողություն չի կատարվում արժեքի և հաստատունների չհամընկնելու դեպքում։

Կարիք չկա ավարտել `case`֊ը `switch`֊արտահայտությունից վերադարձնելով արժեք։ Հաճախ ցանկանում ենք շարունակել `switch`֊արտահայտությանը հետևող արտահայտությունը։ Դա անում ենք `break` հրամանի միջոցով։ Որպես օրինակ եկեք դիտարկենք չափազանց խելացի, բայց դեռ պրիմիտիվ փարսերի ծրագիր մի վիդեո֊խաղի շատ փոքր հրամանի համար․

````c++
void action()
{
    while(true){
        cout<<"enter action:\n";    //սպասում ենք գործողության
        string act;
        cin>>act;            //
        Point delta{0,0};    //

        for(char ch:act) {
        switch (ch){
        case 'u':    //
        case 'n':    //
            ++delta.y;
            break;
        case 'r':    //
        case 'e':    //
            ++delta.x;
            break;
        //
       default:
            cout<<"I freeaze!\n";
       }
        move(current+delta*scale);
        update_display();
      }
    }

}
````


## 1.10 Խորհուրդներ

1. Այս գլխում շարադրված նյութը մոտավորապես համապատասխանում է այն նյութին, որը շատ ավելի մանրամասնորեն նկարագրված է  «Stroustrup, 2013» գրքի, 5-6, 9-10 և 12 գլուխներում։
2. Խուճապի մի՛ մատնվեք։ Ամեն ինչ ավելի հասկանալի կլինի ժամանակի ընթացքում, §1.1։
3. C++ լեզվով լավ ծրագրեր գրելու համար պարտադիր չէ իմանալ բոլոր մանրուքները։
4. Կենտրոնացե՛ք ծրագրավորման մեթոդների (տեխնիկական հնարքների) և ոչ թե լեզվական առանձնահատկությունների վրա։
5. Լեզվի սահմանման հարցերի (տարաձայնությունների) մասին վերջնական խոսքի համար նայեք ISO C++ ստանդարտը, §14.1.3։
6. «Փաթեթի» իմաստ ունեցող գործողությունները անվանվել են ֆունկցիաներ, §1.4։
7. Ֆունկցիան պետք է իրականացնի ընդամենը մեկ տրամաբանական գործողություն, §1.4։
8. Ֆունկցիաները պահպանեք կարճ տեսքով, §1.4։
9. Օգտագործե՛ք գերբեռնման հնարավորությունը, երբ ֆունկցիաներն իրականացնում եմ գաղափարային նույն խնդիրը տարբեր տիպերի համար, §1.4։
10. Եթե ֆունկցիան պետք է հաշվարկվի կոմպիլյացիայի ժամանակ, հայտարարեք այն `constexpr`, §1.7։ 
11. Avoid ‘‘magic constants;’’ use symbolic constants; §1.7.
12․ Յուրաքանչյուր հայտարարությունում հայտարարեք մեկ անուն (միայն)։
13. Ընթացիկ և լոկալ անունները պահպանեք կարճ տեսքով, իսկ ոչ սովորական և ոչ լոկալ անունները՝ ավելի երկար տեսքերով։
14. Խուսափեք իրար նման անուններից։
15. Խուսափեք մեծատառերով անուններից։
16. Նախընտրեք `{}`-ինիցիալիզատորը այն հայտարարություններում, որտեղ տիպը անվանված է, §1.5։
17. Նախընտրեք `=` սինտաքսիսը ինիցիալիզացիայի համար այն հայտարարություններում, որտեղ օգտագործվում է `auto` բառը,§1.5։
18. Խուսափեք ոչ ինիցիալիզացված փոփոխականներից, §1.5։
19. Պահեք փոքր տեսանելիության տիրույթներ, §1.6։
20. Ցուցիչների օգտագործումը թող լինի պարզ և բաց,§1.8։
21. Օգտագործեք `nullptr` ավելի հաճախ, քան `0` կամ `NULL`, §1.8։
22. Պետք չէ հայտարարել փոփոխական, քանի դեռ չունեք սկզբնական արժեք նրա համար, §1.8, §1.9։
23. Պետք չէ մեկնաբանության մեջ գրել այնպիսի բան, որը կոդում հստակ երևում է։
24. State intent in comments.
25. Maintain a consistent indentation style.
26. Խուսափեք բարդ արտահայտություններից։
27. Խուսափեք նեղացող ձևափոխումներից, §1.5։




























