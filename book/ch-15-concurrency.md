# Զուգահեռություն

Keep it simple: as simple as possible, but no simpler.
– A. Einstein

* Ներածություն
* Խնդիրներ և `thread`-ներ
* Արգումենտների փոխանցումը
* Արդյունքների վերադարձնելը
* Տվյալների համատեղ օգտագործումը
* Պատահարներին սպասելը
* Խնդիրների հաղորդակցությունը
  - `future` և `promise`
  - `packaged_task`
  - `async()`
* Խորհուրդներ


## Ներածություն

Զուգահեռությունը՝ մի քանի խնդիրների համաժամանակյա կատարումը, լայնորեն օգտագործվում է ծրագրերի թողունակության (մի հաշվարկի համար մի քանի պրոցեսորների օգտագործմամբ) կամ արձագանքելիության (թույլ տալով ծրագրի մի մասին քատարվել, քանի դեռ մի այլ մաս սպասում է պատասխանի) լավացման համար։ Բոլոր ժամանակակից ծրագրավորման լեզուները տասլիս են այս հնարավորությունը։ C++ լեզվի ստանդարտ գրադարանի տրամադրածը տեղափոխելի և տիպերի տեսակետից ապահով տարբերակն է այն եղանակի, որը ավելի քան 20 տարի օգտագործվել է C++ լեզվում և ապահովվում է համարյա բոլոր ժամանակակից ապարատային միջոցներով։ Ստանդարտ գրադարանի տրամադրածը առաջին հերթին նախատեսված է համակարգի մակարդակում զուգահեռության ապահովման համար, այլ ոչ թե բարձր մակարդակի զուգահեռացման բարդ մոդելների ուղղակի տրամադրման համար. վերջիններս կարող են ապահովվել որպես ստանդարտ գրադարանի հնարավորություններն օգտագործող գրադարաններ։

Ստանդարտ գրադարանը ուղղակիորեն ապահովում է նույն հասցեների տիրույթում մի քանի հոսքերի (thread) զուգահեռ կատարումը։ Դա թույլատրելու համար C++ լեզուն տրամադրում է հիշողության համապատասխան մոդել և ատոմար գործողությունների բազմություն։ Ատոմար գործողությունները փականներից ազատ (lock-free) ծրագրավորման հնարավորություն են տալիս [Dechev,2010]։ Հիշողության այս մոդելը երաշխավորում է, որ քանի դեռ ծրագրավորողը խուսափում է տվյալների մրցավազքից? (data race) (փոփոխելի տվյալներին անվերահսկելի դիմումը), ամեն ինչ աշխատում է սպասածին պես։ Այնուամենայնիվ, օգտագործողների մեծամասնությունը զուգահեռությունը կտեսնեն միայն ստանդարտ գրադարանի կամ նրա հնարավորություններով կառուցված այլ գրադարանների տերմիններով։ Այս բաժնում բերվում են ստանդարտ գրադարանի՝ զուգահեռությունն ապահովող միջոցների՝ `thread`-ներ, `mutex`-ներ, `lock()` գործողություններ, `packaged_task`-եր և `future`-ներ, հակիրճ օրինակներ։ Այդ միջոցները կառուցված են հենց օպերացիոն համակարգի տրամադրած հնարավորությունների վրա և չեն բերում արտադրողականության նվազեցման։ Դրանք ոչ էլ երաշխավորում են արտադրողականության լավացում՝ համեմատած օպերացիոն համակարգի տրամադրած միջոցներին։ (??)

Զուգահեռ կատարումը մի՛ ընդունեք որպես համադարման։ Եթե խնդիրը կարող է կատարվել հաջորդական եղանակով, ապա հաճախ ավելի պարզ ու արագ է այդպես էլ անել։

Որպես զուգահեռացման միջոցների բացահայտ օգտագործման այլընտրանք մենք հաճախ կարող ենք դիմել զուգահեռացված ալգորիթմների կիրառմանը՝ կատարման տարատեսակ մեխանիզմների օգնությամբ արտադրողականության մեծացման համար (§12.9, §14.3.1)։ (??)


## Խնդիրներ և `thread`-ներ

Այլ հաշվարկների հետ կատարվելու պոտենցիալ հնարավորություն ունեցող հաշվարկին անվանում ենք _խնդիր_ (_task_)։ _Հոսքը_ (thread) ծրագրում խնդրի համակարգային (համակարգի մակարդակի) ներկայացումն է։ Այլ խնդիրների հետ զուգահեռ կատարվող խնդիրը գործարկվում է `std::thread` (`<thread>` ֆայլից) օբյեկտ ստեղծելով և նրա արգումենտում խնդիրը տալով։ Խնդիրը ֆունկցիա է կամ ֆունկցիա օբյեկտ.

````C++
void f();                 // ֆունկցիա

struct F {                // ֆունկցիա օբյեկտ
    void operator()();   // F-ի կանչի օպերատորը (§6.3.2)
};

void user()
{
    thread t1 {f};       // f() executes in separate thread
    thread t2 {F()};     // F()() executes in separate thread

    t1.join();           // սպասել t1-ին
    t2.join();           // սպասել t2-ին
}
````

`join()`-ները երաշխավորում են, որ չենք լքի `user()`-ը, քանի դեռ հոսքերի կատարումը չի ավարտվել։ Հոսքին «միանալ» (join) նշանակում է «սպասել նրա շխատանքի ավարտին»։

Ծրագրի բոլոր հոսքերը համատեղ օգտագործում են նույն հասցեների տիրույթը։ Սրանով հոսքերը տարբերվում են պրոցեսներից, որոնք, ընդհանուր առմամբ, տվյալների ուղղակի համատեղ օգտագործում չունեն։ Քանի որ հոսքերը համատեղ են օգտագործում հասցեների նույն տիրույթը, նրանք կարող են հաղորդակցվել ընդհանուր օբյեկտների միջոցով (§15.5)։ Տյալների մրցավազքից՝ փոփոխականին անկառավարելի միաժամանակյա դիմումից, խուսափելու նպատակով այսպիսի հաղորդակցությունը սովորաբար կառավարվում է փականների (lock) կամ այլ մեխանիզմների միջոցով։

Զուգահեռ խնդիրների ծրագրավորումը կարող է բավականին բարդ լինել։ Դիրարկենք `f` (ֆունկցիա) և `F` (ֆունկցիա-օբյեկտ) խնդիրների մի հնարավոր իրականացում.

````C++
void f()
{
    cout << "Hello ";
}

struct F {
    void operator()() { cout << "Parallel World!\n"; }
};
````

Սա վատ սխալի օրինակ է. այստեղ `f`-ը և `F()`-ը երկուսն էլ `cout` օբյեկտն օգտագործում են առաց սինխրոնիզացիայի որևէ միջոցի։ Ստացված արտածումը կարող է անկանխատեսելի լինել և կարող է տարբերվել ծրագրի տարբեր կատարումների ժամանակ, քանի որ երկու խնդիրների առանձին գործողությունների կատարման կարգը սահմանված չէ։ Ծրագիրը կարող է արտածել շատ «տարօրինակ» արդյունք.

````
PaHerallllel o World!
````

Միայն ստադարտի որոշակի երաշխիքներն են մեզ զերծ պահում `ostream`-ի սահմանման շրջանակներում տվյալների մրցավազքից, որը կարող է բերել ծրագրի վթարային ավարտի։

Զուգահեռ կատարվող ծրագրում խնդիրներ սահմաելիս մեր նպատակն է այդ խնդիրները պահել լիովին անկախ, բացառությամբ այն դեպքերի, երբ նրանք հաղորդակցվում են պարզ ու ակնհայտ եղանակով։ զուգահեռ կատարվող խնդրի մասին պաատկերացում կազմելու ամենապարզ տարբերակը ֆունկցիան է, որը պետք է կատարվի ին կանչողին զուգահեռ։ (?) Դա համար պարզապես պետք է փոխանցենք արգումենտներ, հետ ստանանք արդյունքը և համոզվենք, որ ընդհանուր օգտագործման տվյալներ չկան (չկա տվյալների մրցավազք):


## Արգումենտների փոխանցումը

Իր աշխատանքի համար խնդիրը սովորապար կարիք ունի տվյալների։ Տվյալները (կամ դրանց ցուցիչներն ու հղումները) կարող ենք պարզապես փոխանցել որպես արգումենտներ։ Դիցուք.

````C++
void f(vector<double>& v);    // function do something with v

struct F {                    // function object: do something with v
    vector<double>& v;
    F(vector<double>& vv) :v{vv} { }
    void operator()();       // application operator; §6.3.2
};

int main()
{
    vector<double> some_vec {1,2,3,4,5,6,7,8,9};
    vector<double> vec2 {10,11,12,13,14};

    thread t1 {f,ref(some_vec)};   // f(some_vec) executes in a separate thread
    thread t2 {F{vec2}};           // F(vec2)() executes in a separate thread

    t1.join();
    t2.join();
}
````

Ակնհայտ է, որ `F{vec2}`-ը արգումենտում տրված վեկտորի հղումը պահում է `F`-ի մեջ։ Այժմ `F`-ը կարող է օգտագործել այդ վեկտորը, և հույս ունենանք, որ որևէ այլ խնդիր չի դումում `vec2`-ին, քանի դեռ `F`-ը կատարվում է։ `vec2`-ը որպես արժեք փոխանցելով կբացառենք այդ վտանգը։

`{f,ref(some_vec)}` տեսքի ինիցիալիզացիան օգտագործում է `thread` կաղապարի վարիադիկ կոնստրուկտորը, որը կարող է ընդունել արգումենտների կամայական հաջորդականություն (§7.4)։ `ref()`-ը տիպի ֆունկցիա է `<functional>`-ից, որը ցավոք անհրաժեշտ է, որպեսզի վարիադիկ կաղապարը `some_vec`-ը համարի հղում, այլ ոչ թե օբյեկտ։ Առանց այս `ref()`-ի `some_vec`-ը կփոխանցվի որպես արժեք։ Կոմպիլյատորը ստուգում է, որ առաջին արգումենտը կարող է կանչվել հաջորդիվ տրված արգումենտներով և կառուցում է համապատասխան ֆունկցիա-օբյեկտը՝ հոսքին փոխանցելու համար։ Այսինքն, եթե `F::operator()()`-ը և `f()`-ը իրականացնում են նույն ալգորիթմը, ապա երկու խնդիրների կատարումը համարյա համարժեք է. երկու դեպքում էլ `thread`-ի կատարման համար ստեղծվում է ֆունկցիա-օբյեկտ։


## Արդյունքների վերադարձնելը

§15.3-ի օրինակում ես արգումենտները փոխանցեցի որպես ոչ-`const` հղում։ Այդպես անում եմ միայն երբ ուզում եմ, որ խնդիրը կարողանա փոփոխել հղվող արժեքը (§1.7)։ Սա  արժեք վերադարձնելու մի քիչ կոպիտ, բայց տարածված եղանակ է։ Ավելի պակաս մշուշոտ հնարքն է՝ մուտքային տվյալները փոխանցել `const` հղումներով, և առանձին արգումենտով էլ փոխանցել այն տեղը, որտեղ պետք է գրվի վերադարձվող արժեքը.

````C++
void f(const vector<double>& v, double* res);    // take input from v; place result in *res

class F {
public:
    F(const vector<double>& vv, double* p) :v{vv}, res{p} { }
    void operator()();          // place result in *res
private:
    const vector<double>& v;    // source of input
    double* res;                // target for output
};

double g(const vector<double>&); // use return value

void user(vector<double>& vec1, vector<double> vec2, vector<double> vec3)
{
    double res1;
    double res2;
    double res3;

    thread t1 {f,cref(vec1),&res1};        // f(vec1,&res1) executes in a separate thread
    thread t2 {F{vec2,&res2}};             // F{vec2,&res2}() executes in a separate thread
    thread t3 {[&](){res3 = g(vec3);}};    // capture local variables by reference

    t1.join();
    t2.join();
    t3.join();

    cout << res1 << ' ' << res2 << ' ' << res3 << '\n';
}
````

Աշխատում է և այս եղանակն էլ բավականին տարածված է, սակայն հղման միջոցով արժեք վերադարձնելը ես բավականաչափ էլեգանտ չեմ համարում, այդ պատճառով էլ այս թեմային նորից կանդրադառնամ §15.7.1-ում։

## Տվյալների համատեղ օգտագործումը

Երբեմն անհրաժեշտ է լինում, որ խնդիրները տվյալները համատեղ օգտագործեն։ Այդ դեպքում տվյալներին հասանելիությունը պետք է համաձայնեցնել այնպես, որ ժամանակի որևէ պահի միայն մեկ խնդիր կարողանա օգտագործել դրանք։ Փորձառու ծրագրավորողները կասեն որ սա շատ պարզեցված է (այսինքն, ոչ մի վտանգ չկա, երբ մի քանի խնդիրներ միաժամանակ կարդում են անփոփոխելի տվյալները), բայց, այնուամենայնիվ, դիտարկենք, թե ինչպես կարելի է երաշխավորել, որ ժամանակի տվյալ պահին տվյալների բազմությանը դիմի առավելագույնը մեկ խնդիր։ (??)

Այս խնդրի լուծման հիմնարար տարրը `mutex`-ն է՝ «mutual exclusion object» — «փոխադարձ բացառման օբյեկտը»։ `thread`-ը `mutex`-ին տիրանում է `lock()` գործողության միջոցով.

````C++
mutex m; // controlling mutex
int sh;  // shared data

void f()
{
    scoped_lock lck {m};        // acquire mutex
    sh += 7;                    // manipulate shared data
}    // release mutex implicitly
````

`lck`-ի տիպը արտածվում է որպես `scoped_lock<mutex>` (§6.2.3)։ `scoped_lock`-ի կոնստրուկտորը տիրանում է `mutex`-ին (`m.lock()` կանչով)։ Եթե մի այլ հոսք արդեն տիրացել է մյուտեքսին, ապա այս հոսքը սպասում է (“blocks”) այնքան, մինչև մյուս հոսքը վերջացնի տվյալներին դիմելու իր գործողությունը։ Հենց որ հոսքը վերջացնում է ընդհանուր օգտագործվող տվյալների հետ իր աշխատանքը, `scoped_lock`-ը ազատում է `mutex`-ը (`m.unlock()` կանչով)։ Երբ մյուտեքսն ազատվում է, նրան սպասող հոսքերը շարունակում են իրենց աշխատանքը՝ «արթնանում են»։ Փոխադարձ բացառման և փականների մեխանիզմները սահմանված են `<mutex>`-ում։

Ուշադրություն դարձրեք RAII սկզբունքի կիրառմանը (§5.3)։ Ռեսուրսների նկարագրիչների օգտագործումը, ինչպիսիք են `scoped_lock`-ը և `unique_lock`-ը (§15.6), ավելի պարզ ու ապահով է, քան `mutex`-ի ուղղակի locking and unlocking։ (??)

Համատեղ օգտագործվող տվյալների և `mutex`-ի կապը պայմանական է. ծրագրավորողը պարզապես պարտավոր է իմանալ, թե որ `mutex`-ը որ տվյալների համար է նախատեսված։ Ակնհայտ է, որ սա հղի է սխալներով, և նույնպես ակնհայտ է, որ մենք փորձելու ենք համապատասխանությունը պարզաբանել լեզվի զանազան միջոցների կիրառմամբ։ Օրինակ.

````C++
class Record {
public:
    mutex rm;
    // ...
};
````

Պետք չէ հանճար լինել՝ գլխի ընկնելու համար, որ `rec` `Record`-ի այլ մասերին դիմելու համար պետք է նախ տիրանալ `rec.rm`-ին, չնայած ընթերցողին օգտակար կլինեին նաև ավելի լավ ընտրված անունը կամ մեկնաբանությունը։ (??)

Քիչ չեն այն դեպքերը, երբ ինչ-որ գործողության համար միաժամանակ հասանելիություն է պետք մի քանի ռեսուրսների։ Սա կարող է բերել փակուղու? (deadlock)։ Օրինակ, եթե `thread1`-ը տիրանում է `mutex1`-ին, ապա փորձում է տիրանալ `mutex2`-ին, իսկ `thread2`-ը տիրանում է `mutex2`-ին, ապա փորձում է տիրանալ `mutex1`-ին. արդյունքում խնդիրը երբեք առաջ չի գնա։ (?) `scoped_lock`-ը հնարավորություն է տալիս միաժամանակ տիրանալ մի քանի փականների.

````C++
void f()
{
    scoped_lock lck {mutex1,mutex2,mutex3};   // acquire all three locks
    // ... manipulate shared data ...
}// implicitly release all mutexes
````

Այս `scoped_lock`-ը թույլ կտա ֆունկցիայի աշխատանքը շարունակել միայն իր արգումենտներում տրված բոլոր մյութեքսներին տիրանալուց հետո and will never block (“go to sleep”) while holding a mutex. `scoped_lock`-ի դեստրուկտորը երաշխավորում է, որ երբ հասք լքի իր տիրույթը, ապա `mutex`-ները կազատվեն։

Համատեղ օգտագործվող տվյալների միջոցով հաղորդակցվելը ցածր մակարդակի հնարք է։ Մասնավորապես, ծրագրավորողը պետք է մտածի ճանապարհներ, որպեսզի հետևի, թե ինչ աշխատանք է արվել կամ մնացել տարբեր խնդիրներում։ (?) Այդ պատճառով էլ համատեղ օգտագործվող տվյալների օգտագործումը զիջում է կանչի և վերադարձի գաղափարին։ (?) Մյուս կողմից էլ, որոշ մարդիկ համոզված են, որ համատեղ օգտագործումը պիտի ավելի արդյունավետ լինի, քան արգումենտների պատճենումն ու արժեք վերադարձնելը։ Թերևս կարող է այդպես լինել՝ երբ ներգրավված են տվյալների մեծ կտորներ, սակայն locking and unlocking համեմատաբար թանկ գործողություններ են։ Մյուս կողմից էլ՝ ժամանակակից մեքենաները շատ հաջող են տվյալների պատճենման գործում, հատկապես կոմպակտ տվյալների, ինչպիսիք են `vector`-ի տարրերը։ Այսպիսով, հոսքերի հաղորդակցության համար մի ընտրեք համատեղ օգտագործվող տվյալները՝ պատճառաբանելով «արդյունավետությունը», առանց կշռադատելու և ցանկալի է ոչ առանց չափումների։ (?!)

Սովորական `mutex`-ը թույլ է տալիս, որ տվյալը միաժամանակ հասանելի լինի միայն մեկ հասքի։ Տվյալների համատեղ օգտագործման տարածված եղանակներից մեկը շատ կարդացողներ և մեկ գրող ունենալն է։ Այս «կարդացող-գրող կողպեքի» դաղափարը տրամադրում է `share_mutex`-ը։ Կարդացողը մյութեքսին կտիրանա՝ թույլատրելով համատեղ օգտագործումը այնպես, որ այլ կարդացողներ նույնպես տվյալներին հասանելիություն ունենան, մինչդեռ գրողը կպահանջի տվյալների բացառիկ հասանելիություն։ Օրինակ.

````C++
shared_mutex mx;          // mutex-ը կարող է համատեղ օգտագործվել

void reader()
{
    shared_lock lck {mx};  // ցանկալի է այլոց հետ համատեղ օգտագործումը
    // ... կարդալ ...
}

void writer()
{
    unique_lock lck {mx};   // պահանջվում է բացառիկ, միանձնյա հասանելիություն
    // ... գրել ...
}
````


## Պատահարներին սպասելը

Երբեմն հասքը պետք է սպասի ինչ-որ արտաքին պատահարի, ինչպիսին է մեկ այլ հոսքի՝ աշխատանք ավարտելը, կամ որոշակի ժամանակ լրանալը։ Պարզագույն «պատահարը» ժամանակի լրանալն է։ `<chrono`-ում սահմանված հնարավորություններն օգտագործելով կարող եմ գրել.

````C++
using namespace std::chrono;    // տես §13.7

auto t0 = high_resolution_clock::now();
this_thread::sleep_for(milliseconds{20});
auto t1 = high_resolution_clock::now();

cout << duration_cast<nanoseconds>(t1−t0).count() << " nanoseconds passed\n";
````

Ուշադրություն դարձրեք, որ ես նույնիսկ նոր հոսք չգործարկեցի. լռելությամբ `this_thread`-ը հղվում է մեկ ու միակ հոսքի։ (?)

Ես `duration_cast`-ն օգտագործել եմ ինձ հարկավոր նանովարկյանների ձևափոխելու համար։
