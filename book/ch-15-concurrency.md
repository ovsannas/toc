# Զուգահեռություն

Keep it simple: as simple as possible, but no simpler.
– A. Einstein

* Ներածություն
* Խնդիրներ և `thread`-ներ
* Արգումենտների փոխանցումը
* Արդյունքների վերադարձը
* Տվյալների համատեղ օգտագործումը
* Պատահարներին սպասելը
* Խնդիրների փոխգործակցությունը
  - `future` և `promise`
  - `packaged_task`
  - `async()`
* Խորհուրդներ


## Ներածություն

Զուգահեռությունը՝ մի քանի խնդիրների համաժամանակյա կատարումը, լայնորեն օգտագործվում է ծրագրերի թողունակության (մի հաշվարկի համար մի քանի պրոցեսորների օգտագործմամբ) կամ արձագանքելիության (թույլ տալով ծրագրի մի մասին քատարվել, քանի դեռ մի այլ մաս սպասում է պատասխանի) լավացման համար։ Բոլոր ժամանակակից ծրագրավորման լեզուները տասլիս են այս հնարավորությունը։ C++ լեզվի ստանդարտ գրադարանի տրամադրածը տեղափոխելի և տիպերի տեսակետից ապահով տարբերակն է այն եղանակի, որը ավելի քան 20 տարի օգտագործվել է C++ լեզվում և ապահովվում է համարյա բոլոր ժամանակակից ապարատային միջոցներով։ Ստանդարտ գրադարանի տրամադրածը առաջին հերթին նախատեսված է համակարգի մակարդակում զուգահեռության ապահովման համար, այլ ոչ թե բարձր մակարդակի զուգահեռացման բարդ մոդելների ուղղակի տրամադրման համար. վերջիններս կարող են ապահովվել որպես ստանդարտ գրադարանի հնարավորություններն օգտագործող գրադարաններ։

Ստանդարտ գրադարանը ուղղակիորեն ապահովում է նույն հասցեների տիրույթում մի քանի հոսքերի (thread) զուգահեռ կատարումը։ Դա թույլատրելու համար C++ լեզուն տրամադրում է հիշողության համապատասխան մոդել և ատոմար գործողությունների բազմություն։ Ատոմար գործողությունները փականներից ազատ (lock-free) ծրագրավորման հնարավորություն են տալիս [Dechev,2010]։ Հիշողության այս մոդելը երաշխավորում է, որ քանի դեռ ծրագրավորողը խուսափում է տվյալների մրցավազքից? (data race) (փոփոխելի տվյալներին անվերահսկելի դիմումը), ամեն ինչ աշխատում է սպասածին պես։ Այնուամենայնիվ, օգտագործողների մեծամասնությունը զուգահեռությունը կտեսնեն միայն ստանդարտ գրադարանի կամ նրա հնարավորություններով կառուցված այլ գրադարանների տերմիններով։ Այս բաժնում բերվում են ստանդարտ գրադարանի՝ զուգահեռությունն ապահովող միջոցների՝ `thread`-ներ, `mutexe`-ներ, `lock()` գործողություններ, `packaged_task`-եր և `future`-ներ, հակիրճ օրինակներ։ Այդ միջոցները կառուցված են հենց օպերացիոն համակարգի տրամադրած հնարավորությունների վրա և չեն բերում արտադրողականության նվազեցման։ Դրանք ոչ էլ երաշխավորում են արտադրողականության լավացում՝ համեմատած օպերացիոն համակարգի տրամադրած միջոցներին։ (??)

Զուգահեռ կատարումը մի՛ ընդունեք որպես համադարման։ Եթե խնդիրը կարող է կատարվել հաջորդական եղանակով, ապա հաճախ ավելի պարզ ու արագ է այդպես էլ անել։

Որպես զուգահեռացման միջոցների բացահայտ օգտագործման այլընտրանք մենք հաճախ կարող ենք դիմել զուգահեռացված ալգորիթմների կիրառմանը՝ կատարման տարատեսակ մեխանիզմների օգնությամբ արտադրողականության մեծացման համար (§12.9, §14.3.1)։ (??)


## Խնդիրներ և `thread`-ներ

Այլ հաշվարկների հետ կատարվելու պոտենցիալ հնարավորություն ունեցող հաշվարկին անվանում ենք _խնդիր_ (_task_)։ _Հոսքը_ (thread) ծրագրում խնդրի համակարգային (համակարգի մակարդակի) ներկայացումն է։ Այլ խնդիրների հետ զուգահեռ կատարվող խնդիրը գործարկվում է `std::thread` (`<thread>` ֆայլից) օբյեկտ ստեղծելով և նրա արգումենտում խնդիրը տալով։ Խնդիրը ֆունկցիա է կամ ֆունկցիա օբյեկտ.

````C++
void f();                 // ֆունկցիա

struct F {                // ֆունկցիա օբյեկտ
    void operator()();   // F-ի կանչի օպերատորը (§6.3.2)
};

void user()
{
    thread t1 {f};       // f() executes in separate thread
    thread t2 {F()};     // F()() executes in separate thread

    t1.join();           // սպասել t1-ին
    t2.join();           // սպասել t2-ին
}
````

`join()`-ները երաշխավորում են, որ չենք լքի `user()`-ը, քանի դեռ հոսքերի կատարումը չի ավարտվել։ Հոսքին «միանալ» (join) նշանակում է «սպասել նրա շխատանքի ավարտին»։
