# Զուգահեռություն

Keep it simple: as simple as possible, but no simpler.
– A. Einstein

* Ներածություն
* Խնդիրներ և `thread`-ներ
* Արգումենտների փոխանցումը
* Արդյունքների վերադարձը
* Տվյալների համատեղ օգտագործումը
* Պատահարներին սպասելը
* Խնդիրների հաղորդակցությունը
  - `future` և `promise`
  - `packaged_task`
  - `async()`
* Խորհուրդներ


## Ներածություն

Զուգահեռությունը՝ մի քանի խնդիրների համաժամանակյա կատարումը, լայնորեն օգտագործվում է ծրագրերի թողունակության (մի հաշվարկի համար մի քանի պրոցեսորների օգտագործմամբ) կամ արձագանքելիության (թույլ տալով ծրագրի մի մասին քատարվել, քանի դեռ մի այլ մաս սպասում է պատասխանի) լավացման համար։ Բոլոր ժամանակակից ծրագրավորման լեզուները տասլիս են այս հնարավորությունը։ C++ լեզվի ստանդարտ գրադարանի տրամադրածը տեղափոխելի և տիպերի տեսակետից ապահով տարբերակն է այն եղանակի, որը ավելի քան 20 տարի օգտագործվել է C++ լեզվում և ապահովվում է համարյա բոլոր ժամանակակից ապարատային միջոցներով։ Ստանդարտ գրադարանի տրամադրածը առաջին հերթին նախատեսված է համակարգի մակարդակում զուգահեռության ապահովման համար, այլ ոչ թե բարձր մակարդակի զուգահեռացման բարդ մոդելների ուղղակի տրամադրման համար. վերջիններս կարող են ապահովվել որպես ստանդարտ գրադարանի հնարավորություններն օգտագործող գրադարաններ։

Ստանդարտ գրադարանը ուղղակիորեն ապահովում է նույն հասցեների տիրույթում մի քանի հոսքերի (thread) զուգահեռ կատարումը։ Դա թույլատրելու համար C++ լեզուն տրամադրում է հիշողության համապատասխան մոդել և ատոմար գործողությունների բազմություն։ Ատոմար գործողությունները փականներից ազատ (lock-free) ծրագրավորման հնարավորություն են տալիս [Dechev,2010]։ Հիշողության այս մոդելը երաշխավորում է, որ քանի դեռ ծրագրավորողը խուսափում է տվյալների մրցավազքից? (data race) (փոփոխելի տվյալներին անվերահսկելի դիմումը), ամեն ինչ աշխատում է սպասածին պես։ Այնուամենայնիվ, օգտագործողների մեծամասնությունը զուգահեռությունը կտեսնեն միայն ստանդարտ գրադարանի կամ նրա հնարավորություններով կառուցված այլ գրադարանների տերմիններով։ Այս բաժնում բերվում են ստանդարտ գրադարանի՝ զուգահեռությունն ապահովող միջոցների՝ `thread`-ներ, `mutex`-ներ, `lock()` գործողություններ, `packaged_task`-եր և `future`-ներ, հակիրճ օրինակներ։ Այդ միջոցները կառուցված են հենց օպերացիոն համակարգի տրամադրած հնարավորությունների վրա և չեն բերում արտադրողականության նվազեցման։ Դրանք ոչ էլ երաշխավորում են արտադրողականության լավացում՝ համեմատած օպերացիոն համակարգի տրամադրած միջոցներին։ (??)

Զուգահեռ կատարումը մի՛ ընդունեք որպես համադարման։ Եթե խնդիրը կարող է կատարվել հաջորդական եղանակով, ապա հաճախ ավելի պարզ ու արագ է այդպես էլ անել։

Որպես զուգահեռացման միջոցների բացահայտ օգտագործման այլընտրանք մենք հաճախ կարող ենք դիմել զուգահեռացված ալգորիթմների կիրառմանը՝ կատարման տարատեսակ մեխանիզմների օգնությամբ արտադրողականության մեծացման համար (§12.9, §14.3.1)։ (??)


## Խնդիրներ և `thread`-ներ

Այլ հաշվարկների հետ կատարվելու պոտենցիալ հնարավորություն ունեցող հաշվարկին անվանում ենք _խնդիր_ (_task_)։ _Հոսքը_ (thread) ծրագրում խնդրի համակարգային (համակարգի մակարդակի) ներկայացումն է։ Այլ խնդիրների հետ զուգահեռ կատարվող խնդիրը գործարկվում է `std::thread` (`<thread>` ֆայլից) օբյեկտ ստեղծելով և նրա արգումենտում խնդիրը տալով։ Խնդիրը ֆունկցիա է կամ ֆունկցիա օբյեկտ.

````C++
void f();                 // ֆունկցիա

struct F {                // ֆունկցիա օբյեկտ
    void operator()();   // F-ի կանչի օպերատորը (§6.3.2)
};

void user()
{
    thread t1 {f};       // f() executes in separate thread
    thread t2 {F()};     // F()() executes in separate thread

    t1.join();           // սպասել t1-ին
    t2.join();           // սպասել t2-ին
}
````

`join()`-ները երաշխավորում են, որ չենք լքի `user()`-ը, քանի դեռ հոսքերի կատարումը չի ավարտվել։ Հոսքին «միանալ» (join) նշանակում է «սպասել նրա շխատանքի ավարտին»։

Ծրագրի բոլոր հոսքերը համատեղ օգտագործում են նույն հասցեների տիրույթը։ Սրանով հոսքերը տարբերվում են պրոցեսներից, որոնք, ընդհանուր առմամբ, տվյալների ուղղակի համատեղ օգտագործում չունեն։ Քանի որ հոսքերը համատեղ են օգտագործում հասցեների նույն տիրույթը, նրանք կարող են հաղորդակցվել ընդհանուր օբյեկտների միջոցով (§15.5)։ Տյալների մրցավազքից՝ փոփոխականին անկառավարելի միաժամանակյա դիմումից, խուսափելու նպատակով այսպիսի հաղորդակցությունը սովորաբար կառավարվում է փականների (lock) կամ այլ մեխանիզմների միջոցով։

Զուգահեռ խնդիրների ծրագրավորումը կարող է բավականին բարդ լինել։ Դիրարկենք `f` (ֆունկցիա) և `F` (ֆունկցիա-օբյեկտ) խնդիրների մի հնարավոր իրականացում.

````C++
void f()
{
    cout << "Hello ";
}

struct F {
    void operator()() { cout << "Parallel World!\n"; }
};
````

Սա վատ սխալի օրինակ է. այստեղ `f`-ը և `F()`-ը երկուսն էլ `cout` օբյեկտն օգտագործում են առաց սինխրոնիզացիայի որևէ միջոցի։ Ստացված արտածումը կարող է անկանխատեսելի լինել և կարող է տարբերվել ծրագրի տարբեր կատարումների ժամանակ, քանի որ երկու խնդիրների առանձին գործողությունների կատարման կարգը սահմանված չէ։ Ծրագիրը կարող է արտածել շատ «տարօրինակ» արդյունք.

````
PaHerallllel o World!
````

Միայն ստադարտի որոշակի երաշխիքներն են մեզ զերծ պահում `ostream`-ի սահմանման շրջանակներում տվյալների մրցավազքից, որը կարող է բերել ծրագրի վթարային ավարտի։

Զուգահեռ կատարվող ծրագրում խնդիրներ սահմաելիս մեր նպատակն է այդ խնդիրները պահել լիովին անկախ, բացառությամբ այն դեպքերի, երբ նրանք հաղորդակցվում են պարզ ու ակնհայտ եղանակով։ զուգահեռ կատարվող խնդրի մասին պաատկերացում կազմելու ամենապարզ տարբերակը ֆունկցիան է, որը պետք է կատարվի ին կանչողին զուգահեռ։ (?) Դա համար պարզապես պետք է փոխանցենք արգումենտներ, հետ ստանանք արդյունքը և համոզվենք, որ ընդհանուր օգտագործման տվյալներ չկան (չկա տվյալների մրցավազք):


## Արգումենտների փոխանցումը

Իր աշխատանքի համար խնդիրը սովորապար կարիք ունի տվյալների։ Տվյալները (կամ դրանց ցուցիչներն ու հղումները) կարող ենք պարզապես փոխանցել որպես արգումենտներ։ Դիցուք.

````C++
void f(vector<double>& v);    // function do something with v

struct F {                    // function object: do something with v
    vector<double>& v;
    F(vector<double>& vv) :v{vv} { }
    void operator()();       // application operator; §6.3.2
};

int main()
{
    vector<double> some_vec {1,2,3,4,5,6,7,8,9};
    vector<double> vec2 {10,11,12,13,14};

    thread t1 {f,ref(some_vec)};   // f(some_vec) executes in a separate thread
    thread t2 {F{vec2}};           // F(vec2)() executes in a separate thread

    t1.join();
    t2.join();
}
````

Ակնհայտ է, որ `F{vec2}`-ը արգումենտում տրված վեկտորի հղումը պահում է `F`-ի մեջ։ Այժմ `F`-ը կարող է օգտագործել այդ վեկտորը, և հույս ունենանք, որ որևէ այլ խնդիր չի դումում `vec2`-ին, քանի դեռ `F`-ը կատարվում է։ `vec2`-ը որպես արժեք փոխանցելով կբացառենք այդ վտանգը։

`{f,ref(some_vec)}` տեսքի ինիցիալիզացիան օգտագործում է `thread` կաղապարի վարիադիկ կոնստրուկտորը, որը կարող է ընդունել արգումենտների կամայական հաջորդականություն (§7.4)։ `ref()`-ը տիպի ֆունկցիա է `<functional>`-ից, որը ցավոք անհրաժեշտ է, որպեսզի վարիադիկ կաղապարը `some_vec`-ը համարի հղում, այլ ոչ թե օբյեկտ։ Առանց այս `ref()`-ի `some_vec`-ը կփոխանցվի որպես արժեք։ Կոմպիլյատորը ստուգում է, որ առաջին արգումենտը կարող է կանչվել հաջորդիվ տրված արգումենտներով և կառուցում է համապատասխան ֆունկցիա-օբյեկտը՝ հոսքին փոխանցելու համար։ Այսինքն, եթե `F::operator()()`-ը և `f()`-ը իրականացնում են նույն ալգորիթմը, ապա երկու խնդիրների կատարումը համարյա համարժեք է. երկու դեպքում էլ `thread`-ի կատարման համար ստեղծվում է ֆունկցիա-օբյեկտ։
