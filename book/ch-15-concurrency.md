# Զուգահեռություն

Keep it simple: as simple as possible, but no simpler.
– A. Einstein

* Ներածություն
* Խնդիրներ և `thread`-ներ
* Արգումենտների փոխանցումը
* Արդյունքների վերադարձնելը
* Տվյալների համատեղ օգտագործումը
* Պատահարներին սպասելը
* Խնդիրների հաղորդակցությունը
  - `future` և `promise`
  - `packaged_task`
  - `async()`
* Խորհուրդներ


## Ներածություն

Զուգահեռությունը՝ մի քանի խնդիրների համաժամանակյա կատարումը, լայնորեն օգտագործվում է ծրագրերի թողունակության (մի հաշվարկի համար մի քանի պրոցեսորների օգտագործմամբ) կամ արձագանքելիության (թույլ տալով ծրագրի մի մասին քատարվել, քանի դեռ մի այլ մաս սպասում է պատասխանի) լավացման համար։ Բոլոր ժամանակակից ծրագրավորման լեզուները տասլիս են այս հնարավորությունը։ C++ լեզվի ստանդարտ գրադարանի տրամադրածը տեղափոխելի և տիպերի տեսակետից ապահով տարբերակն է այն եղանակի, որը ավելի քան 20 տարի օգտագործվել է C++ լեզվում և ապահովվում է համարյա բոլոր ժամանակակից ապարատային միջոցներով։ Ստանդարտ գրադարանի տրամադրածը առաջին հերթին նախատեսված է համակարգի մակարդակում զուգահեռության ապահովման համար, այլ ոչ թե բարձր մակարդակի զուգահեռացման բարդ մոդելների ուղղակի տրամադրման համար. վերջիններս կարող են ապահովվել որպես ստանդարտ գրադարանի հնարավորություններն օգտագործող գրադարաններ։

Ստանդարտ գրադարանը ուղղակիորեն ապահովում է նույն հասցեների տիրույթում մի քանի հոսքերի (thread) զուգահեռ կատարումը։ Դա թույլատրելու համար C++ լեզուն տրամադրում է հիշողության համապատասխան մոդել և ատոմար գործողությունների բազմություն։ Ատոմար գործողությունները փականներից ազատ (lock-free) ծրագրավորման հնարավորություն են տալիս [Dechev,2010]։ Հիշողության այս մոդելը երաշխավորում է, որ քանի դեռ ծրագրավորողը խուսափում է տվյալների մրցավազքից? (data race) (փոփոխելի տվյալներին անվերահսկելի դիմումը), ամեն ինչ աշխատում է սպասածին պես։ Այնուամենայնիվ, օգտագործողների մեծամասնությունը զուգահեռությունը կտեսնեն միայն ստանդարտ գրադարանի կամ նրա հնարավորություններով կառուցված այլ գրադարանների տերմիններով։ Այս բաժնում բերվում են ստանդարտ գրադարանի՝ զուգահեռությունն ապահովող միջոցների՝ `thread`-ներ, `mutex`-ներ, `lock()` գործողություններ, `packaged_task`-եր և `future`-ներ, հակիրճ օրինակներ։ Այդ միջոցները կառուցված են հենց օպերացիոն համակարգի տրամադրած հնարավորությունների վրա և չեն բերում արտադրողականության նվազեցման։ Դրանք ոչ էլ երաշխավորում են արտադրողականության լավացում՝ համեմատած օպերացիոն համակարգի տրամադրած միջոցներին։ (??)

Զուգահեռ կատարումը մի՛ ընդունեք որպես համադարման։ Եթե խնդիրը կարող է կատարվել հաջորդական եղանակով, ապա հաճախ ավելի պարզ ու արագ է այդպես էլ անել։

Որպես զուգահեռացման միջոցների բացահայտ օգտագործման այլընտրանք մենք հաճախ կարող ենք դիմել զուգահեռացված ալգորիթմների կիրառմանը՝ կատարման տարատեսակ մեխանիզմների օգնությամբ արտադրողականության մեծացման համար (§12.9, §14.3.1)։ (??)


## Խնդիրներ և `thread`-ներ

Այլ հաշվարկների հետ կատարվելու պոտենցիալ հնարավորություն ունեցող հաշվարկին անվանում ենք _խնդիր_ (_task_)։ _Հոսքը_ (thread) ծրագրում խնդրի համակարգային (համակարգի մակարդակի) ներկայացումն է։ Այլ խնդիրների հետ զուգահեռ կատարվող խնդիրը գործարկվում է `std::thread` (`<thread>` ֆայլից) օբյեկտ ստեղծելով և նրա արգումենտում խնդիրը տալով։ Խնդիրը ֆունկցիա է կամ ֆունկցիա օբյեկտ.

````C++
void f();                 // ֆունկցիա

struct F {                // ֆունկցիա օբյեկտ
    void operator()();   // F-ի կանչի օպերատորը (§6.3.2)
};

void user()
{
    thread t1 {f};       // f() executes in separate thread
    thread t2 {F()};     // F()() executes in separate thread

    t1.join();           // սպասել t1-ին
    t2.join();           // սպասել t2-ին
}
````

`join()`-ները երաշխավորում են, որ չենք լքի `user()`-ը, քանի դեռ հոսքերի կատարումը չի ավարտվել։ Հոսքին «միանալ» (join) նշանակում է «սպասել նրա շխատանքի ավարտին»։

Ծրագրի բոլոր հոսքերը համատեղ օգտագործում են նույն հասցեների տիրույթը։ Սրանով հոսքերը տարբերվում են պրոցեսներից, որոնք, ընդհանուր առմամբ, տվյալների ուղղակի համատեղ օգտագործում չունեն։ Քանի որ հոսքերը համատեղ են օգտագործում հասցեների նույն տիրույթը, նրանք կարող են հաղորդակցվել ընդհանուր օբյեկտների միջոցով (§15.5)։ Տյալների մրցավազքից՝ փոփոխականին անկառավարելի միաժամանակյա դիմումից, խուսափելու նպատակով այսպիսի հաղորդակցությունը սովորաբար կառավարվում է փականների (lock) կամ այլ մեխանիզմների միջոցով։

Զուգահեռ խնդիրների ծրագրավորումը կարող է բավականին բարդ լինել։ Դիրարկենք `f` (ֆունկցիա) և `F` (ֆունկցիա-օբյեկտ) խնդիրների մի հնարավոր իրականացում.

````C++
void f()
{
    cout << "Hello ";
}

struct F {
    void operator()() { cout << "Parallel World!\n"; }
};
````

Սա վատ սխալի օրինակ է. այստեղ `f`-ը և `F()`-ը երկուսն էլ `cout` օբյեկտն օգտագործում են առաց սինխրոնիզացիայի որևէ միջոցի։ Ստացված արտածումը կարող է անկանխատեսելի լինել և կարող է տարբերվել ծրագրի տարբեր կատարումների ժամանակ, քանի որ երկու խնդիրների առանձին գործողությունների կատարման կարգը սահմանված չէ։ Ծրագիրը կարող է արտածել շատ «տարօրինակ» արդյունք.

````
PaHerallllel o World!
````

Միայն ստադարտի որոշակի երաշխիքներն են մեզ զերծ պահում `ostream`-ի սահմանման շրջանակներում տվյալների մրցավազքից, որը կարող է բերել ծրագրի վթարային ավարտի։

Զուգահեռ կատարվող ծրագրում խնդիրներ սահմաելիս մեր նպատակն է այդ խնդիրները պահել լիովին անկախ, բացառությամբ այն դեպքերի, երբ նրանք հաղորդակցվում են պարզ ու ակնհայտ եղանակով։ զուգահեռ կատարվող խնդրի մասին պաատկերացում կազմելու ամենապարզ տարբերակը ֆունկցիան է, որը պետք է կատարվի ին կանչողին զուգահեռ։ (?) Դա համար պարզապես պետք է փոխանցենք արգումենտներ, հետ ստանանք արդյունքը և համոզվենք, որ ընդհանուր օգտագործման տվյալներ չկան (չկա տվյալների մրցավազք):


## Արգումենտների փոխանցումը

Իր աշխատանքի համար խնդիրը սովորապար կարիք ունի տվյալների։ Տվյալները (կամ դրանց ցուցիչներն ու հղումները) կարող ենք պարզապես փոխանցել որպես արգումենտներ։ Դիցուք.

````C++
void f(vector<double>& v);    // function do something with v

struct F {                    // function object: do something with v
    vector<double>& v;
    F(vector<double>& vv) :v{vv} { }
    void operator()();       // application operator; §6.3.2
};

int main()
{
    vector<double> some_vec {1,2,3,4,5,6,7,8,9};
    vector<double> vec2 {10,11,12,13,14};

    thread t1 {f,ref(some_vec)};   // f(some_vec) executes in a separate thread
    thread t2 {F{vec2}};           // F(vec2)() executes in a separate thread

    t1.join();
    t2.join();
}
````

Ակնհայտ է, որ `F{vec2}`-ը արգումենտում տրված վեկտորի հղումը պահում է `F`-ի մեջ։ Այժմ `F`-ը կարող է օգտագործել այդ վեկտորը, և հույս ունենանք, որ որևէ այլ խնդիր չի դումում `vec2`-ին, քանի դեռ `F`-ը կատարվում է։ `vec2`-ը որպես արժեք փոխանցելով կբացառենք այդ վտանգը։

`{f,ref(some_vec)}` տեսքի ինիցիալիզացիան օգտագործում է `thread` կաղապարի վարիադիկ կոնստրուկտորը, որը կարող է ընդունել արգումենտների կամայական հաջորդականություն (§7.4)։ `ref()`-ը տիպի ֆունկցիա է `<functional>`-ից, որը ցավոք անհրաժեշտ է, որպեսզի վարիադիկ կաղապարը `some_vec`-ը համարի հղում, այլ ոչ թե օբյեկտ։ Առանց այս `ref()`-ի `some_vec`-ը կփոխանցվի որպես արժեք։ Կոմպիլյատորը ստուգում է, որ առաջին արգումենտը կարող է կանչվել հաջորդիվ տրված արգումենտներով և կառուցում է համապատասխան ֆունկցիա-օբյեկտը՝ հոսքին փոխանցելու համար։ Այսինքն, եթե `F::operator()()`-ը և `f()`-ը իրականացնում են նույն ալգորիթմը, ապա երկու խնդիրների կատարումը համարյա համարժեք է. երկու դեպքում էլ `thread`-ի կատարման համար ստեղծվում է ֆունկցիա-օբյեկտ։


## Արդյունքների վերադարձնելը

§15.3-ի օրինակում ես արգումենտները փոխանցեցի որպես ոչ-`const` հղում։ Այդպես անում եմ միայն երբ ուզում եմ, որ խնդիրը կարողանա փոփոխել հղվող արժեքը (§1.7)։ Սա  արժեք վերադարձնելու մի քիչ կոպիտ, բայց տարածված եղանակ է։ Ավելի պակաս մշուշոտ հնարքն է՝ մուտքային տվյալները փոխանցել `const` հղումներով, և առանձին արգումենտով էլ փոխանցել այն տեղը, որտեղ պետք է գրվի վերադարձվող արժեքը.

````C++
void f(const vector<double>& v, double* res);    // take input from v; place result in *res

class F {
public:
    F(const vector<double>& vv, double* p) :v{vv}, res{p} { }
    void operator()();          // place result in *res
private:
    const vector<double>& v;    // source of input
    double* res;                // target for output
};

double g(const vector<double>&); // use return value

void user(vector<double>& vec1, vector<double> vec2, vector<double> vec3)
{
    double res1;
    double res2;
    double res3;

    thread t1 {f,cref(vec1),&res1};        // f(vec1,&res1) executes in a separate thread
    thread t2 {F{vec2,&res2}};             // F{vec2,&res2}() executes in a separate thread
    thread t3 {[&](){res3 = g(vec3);}};    // capture local variables by reference

    t1.join();
    t2.join();
    t3.join();

    cout << res1 << ' ' << res2 << ' ' << res3 << '\n';
}
````

Աշխատում է և այս եղանակն էլ բավականին տարածված է, սակայն հղման միջոցով արժեք վերադարձնելը ես բավականաչափ էլեգանտ չեմ համարում, այդ պատճառով էլ այս թեմային նորից կանդրադառնամ §15.7.1-ում։

## Տվյալների համատեղ օգտագործումը

Երբեմն անհրաժեշտ է լինում, որ խնդիրները տվյալները համատեղ օգտագործեն։ Այդ դեպքում տվյալներին հասանելիությունը պետք է համաձայնեցնել այնպես, որ ժամանակի որևէ պահի միայն մեկ խնդիր կարողանա օգտագործել դրանք։ Փորձառու ծրագրավորողները կասեն որ սա շատ պարզեցված է (այսինքն, ոչ մի վտանգ չկա, երբ մի քանի խնդիրներ միաժամանակ կարդում են անփոփոխելի տվյալները), բայց, այնուամենայնիվ, դիտարկենք, թե ինչպես կարելի է երաշխավորել, որ ժամանակի տվյալ պահին տվյալների բազմությանը դիմի առավելագույնը մեկ խնդիր։ (??)

Այս խնդրի լուծման հիմնարար տարրը `mutex`-ն է՝ «mutual exclusion object» — «փոխադարձ բացառման օբյեկտը»։ `thread`-ը `mutex`-ին տիրանում է `lock()` գործողության միջոցով.

````C++
mutex m; // controlling mutex
int sh;  // shared data

void f()
{
    scoped_lock lck {m};        // acquire mutex
    sh += 7;                    // manipulate shared data
}    // release mutex implicitly
````

`lck`-ի տիպը արտածվում է որպես `scoped_lock<mutex>` (§6.2.3)։ `scoped_lock`-ի կոնստրուկտորը տիրանում է `mutex`-ին (`m.lock()` կանչով)։ Եթե մի այլ հոսք արդեն տիրացել է մյուտեքսին, ապա այս հոսքը սպասում է (“blocks”) այնքան, մինչև մյուս հոսքը վերջացնի տվյալներին դիմելու իր գործողությունը։ Հենց որ հոսքը վերջացնում է ընդհանուր օգտագործվող տվյալների հետ իր աշխատանքը, `scoped_lock`-ը ազատում է `mutex`-ը (`m.unlock()` կանչով)։ Երբ մյուտեքսն ազատվում է, նրան սպասող հոսքերը շարունակում են իրենց աշխատանքը՝ «արթնանում են»։ Փոխադարձ բացառման և փականների մեխանիզմները սահմանված են `<mutex>`-ում։

Ուշադրություն դարձրեք RAII սկզբունքի կիրառմանը (§5.3)։ Ռեսուրսների նկարագրիչների օգտագործումը, ինչպիսիք են `scoped_lock`-ը և `unique_lock`-ը (§15.6), ավելի պարզ ու ապահով է, քան `mutex`-ի ուղղակի locking and unlocking։ (??)
