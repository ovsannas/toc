# 2 Օգտագործողի սահմանած տիպեր

_Խուճապի մի՛ մատնվեք։_

_— Դուգլաս Ադամս_

* Ներածություն
* Ստրուկտուրաներ
* Դասեր
* Միավորումներ
* Թվարկումներ
* Խորհուրդներ


## 2.1 Ներածություն

Ֆունդամենտալ (հիմնական) տիպերի (§1.4), `const` մոդիֆիկատորի (§1.6) և հայտարարման օպերատորների (§1.7) համադրումով կառոցված տիպերը կոչում ենք _ներդրված տիպեր_ (built-in types)։ C++ լեզվի ներդրված տիպերի ու գործողությունների բազմությունը բավականին հարուստ է, բայց դրանք դիտավորյալ թողնված են ցածր մակարդակում։ Դրանք ուղղակիորեն և արդյունավետորեն արտացոլում են սովորական կոմպյուտերի ապարատային հնարավորությունները։ Այնուամենայնիվ, դրանք ծրագրավորողին չեն տրամադրում բարդ ծրագրեր գրելու համար անհրաժեշտ բարձր մակարդակի հնարավորություններ։ Փոխարենը C++ լեզուն ներդրված տիպերն ու գոծողությունները լրացնում է _աբստրակցիայի մեխանիզմների_ համապատասխան բազմությամբ, որից ծրագրավորողները կարող են ստեղծել անհրաժեշտ բարձր մակարդակի միջոցները։ ??

C++ լեզվի աբստրակցիայի մեխանիզմներն առաջին հերթին մշակվել են, որպեսզի ծրագրավորողներին հնարավորություն տրվի մշակել և իրականացնել իրենց սեփական տիպերը՝ համապատասխան ներկայացմամբ և գործողություններով, և որպեսզի ծրագրավորողները կարողանան հեշտությամբ ու նրբորեն օգտագործեն այդ տիպերը։ C++-ի աբստրակցիաների մեխանիզմներով այլ տիպերից կառուցված տիպերը կոչվում են _օգտագործողի սահմանած տիպեր_։ Դրանք հիշատակվում են որպես _դասեր_ և _թվարկումներ_։ ?? Օգտագործողի սահմանած տիպերը կարող են կառուցվել ինչպես ներդրված տիպերից, այնպես էլ օգտագործողի սահմանած այլ տիպերից։ Այս գրքի մեծ մասը նվիրված է օգտագործողի կողմից սահմանված տիպերի մշակմանը, իրականացմանը և օգտագործմանը։ Օգտագործողի սահմանած տիպերը հաճախ նախընտրելի են ներդրված տիպերից, քանի որ դրանց օգտագործումն ավելի պարզ է, ավելի քիչ է սխալների հնարավորությունը, և, որպես կանոն, նույքան արդյունավետ է, որքան ներդրված տիպերի օգտագործումը, միգուցե նաև ավելի արագ։ ??

Այս գլխի շարունակությունը նկարագրում է տիպերի սահմանման և օգտագործման պարզագույն և ամենահիմնարար հնարավորությունները։ 4-7֊րդ գլուխները պարունակում են աբստրակցիայի մեխանիզմների և դրանցով ապահովված ծրագրավորման ոճերի առավել լրիվ նկարագրությունը։ 8-15֊րդ գլուխները ներածություն են ստանդարտ գրադարանի հնարավորություններին, և քանի որ ստանդարտ գրադարանը հիմնականում բաղկացած է օգտագործողի սահմանած տիպերից, այդ գլուխներում բերված են օրինակներ, թե ինչ է հնարավոր կառուցել 1-7-րդ գլուխներում նկարագրված լեզվական միջոցների և ծրագրավորման տեխնիկաների օգտագործմամբ։ ??


## 2.2 Ստրուկտուրաներ

Հաճախ նոր տիպ կառուցելու առաջին քայլը նրան անհրաժեշտ տարրերի ընդգրկումն է տվյալների կառուցվածքի՝ ստրուկտուրայի (`struct`) մեջ.

```C++
struct Vector {
    int sz;          // տարրերի քանակը
    double* elem;    // ցուցիչ տարրերի վրա
};
```

`Vector`֊ի այս նախնական տարբերակը բաղկացած է `int` տիպի և `double*` տիպի տարրերից։

`Vector` տիպի փոփոխականը կարող է սահմանվել հետևյալ կերպ․

```C++
Vector v;
```

Այնուամենայնիվ, սրանից շատ օգուտ չկա, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի ցույց չի տալիս։ Որպեսզի այն օգտակար լինի, մենք պետք է `v`-ին տանք ինչ-որ տարրեր, որոնց վրա այն ցույց կտա։ Օրինակ, `Vector`֊ը մենք կարող ենք կառուցել հետևյալ ձևով․

```C++
void vector_init(Vector& v, int s)
{
    v.elem = new double[s];   // ստեղծել s հատ double տիպի թվերի զանգված
    v.sz = s;
}
```

Ահա, `v`֊ի `elem` անդամն ստանում է ցուցիչ՝ ստեղծված `new` օպերատորի կողմից և `v`֊ի `sz` անդամն ստանում է տարրերի քանակը։ `Vector&` գրառման `&`-ը ցույց է տալիս, որ `v`֊ն մենք փոխանցում ենք որպես ոչ-`const` հղում (§1.7), այդ ձևով `vector_init()` ֆունկցիան կարող է փոփոխություններ անել իրեն փոխանցված վեկտորի հետ։

`new` օպերատորը հիշողություն է առանձնացնում այն տարածքից, որը կոչվում է _ազատ տարածք_ (հայտնի է նաև որպես _դինամիկ հիշողություն_ և _heap_)։ Ազատ տարածքում տեղադրված օբյեկտներն անկախ են այն տեսանելիության տիրույթից, որտեղ ստեղծվել են և «ապրում» են, քանի դեռ չեն ոչնչացվել `delete` հրամանով (§4.2.2)։

`Vector`֊ի մի պարզ կիրառում ունի հետևյալ տեսքը․

````C++
double read_and_sum(int s)
    // կարդալ s ամբողջ թվերը cin֊ից և վերադարձնել նրանց գումարը;
    // ենթադրվում է, որ s-ը պետք է լինի դրական թիվ
{
    Vector v;
    vector_init(v,s);           // առանձնացնել s հատ տարր v-ի համար
    for (int i=0; i!=s; ++i)
        cin >> v.elem[i];       // կարդալ տարրերի մեջ

    double sum = 0;
    for (int i=0; i!=s; ++i)
        sum+=v.elem[i];       // ստանալ տարրերի գումարը
    return sum;
}
````

Գեղեցիկ և ճկուն դառնալու համար, ինչպիսին որ ստանդարտ գրադարանի `vector`֊ն է, մեր `Vector`֊ը դեռ երկար ճանապարհ պիտի անցնի։ Մասնավորապես, `Vector`-ի օգտագործողը պետք է իմանա `Vector`֊ի նկարագրության յուրաքանչյուր մասնիկը։ Այս գլխի մնացած մասը և հաջորդ երկու գլուխները աստիճանաբար զարգացնում են `Vector`֊ը, որպես լեզվի հնարավորությունների և տեխնիկական հնարքների օրինակ։ Գլուխ 11-ը ներկայացնում է ստանդարտ գրադարանի `vector`֊ը, որը պարունակում է բազմաթիվ գեղեցիկ բարելավումներ։

`vector`֊ը և ստանդարտ գրադարանի մյուս բաղադրիչները ես օգտագործում եմ որպես օրինակներ, որպեսզի.
* ցուցադրեմ լեզվական հնարավորություններն ու դիզայնի տեխնիկան, և
* օգնեմ ձեզ սովորել և օգտագործել ստանդարտ գրադարանի բաղադրիչները։

Նորից մի՛ հորինեք ստանդարտ գրադարանի բաղադրիչներն, ինչպիսիք են `vector`֊ը և `string`֊ը, օգտագործեք դրանք։

We use . (dot) to access struct members through a name (and through a reference) and −> to access struct members through a pointer. For example:

Մենք `.`-ը (կետ) օգտագործում ենք `struct`֊ի անդամներին անվան (և հղման) միջոցով դիմելու համար, իսկ `->` նշանը՝ `struct`֊ի անդամներին ցուցիչով դիմելու համար։ Օրինակ․

````C++
void f(Vector v, Vector& rv, Vector* pv)
{
    int i1 = v.sz;       // դիմում անվան միջոցով
    int i2 = rv.sz;      // դիմում հղման միջոցով
    int i4 = pv->sz;     // դիմում ցուցիչի միջոցով
}
````


## 2.3 Դասեր

A class has a set of members, which can be data, function, or type members.

Տվյալների և դրանց համար սահմանված գործողությունների առանձին սահմանումն ունի իր առավելությունը, ինչպես տվյալների տարբեր եղանակով օգտագործելը։ Սակայն տվյալների ներկայացման և գործողությունների միջև ավելի սերտ կապը օգտագործողի սահմանած տիպին անհրաժեշտ է «իսկական տիպին» յուրահատուկ բոլոր հատկություններն ունենալու համար։ ?? Մասնավորապես, հաճախ ցանկանում ենք տվյալների ներկայացումն անհասանելի պահել օգտագործողներին, դրանով պարզեցնելով օգտագործումը, երաշխավորելով տվյալների անսխալ օգտագործումը, և մեզ հնարավորություն տալով հետագայում բարելավել ներկայացումը։ ?? Դա անելու համար պետք է տարանջատենք տիպի ինտերֆեյսը (որ հասանելի է բոլորին) և նրա իրականացումը (որին մատչելի են այլ եղանակով անհասանելի տվյալները)։ ?? Ասվածն ապահովող լեզվական մեխանիզմը կոչվում է _դաս_ (_class_)։ Դասն ունի անդամներ (members), որոնք կարող են լինել տվյալներ, ֆունկցիաներ կամ տիպեր։ Ինտերֆեյսը որոշվում է դասի `public` անդամներով, իսկ `private` անդամները հասանելի են միայն այդ ինտերֆեյսով։ Օրինակ․

````C++
class Vector {
public:
     Vector (int s) :elem{new double[s]}, sz{s} {}   //կառուցում ենք Vector֊ը
     double& operator[](int i) { return elem[i]; }   // դիմում էլեմենտին՝ ինդեքսավորում
     int size() { return sz; }
private:
     double* elem   // էլեմենտների ցուցիչը
     int sz;        // էլեմենտների քանակը
};
````

Սա ունենալով մենք կարող ենք սահմանել մեր նոր `Vector` տիպի փոփոխական.

```C++
Vector v(6);      // վեկտոր 6 տարրերով
```

`Vector` օբյեկտը գրաֆիկորեն կարող ենք ներկայացնել այսպես․

![](images/image-007.jpeg)

This is the basic technique for handling varying amounts of information in C++: a fixed-size handle referring to a variable amount of data “elsewhere” (e.g., on the free store

Պարզ ասած՝ `Vector` օբյեկտը տարրերի ցուցիչը (`elem`) և տարրերի քանակը (`sz`) պահող մի «handle» ?? է։ Տարրերի քանակը (օրինակի մեջ 6 է) տարբեր `Vector` օբյեկտներում կարող են տարբեր լինել, իսկ նույն `Vector` օբյեկտը ժամանակի տարբեր պահերին կարող է ունենալ տարբեր քանակի տարրեր (§4.2.3)։ Սակայն ինքը `Vector` օբյեկտը միշտ նույն չափն ունի։ Սա է C++֊ում փոփոխական քանակի ինֆորմացիայի հետ աշխատելու հիմնական տեխնիկան. հաստատուն չափի handle, ?? որ հղվում է «մեկ այլ տեղում» գտվող փոփոխական չափի տվյալների (օր., հիշողության դինամիկ տիրույթում՝ ընտրված `new`-ի միջոցով; §4.2.2)։ Չորրորդ գլիխի հիմնական թեման է՝ թե ինչպես նախագծել և օգտագործել այդպիսի օբյեկտները։

Այստեղ `Vector`֊ի ներկայացումը (`elem` և  `sz` անդամները) հասանելի է միայն `public` անդամներով որոշված ինտերֆեյսով․ `Vector()`, `operator[]()` և `size()`։ §2.2֊ի `read_and_sum()` օրինակը պարզեցվել է այսպես․

````C++
double read_and_sum (int s)
{
    Vector v(s);                      // ստեղծվում է s տարրերի վեկտոր
    for (int i=0; i!=v.size(); ++i)
        cin >> v[i];                   // կարդում ենք տարրերը

    double sum = 0;
    for (int i=0; i!=v.size(); ++i)
        sum += v[i];                     // հաշվում ենք տարրերի գումարը
    return sum;
}
````

Նույն իր դասի անունն ունեցող «ֆունկցիան» կոչվում է _կոնստրուկտոր_ (_constructor_), այն է՝ մի ֆունկցիա, որն օգտագործվում է տվյալ դասի օբյեկտները կառուցելու համար։ Այսինքն, կոնստրուկտորը՝ `Vector()`-ը, փոխարինում է  §2.2֊ի `vector_init()`֊ին։ Ի տարբերություն սովորական ֆունկցիայի, կոնստրուկտորը պարտադիր օգտագործվում է իր դասի օբյեկտներ ինիցիալիզացիայի համար։ Հետևաբար,  կոնստրուկտորի սահմամնմամբ բացառվում է դասի ոչ արժեքավորված փոփոխականների խնդիրը։

Vector(int) defines how objects of type Vector are constructed. In particular, it states that it needs an integer to do that. That integer is used as the number of elements. The constructor initializes the Vector members using a member initializer list:

`Vector(int)`֊ը սահմանում է, թե ինչպես են կառուցվում `Vector` տիպի օբյեկտները։ Մասնավորապես, նշվում է, որ դրա համար իրեն անհրաժեշտ է ամբողջ թիվ։ Այդ ամբողջ թիվն օգտագործվում է որպես տարրերի քանակ։ Կոնստրուկտորը `Vector`֊ի անդամներն արժեքավորում է դասի անդամների արժեքավորման ցուցակն օգտագործելով․

```C++
: elem {new double[s]}, sz{s}
```

Այսինքն, նախ՝ `elem`-ն արժեքավորում ենք `s` հատ `double` տիպի տարրերի ցուցիչով՝ ընտրված հիշողության դինամիկ տիրույթից։ Ապա `sz`-ն արժեքավորում ենք `s`-ով։

Տարրերին դիմումն իրականացված է ինդեքսավորման ֆունկցիայով, որի անունն է `operator[]`: Այն հղում է վերադարձնում համապատասխան տարրին (`double&`-ը թույլատրում է ինչպես արժեքի գրելը, այնպես էլ կարդալը)։

`size()` ֆունկցիան նախատեսված է օգտագործողին տարրերի քանակը տալու համար։

Ակնհայտ է, որ սխալների մշակումն ամբողջությամբ բացակայում է, բայց մենք դրան կվերադառնանք §3.5֊ում։ Նմանապես, մենք որևէ մեխանիզմ չենք ապահովում, որը «կվերադարձնի» `new`-ով ձեռք բերված `double`-երի զանգվածը. §4.2.2֊ում ցույց է տրված, թե ինչպես դեստրուկտորն օգտագործել էլեգանտ կերպով դա անելու համար։ ??

`struct`֊ի և `class`֊ի ոչ մի սկզբունքային տարբերություն չկա. `struct`֊ը սովորական `class` է՝ լռությամբ `public` անդամներով։ Օրինակ, դուք կարող եք  սահմանել կոնստրուկտորներ և ուրիշ անդամ֊ֆունկցիաներ `struct`֊ի համար։


## 2.4 Միավորումներ

`union`-ը (_միավորում_) այնպիսի մի `struct` է, որի բոլոր անդամները տեղադրված են հիշողության միևնույն հասցեից, այսինքն՝ `union`-ը զբաղեցնում է միայն իր ամենամեծ անդամի չափով տարածք։ ?? Բնականաբար, `union`-ը միաժամանակ կարող է պահել իր միայն մեկ անդամի արժեքը։ Օրինակ, դիտարկենք սիմվոլների աղյուսակի գրառում, որը պարունակում է անուն և արժեք։ Անունը կարող է լինե կամ `Node*`, կամ էլ `int`․

````C++
enum Type { ptr, num }; // Type-ը կարող է ստանալ ptr և num արժեքները (§2.5)

struct Entry {
    string name;  // string-ը ստանդարտ գրադարանի տիպ է
    Type t;
    Node* p; // երբ t == ptr, օգտագործել p-ն
    int i;   // երբ t == num. օգտագործել i-ն
};

void f(Entry* p)
{
    if (pe−>t == num)
        cout << pe−>i;
    // ...
}
````

 It can be easily recovered by specifying that both should be members of a union, like this:

`p` և `i` անդամները երբեք միաժամանակ չեն օգտագործվում, հետևաբար տարածքի վատնում ունենք։ ?? Այդ վատնումը կարելի է հեշտությամբ վերականգնել՝ `p`-ն և `i`-ն սահմանելով որպես `union`-ի անդամներ։ Այսպես.

````C++
union Value {
    Node* p;
    int i;
};
````

Լեզուն չի հետևում, թե ինչ արժեք է գրառված միավորման մեջ, դա պետք է ծրագրավորողն անի։

```C++
struct Entry {
    string name;
    Type t;
    Value v;  // use v.p if t==ptr; use v.i if t==num
};

void f(Entry* pe)
{
    if (pe−>t == num)
        cout << pe−>v.i;
    // ...
}
```

_Տիպի դաշտի_ (այստեղ՝ `t`) և `union`-ում գրված տիպի համապատասխանության ապահովումը հղի է սխալներով։ ?? Սխալներից խուսփելու համար կարող ենք այդ համապատասխանությունն ապահովել `union`-ը և տիպի դաշտը դասի մեջ ընդգրկելով, և հասանելիություն առաջարկելով միայն `union`-ը ճիշտ օգտագործող անդամ-ֆունկցիաներով։ ?? Կիրառությունների մակարդակում այդպիսի պիտակավորված միավորումների (tagged unions) վրա հիմնված աբստրակցիաները շատ տարածված են ու կիրառելի։ «Մերկ» `union`-երի օգտագործումը ավելի լավ է հասցնել նվազագույնի։ ??

Ստանդարտ գրադարանի `variant` տիպը կարելի է օգտագործել `union`-ների շատ ուղղակի կիրառումներ բացառելու համար։ ?? `variant`-ը պահում է այլընտրանքային տիպերից մեկի արժեքը (§13.5.1)։ Օրինակ, `variant<Node*,int>`-ը կարող է պահել կամ `Node*`, կամ `int`: ??

`variant`-ի օգտագործմամբ `Entry`-ի օրինակը կարող է ունենալ այսպիսի տեսք։

```C++
struct Entry {
    string name;
    variant<Node*,int> v;
};

void f(Entry* pe)
{
    if (holds_alternative<int>(pe−>v))  // *pe-ում int արժե՞ք է (տես §13.5.1) /**/
        cout << get<int>(pe−>v);        // վերցնել int արժեքը
    // ...
}
```

Շատ դեպքերում `variant`-ի օգտագործումն ավելի պարզ ու ապահով է, քան `union`-ը։ ??


## 2.5 Թվարկումներ

Ի լրումն դասերի, C++-ը տրամադրում է օգտագործողի սահմանած մի պարզ տիպ՝ արժեքների թվարկելիության հնարավորությամբ. ??

```C++
enum class Color { red, blue, green };
enum class Traffic_light { green, yellow, red };

Color col = Color::red;
Traffic_light light = Traffic_light::red;
````

Ուշադրություն դարձրեք, որ թվարկելիներն (օր., `red`) իրենց սեփական `enum class`-ի տիրույթում են, այսինքն դրանք կարող են առանց շփոթելու վտանգի կրկնվել տարբեր `enum classe`-երում։ Օրինակ, `Color::red`-ը `Color`-ի `red`-ն է, որը տարբեր է `Traffic_light::red`-ից։

Թվարկումներն օգտագործվում են ամբողջաթիվ արժեքների փոքր խմբեր ներկայացնելու համար։ Դրանք օգտագործվում են ծրագրի տեքստն ավելի ընթեռնելի և սխալների հնարավորությունից ավելի զերծ պահելու համար, քան դա դա կարելի էր անել առանց սիմվոլիկ (և հեշտ հիշվող՝ մնեմոնիկ) թվարկվող անունների օգտագործամբ։ ??

`enum`-ից հետո գրված `class`-ը նշում է, որ թվարկումը խիստ տիպիզացված է և դրա թվարկելիներն իրենց սեփական տիրույթում են։ Լինելով առանձին տիպեր, `enum class`-ներն օգնում են խուսափել հաստատունների պատահական շփոթումից։ ?? Մասնավորապես, մենք չենք կարող շփոթել `Traffic_light` և `Color` արժեքները.

````C++
Color x = red;                  // սխալ. ո՞րh red-ը
Color y = Traffic_light::red;   // սխալ. այս red-ը Color-ց չէ
Color z = Color::red;
````

Նմանապես, չենք կարող `Color`-ի արժեքները և ամբողջ թվերը օգտագործել իրար հետ․

````C++
int i = Color::red;        // սխալ, Color::red-ը int չէ
Color c = 2;               // ինիցիալիզացիայի սխալ, 2-ը Color-ց չէ
````

`enum`-ի Catching attempted conversions to an enum is a good defense against errors, but often we want to initialize an enum with a value from its underlying type (by default, that’s int), so that’s allowed, as is explicit conversion from the underlying type:

```C++
Color x = Color{5};  // OK, but verbose
Color y {6};         // also OK
```

Լռությամբ `enum class`֊ն ունի սահմանված հավասարության, ինիցիալիզացիայի և համեմատության գործողությունները (օր․`==` և `<`; §1.5)։ Սակայն թվարկումն օգտագործողի կողմից սահմանված տիպ է, հետևաբար մենք ինքներս կարող ենք նրա համար սահմանել  օպերատորներ․

````C++
Traffic_light& operator++(Traffic_light& t)
       // նախածանցային ինկրեմենտ՝ ++
{
        switch(t){
        case Traffic_light::green:      return t = Traffic_light::yellow;
        case Traffic_light::yellow;      return t = Traffic_light::red;
        case Traffic_light::red;           return t = Traffic_light::green;
        }
}

Traffic_light next = ++light;
````

Եթե չեք ցանկանում խստորեն նշել թվարկման անունները և ուզում եք, որ արժեքները լինեն `ամբողջ`ներ (առանց բացահայտ ձևափոխման), դուք կարող եք հեռացնել  `class` անունը `enum class`֊ից՝ ստանալու համար «պարզ» `թվարկում` (`enum`): «Պարզ» `թվարկման` թվարկված անունները մուտքագրվում են տեսանելիության միևնույն տիրույթում, որտեղ, որ իրենց  `թվարկման` անունն է և ոչ ակնհայտորեն ձևափոխվում են իրենց ամբողջ արժեքներին։ Օրինակ․

````C++
enum Color {red, green, blue};
int col = green;
````

Այստեղ `col`֊ը ստանում է `1` արժեքը։ Լռությամբ թվարկվող անունների ամբողջ արժեքներն սկսում են `0`֊ից և ավելանում են մեկով յուրաքանչյուր թվարկվող անվան հետ։ «Հասարակ» `թվարկումները` եղել են C++-ում (և C-ում) ամենավաղ օրերից, և թեև նրանց վարքը այնքան էլ լավը չէ, դրանք ընթացիկ կոդերում էլ գործածելի են։


## 2.6 Խորհուրդներ

1. Այս գլխի նյութը մոտավորապես համապատասխանում է [Stroustrup,2013] գրքի, 8֊րդ գլխում շատ ավելի մանրամասն շարադրված նյութին։
2. Իրար հետ կապ ունեցող տվյալները համակարգեք տվյալների կառուցվածքի մեջ (`տվյալների կառուցվածքներ` կամ `դասեր`); §2.2։
3. Represent the distinction between an interface and an implemetation using a class ; §2.3.
4. `Տվյալների կառուցվածքը` նույն `դասն` է լռությամբ `public` անդամներով; §2.3։
5. Սահմանեք կոնստրուկտորներ, որպեսզի պարզեցվի և երաշխավորվի `դասերի` ինիցիալիզացիան։
6. Խուսափե՛ք «միայնակ» `միավորումներից`; շրջափակեք դրանք դասով ?; §2.4:
7. Օգտագործե՛ք թվարկումները անվանված հաստատունների խումբ ներկյացնելու համար; §2.5
8. Նախընտրե՛ք `class enum` թվարկումները «հասարակ» `թվարկումներից`, անսպասելի դեպքերը քչացնելու համար; §2.5:
9. Սահմանեք գործողություններ թվարկուների վրա՝ ապահով և պարզ օգտագործման համար; §2.5:
