# Տողեր և կանոնավոր արտահայտություններ

_Prefer the standard to the offbeat._

_— Strunk & White_

## Ներածություն

Տեքստի հետ աշխատանքը շատ ծրագրերի հիմնական մասն է։ C լեզվի ոճով նիշերի զանգվածների հետ ցուցիչների օգնությամբ աշխատելուց օգտագործողին զերծ պահելու համար C++ լեզվի ստանդարտ գրադարանն առաջարկում է `string` տիպը։ `string_view` տիպը հնարավորություն է տալիս աշխատել նիշերի հաջորդականությունների հետ՝ որտեղ էլ որ նրանք գրառված լինեն (այսինքն՝ `std::string` օբյեկտում կամ `char[]` զանգվածում)։ Ի լրումն, կոնոնավոր արտահայտություններին համապատասխանեցումը առաջարկվում է տեքստում ձևանմուշների (pattern) որոնման համար։ Կանոնավոր արտահայտությունները ներկայացված են այնպես, ինչպես դրանք առկա են շատ ծրագրավորման լեզուներում։ Թե՛ `string`, թե՛ `regex` օբյեկտներում կարող են օգտագործվել տարատեսակ նիշեր (օրինակ, Unicode)։


## Տողեր

Ստանդարտ գրադարանը `string` տիպն առաջարկում է ի լրումն տեքստային լիտերալների (§1.2.1)։ The standard library provides a string type to complement the string literals (§1.2.1)։ Տարներ տիպերի նիշեր պահելու և դրանց հետ աշխատելու համար գրադարանը տրամադրում է `Regular` տիպը (§7.2, §12.7)։ `string` տիպը տրամադրում է զանազան օգտակար տողային գործողություններ, ինչպիսին է միակցումը (concatenation)։ Օրինակ.

```C++
string compose(const string& name, const string& domain)
{
    return name + '@' + domain;
}

auto addr = compose("dmr","bell−labs.com");
```

Այստեղ `addr`-ն արժեքավորվում է նիշերի `dmr@bell−labs.com` հաջորդականությամբ։ Տողերի «գումարումը» հենց միակցումն է։ `string`-ը կարող եք միակցել մի այլ `string`-ի, տողային լիտերալի, C-ոճով տողի կամ նիշի հետ։ Ստանդարտ `string`-ն ունի տողափոխող (move) կոնստրուկտոր, որը հնարավոր է դարձնում ֆունկցիայից նույնիսկ շատ երկար `string`-ների արդյունավետ վերադարձնելը (§5.2.2)։

Շատ կիրառություններում միակցման ամենատարածված տեսակը `string`-ի պոչից ինչ-որ բան ավելացնելն է։ Սա ուղղակիորեն առաջարկվում է `+=` գործողությամբ։ Օրինակ.

```C++
void m2(string& s1, string& s2)
{
    s1 = s1 + '\n';  // կցել նոր տողի նիշը
    s2 += '\n';      // կցել նոր տողի նիշը
}
```

Տողի վերջից կցելու այս երկու եղանակներն էլ ունեն համարժեք իմաստ, բայց ես նախընտրում եմ վերջինը, քանի որ այն ավելի ուղղակիորեն, ավելի հակիրճ և, միգուցե, ավելի արդյունավետ է արտահայտում գործողության իմաստը։

`string`-ը փոփոխելի (mutable) է։ Ի լրումն `=` և `+=` գործողությունների, առաջարկվում են նաև ինդեքսավորման (օգտագործելով `[]` փակագծերը) և ենթատողի առանձնացման գործողությունները։ Օրինակ.

```C++
string name = "Niels Stroustrup";

void m3()
{
    string s = name.substr(6,10);   // s = "Stroustrup"
    name.replace(0,5,"nicholas");   // name-ը դառնում է "nicholas Stroustrup"
    name[0] = toupper(name[0]);     // name-ը դառնում է "Nicholas Stroustrup"
}
```

`substr()` գործողությունը վերադարձնում է `string` օբյեկտ, որը արգումենտներով որոշվող ենթատողի պատճենն է։ Առաջին արգումենտը նպատակային ենթատողի ինդեքսն է (դիրքը) `string`-ում, իսկ երկրորդը՝ երկարությունը։ Քանի որ ինդեքսավորումը `0`-ից է, `s`-ը դառնում է `Stroustrup`։

`replace()` գործողությունը ենթատողը փոխարինում է տրված արժեքով։ Այս դեպքում `0` ինդեքսով սկսվող և `5` երկարությամբ ենթատողը `Niels` է. այն փոխարինվել է `nicholas`-ով։ Վերջապես, ես փոխարինում եմ առաջին տառն իր համարժեք մեծատառով։ Այսպիսով, `name`-ի վերջնական արժեքն է `Nicholas Stroustrup`։ Նշենք՝ ամենևին էլ անհրաժեշտ չէ, որ փոխարինող արժեքը ունենա փոխարինվող ենթատողի նույն երկարությունը։

Ի թիվս այլնի, `string`-ի օգտակար գործողություններից են վերագրումը (արտահայտված `=`-ով), ինդեքսավորումը (արտահայտված `[]`-ով կամ `at()`-ով, ինչպես `vector`-ում, §11.2.2), համեմատումը (արտահայտված `==`-ով և `!=`-ով), բառարանային կարգավորումը (արտահայտված `<`, `<=`, `>` և `>=` գործողություններով), իտերացիան (օգտագործելով իտերատորներն ինչպես `vector`-ում, §12.2), ներմուծումը (§10.3), և հոսքերի հետ աշխատանքը (§10.8)։

Իսկապես, `string`-ները կարող են համեմատվել միմյանց հետ, C-ոճի տողերի հետ և տեքստային լիտերալների հետ։ Օրինակ.

```C++
string incantation;

void respond(const string& answer)
{
    if (answer == incantation) {
        // perform magic
    }
    else if (answer == "yes") {
        // ...
    }
    // ...
}
```

Եթե ձեզ հարկավոր է C-ոճի տող (`char` տիպի նիշերի զրոյով վերջացող զանգված), ապա `string` դասն առաջարկում է իր պարունակած նիշերի միայն կարդալու համար նախատեսված մատչելիություն։ Օրինակ.

```C++
void print(const string& s)
{
    printf("For people who like printf: %s\n", s.c_str());     // s.c_str()-ը վերադարձնում է ցուցիչ s-ի նիշերին
    cout << "For people who like streams: " << s << '\n';
}
```

Ըստ սահմանման տեքստային լիտերալի տիպը `const char*` է։ `std::string` տիպի լիտերալ ստանալու համար օգտագործեք `s` վերջածանցը։ Օրինակ.

```C++
auto s = "Cat"s;   // std::string
auto p = "Dog";    // C-ոճով տող՝ const char*
```

`s` վերջածանցն օգտագործելու համար պետք է օգտվեք `std::literals::string_literals` անունների տիրույթից (§5.4.4)։


### `string`-ի իրականացումը

Տողերի դասն իրականացնելը տարածված ու օգտակար վարժություն է։ Բայց այնուամենայնիվ, ընդհանուր օգտագործման համար մեր խնամքով մշակված առաջին մոտեցումը հազվադեպ է համապատասխանում ստանդարտ `string`-ի հարմարությանն ու արտադրողականությանը։ Այժմ `string`-ը սովորաբար իրականացվում է _կարճ-տողերի օպտիմիզացիայի_ սկզբունքով։ Այսինքն, կարճ տեքստային արժեքները պահվում են `string` օբյեկտում, և միայն երկար տողերն են պահվում հիշողության ազատ տիրույթում։ Դիցուք.

```C++
string s1 {"Annemarie"};               // կարճ տող է
string s2 {"Annemarie Stroustrup"};    // երկար տող է
```

Հիշողության պատկերը կլինի մոտավորապես այսպես.

    nkar 

Երբ `string`-ի արժեքը փոխվում է կարճից երկարի, կամ հակառակը, նրա ներքին ներկայացումը փոխվում է համապատասխան կերպ։ Քանի՞ նիշ կարող է ունենալ «կարճ» տողը։ Դա որոշվում է իրականացմամբ, բայց «մոտ 14 նիշը» վատ մոտարկում չէ։

`string`-ների իրական արտադրողականությունը կարող է էապես կախված լինել կատարման միջավայրից։ Մասնավորապես, բազմահոսք իրականացումներում հիշողության հատկացումը կարող է հարաբերականորեն «թանկ» լինել։ Ինչպես նաև, երբ օգտագործված են տարբեր երկարություններով շատ տողեր, արտադրողականության վրա կարող է ազդել նաև հիշողության կտրտվածությունը (fragmentation)։ Սրանք են այն հիմնական պատճառները, որոնք կարճ-տողերի օպտիմիզացիան դարձրել են ամենուրեք ընդունված։

Նիշերի տարբեր բազմությունների հետ աշխատանքն ապահովելու համար `string`-ն իրականում սահմանված է որպես `basic_string` կաղապարի կոնկրետացում՝ `char` տիպով։

```C++
template<typename Char>
class basic_string {
    // ... string of Char ...
};

using string = basic_string<char>
```

Օգտագործողը կարող է սահմանել կամայական տիպերի տողեր։ Օրինակ, ենթադրենք ունենք ճապոնական նիշերի `Jchar` տիպը, ապա կարող ենք գրել.

```C++
using Jstring = basic_string<Jchar>;
```

Հիմա կարող ենք տեքստային բոլոր գործողություններկ կատարել `Jstring` տիպի՝ ճապոնական նիշերի տողերի հետ։


## String Views


