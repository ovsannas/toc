# Օգտագործողի սահմանած տիպեր


Don't Panic!
-Douglas Adams

* Ներածություն
* Տվյալների կառուցվածքներ
* Դասեր
* Միավորումներ
* Թվարկումներ
* Խորհուրդներ


## 2.1 Ներածություն

Այն տիպերը, որոնք կարող են ստեղծվել ֆունդամենտալ տիպերից (§1.5), `const` մոդիֆիկատորի (§1.7) և հայտարարման օպերատորների (§1.8) միջոցով, կոչվում են _ներդրված տիպեր_։ C++ լեզվի ներդրված տիպերի ու գործողությունների բազմությունը բավականին հարուստ է, բայց ակնհայտորեն դրանք ցածր մակարդակում են։ Դրանք անմիջականորեն և արդյունավետորեն արտացոլում են կոմպյուտերի ապարատային սովորական հնարավորությունները։ Այնուամենայնիվ, դրանք ծրագրավորողին չեն տրամադրում բարդ ծրագրեր գրելու բարձր մակարդակի գործիքներ։ Փոխարենը C++ լեզուն ներդրված տիպերն ու գոծողությունները լրացնում է _աբստրակցիայի մեխանիզմների_ համապատասխան բազմությամբ, որից ծրագրավորողները կարող են ստեղծել անհրաժեշտ բարձր մակարդակի գործիքները։ C++ լեզվում աբստրակցիայի մեխանիզմներն առաջին հերթին մշակվել են, որպեսզի ծրագրավորողներին հնարավորություն տան մշակել և իրականացնել իրենց սեփական տիպերը՝ համապատասխան ներկայացմամբ և գործողություններով, և որպեսզի ծրագրավորողները կարողանան պարզ և գեղեցիկ օգտագործել տվյալ տիպերը։ C++ լեզվում այն տիպերը, որոնք ստեղծվում են ներդված տիպերից դուրս՝ օգտագործելով C++֊ի աբստրակցիայի մեխանիզմները կոչվում են _օգտագործողի սահմանած տիպեր_։ Դրանք ներկայացված են որպես դասեր և թվարկումներ։ Այս գրքի մեծ մասը նվիրված է օգտագործողի կողմից սահմանված տիպերի մշակմանը, իրականացմանը և օգտագործմանը։ Այս գլխի մնացած մասը ներկայացնում է հենց այդ նպատակի համար անհրաժեշտ ամենապարզ և հիմնական գործիքները։ 4-5֊րդ գլուխները աբստրակցիայի մեխանիզմների և նրանց առաջարկած ծրագրավորման ոճի ամբողջական նկարագրւմն է։ 6-13֊րդ գլուխները ներկայացնում են ակնարկ ստանդարտ գրադարանի մասին, և քանի որ ստանդարտ գրադարանը հիմնականում բաղկացած է օգտագործողի սահմանած տիպերից, ներկայացվում են օրինակներ, թե ինչ կարող ենք կառուցել, օգտագործելով 1-5 գլուխներում ներկայացված լեզվի հարմարություններն ու ծրագրավորման տեխնիկան։


## 2.2 Տվյալների կառուցվածքներ

Նոր տիպ կառուցելու առաջին քայլը հաճախ անհրաժեշտ տարրերի համախմբումն է տվյալների կառուցվածքի մեջ՝ `struct`.
````c++
struct Vector {
    int sz;          // տարրերի քանակը
    double* elem;    // ցուցիչ տարրերի վրա
};
````

`Vector`֊ի այս նախնական տարբերակը բաղկացած է `int` տիպի և `double*` տիպի տարրերից։

`Vector` տիպի փոփոխականը կարող է սահմանվել հետևյալ կերպ․
````c++
Vector v;
````
Այնուամենայնիվ, նա ինքն իրենով շատ պետքական չէ, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի վրա ցույց չի տալիս։ Որպեսզի այն օգտակար լինի, մենք պետք է `v`-ին տանք որոշ  տարրեր, որոնց վրա այն ցույց կտա։ Օրինակ, `Vector`֊ը մենք կարող ենք կառուցել հետևյալ ձևով․
````c++
void vector_init(Vector& v, int s)
{
    v.elem = new double[s];   //առանձնացնել s հատ double տիպի թվերի զանգված
    v.sz = s;
}
````
Ահա, `v`֊ի `elem` անդամն ստանում է ցուցիչ՝ ստեղծված `new` օպերատորի կողմից և `v`֊ի `sz` անդամն ստանում է տարրերի քանակը։ `&`(ամպերսանդի) նշանը `Vector&` արգումենտի մեջ ցույց է տալիս, որ `v`֊ն մենք փոխանցում ենք ոչ `const` հղումով (§1.8), այդ ձևով`vector_init()`ֆունկցիան կարող է փոփոխության ենթարկել իրեն փոխանցված վեկտորը։

`new` օպերատորը հիշողություն է առանձնացնում այն տարածքից, որը կոչվում է _ազատ տարածք_ (հայտնի է նաև որպես _դինամիկ հիշողություն_ և _heap_)։ Ազատ տարածքում տեղադրված օբյեկտներն անկախ են այն տեսանելիության տիրույթից, որտեղ ստեղծվել են և «ապրում» են, քանի դեռ չեն հեռացվում՝ օգտագործելով `delete` օպերատորը (§4.2.2)։

`Vector`֊ի պարզ կիրառումն ունի հետևյալ տեսքը․
````c++
double read_and_sum(int s)
         // կարդալ s ամբողջ թվերը cin֊ից և վերադարձնել նրանց գումարը; ենթադրվում է, որ s-ը պետք է լինի դրական թիվ
{
    Vector v;
    vector_init(v,s);           // առանձնացնել s հատ տարր v-ի համար
    for (int i=0; i!=s; ++i)
        cin >> v.elem[i];       // կարդալ տարրերի մեջ

    double sum = 0;
    for (int i=0; i!=s; ++i)
        sum+=v.elem[i];       // ստանալ տարրերի գումարը
    return sum;
}
````

Գեղեցիկ և ճկուն դառնալու համար, ինչպիսին որ ստանդարտ գրադարանի `vector`֊ն է, մեր `Vector`֊ը դեռ երկար ճանապարհ պիտի անցնի։ Մասնավորապես, `Vector`-ի օգտագործողը պետք է իմանա `Vector`֊ի նկարագրության յուրաքանչյուր մասնիկը։ Այս գլխի մնացած մասը և հաջորդ երկու գլուխները աստիճանաբար զարգացնում են `Vector`֊ը, որպես լեզվի հնարավորությունների և տեխնիկական հնարքների օրինակ։ 9-րդ գլուխը ներկայացնում է ստանդարտ գրադարանի `vector`֊ը, որը պարունակում է բազմաթիվ գեղեցիկ գործիքներ։ 

Ես օգտագործում եմ `vector`֊ը և ստանդարտ գրադարանի մյուս բաղկացուցիչները որպես օրինակներ.
* լուսաբանելու համար լեզվի հնարավորություններն ու ձևավորման տեխնիկան, և 
* օգնելու ձեզ սովորելու և օգտագործելու ստանդարտ գրադարանի բաղկացուցիչ մասերը։

Մի՛ վերաիմաստավորեք ստանդարտ գրադարանի կոմպոնենտները, ինչպիսիք են `vector`֊ը և `string`֊ը, օգտագործեք դրանք։

Մենք օգտագործում ենք `.`(կետ)֊ը , որպեսզի `struct`֊ի անդամներին դիմենք անվան միջոցով (և հղման միջոցով), իսկ `->` նշանը՝ որպեսզի կարողանանք `struct`֊ի անդամներին դիմել ցուցիչի միջոցով։ Օրինակ․

````c++
void f(Vector v, Vector& rv, Vector* pv)
{
    int i1 = v.sz;       // դիմում անվան միջոցով
    int i2 = rv.sz;      // դիմում հղման միջոցով
    int i4 = pv->sz;     // դիմում ցուցիչի միջոցով
}
````


## 2.3 Դասեր

Իրենց վրայի գործողություններից առանձին նշված տվյալներ ունենալը ունի այնպիսի առավելություններ, ինչպիսին է տվյալները կամայական ձևերով օգտագործելու կարողությունը։ Սակայն ներկայացման և գործողությունների միջև ամուր կապի համար անհրաժեշտ է օգտագործողի սահմանած տիպ, որպեսզի ունենանք այն բոլոր հատկությունները, որոնք սպասվում են «իսկական տիպին»։ Մասնավոր դեպքերում մենք հաճախ ցանկանում ենք անհասանելի պահել նկարագրությունը օգտագործողներից, այդպիսով հեշտացնել կիրառումը, երաշխավորել տվյալների կայուն օգտագործում և թույլ տալ մեզ հետագայի համար բարելավել ներկայացումը։ Սա անելու համար մենք պետք է տարբերություն դնենք տիպի ինտերֆեյսի (որն օգտագործվում է բոլորի կողմից) և նրա իրականացման (որը, պետք է դիմի ուրիշ անհասանելի տվյալների) միջև։ Այս գործի համար լեզվի մեխանիզմը  կոչվում է *դաս*։ Դասը սահմանված է, որպեսզի ունենա *անդամների* բազմություն, որոնք կարող են լինել տվյալներ, ֆունկցիաներ կամ տիպի անդամներ։ Ինտերֆեյսը սահմանված է դասի `public` անդամներով, և `private` անդամները հասանելի են միայն այդ ինտերֆեյսի միջոցով։ Օրինակ․

````c++
   class Vector {
   public:
         Vector (int s) :elem{new double[s]}, sz{s} {}   //կառուցում ենք Vector֊ը
         double& operator[](int i) {return elem[i];}         // դիմում էլեմենտին՝ subscripting
         int size() {return sz;}
   private:
         double* elem   // ցուցիչ էլեմենտների վրա
         int sz;               // էլեմենտների քանակը
   };
````
Ստանալով սա, մենք կարող ենք սահմանել մեր նոր տիպի՝ `Vector`֊ի փոփոխական։

````c++
   Vector v(6);      // վեկտոր 6 տարրերով
````
Մենք կարող ենք ներկայացնել `Vector` օբյեկտը գրաֆիկորեն․
նկար 2.3

Հիմնականում `Vector`֊ի օբյեկտը "մշակիչ" է, որը պարունակում է ցուցիչ տարրերի վրա(`elem`), գումարած տարրերի քանակը(`sz`)։ Տարրերի քանակը (օրինակի մեջ 6 է) կարող է տատանվել `Vector`֊ի օբյեկտից `Vector`֊ի օբյեկտ և `Vector`֊ի օբյեկտը կարող է ունենալ տարբեր քանակի տարրեր տարբեր ժամանակներում (§4.2.3)։ Այնուամենայնիվ `Vector`֊ի օբյեկտը միշտ նույն չափի է։ Սա է այն հիմնական տեխնիկան C++֊ում տարբեր քանակի ինֆորմացիան  մշակելու համար ։ a fixed-size handle referring to a variable amount of data ‘‘elsewhere’’ (e.g., on the free store allocated by new ; §4.2.2). How to design and use such objects is the main topic of Chapter 4.

Այստեղ `Vector`֊ի ներկայացումը (`elem` և  `sz` անդամները) հասանելի է միայն `public` անդամների կողմից ապահոված ինտերֆեյսի միջոցով․ `Vector()`, `operator[]()` և `size()`։ §2.2֊ից `read_and_sum()` օրինակը պարզեցվում է հետևյալ ձևով․

````c++
   double read_and_sum (int s)
   {
         Vector v(s);                                    // ստեղծվում է s տարրերի վեկտոր
         for (int i=0; i!=v.size(); ++i)
            cin >> v[i];                                 // կարդում ենք տարրերի մեջ

         double sum = 0;
         for (int i=0; i!=v.size(); ++i)
            sum+=v[i];                                 // ստանում ենք տարրերի գումարը
         return sum;
   }
````
Իր դասի անունով «ֆունկցիան», կոչվում է *կոնստրուկտոր*, սա այն ֆունկցիան է, որն օգտագործվում է դասի օբյեկտները կառուցելու համար։ Այսպիսով, `Vector()` կոնստրուկտորը փոխարինում է `vector_init()`֊ին §2.2֊ից։ Ի տարբերություն սովորական ֆունկցիայի, կոնստրուկտորը երաշխավորվում է լինել օգտագործված իր դասի օբյեկտներն արժեքավորելու համար։ Հետևաբար, սահմանելով կոնստրուկտորը, վերանում է դասի համար ոչ արժեքավորված փոփոխականների խնդիրը։ 

`Vector(int)`֊ը սահմանում է, թե ինչպես է կառուցվում `Vector` տիպի օբյեկտը։ Դա անելու համար մասնավորապես այն հաղորդում է, որ իրեն անհրաժեշտ է ամբողջ թիվ։ Ամբողջ թիվն օգտագործվում է որպես տարրերի քանակ։ Կոնստրուկտորն արժեքավորում է `Vector`֊ի անդամները՝ օգտագործելով անդամների արժեքավորման ցուցակը․
````c++
   :elem {new double[s]}, sz{s}
````
Սա նշանակում է, որ սկզբում մենք `elem`֊ին տալիս ենք ցուցիչ `double` տիպի `s` տարրերի վրա, որը ձեռք է բերված ազատ տարածքում։ Հետո արժեքավորում ենք ենք `sz`֊ն `s`֊ով։

Դիմումը տարրերին ապահովվում է ինդեքսավորման ֆունկցիայով, որը կոչվում է `operator[]`: Այն վերադարձնում է համապատասխան տարրի հղումը (`double&`)։ 

`size()` ֆունկցիան տրամադրված է, որպեսզի օգտագործողին տա տարրերի քանակը։

Ակնհայտ է, որ սխալների մշակումը բացակայում է ամբողջությամբ, բայց մենք կվերադառնանք դրան §3.4֊ում։ Նմանապես, մենք չենք ապահովում մեխանիզմ, որը «հետ կստանա» `new`-ով ստացված `double`ների զանգվածը; §4.2.2֊ը ցույց է տալիս, թե ինչպես օգտագործել դեստրուկտորը՝ գեղեցիկ կերպով դա անելու համար։

Չկա ոչ մի ֆունդամենտալ տարբերություն `struct`֊ի և `class`֊ի միջև; `struct`֊ը պարզապես `class`է՝ լռությամբ `public` անդամներով։ Օրինակ, դուք կարող եք  սահմանել կոնստրուկտորներ և ուրիշ անդամ֊ֆունկցիաներ `struct`֊ի համար։


##2.4 Միավորումներ
 
`Միավորումը` (`union`) այն `տվյալների կառուցվածքն է` (`a struct`), որի մեջ բոլոր անդամները տեղավորված են հիշողության մեջ միևնույն հասցեում, այսպիսով `միավորումը` զբաղեցնում է միայն այնքան տարածք, ինչքան որ իր ամենամեծ անդամը։ Բնականաբար `միավորումը` միաժամանակ կարող է պահել միայն մեկ անդամի արժեքը։ Օրինակ, դիտարկենք սիմվոլի մուտքագրման աղյուսակը, որն իր մեջ պահում է անուն և արժեք․

````c++
   enum Type {str, num};

   struct Entry {
           char* name;
           Type t;
           char* s;       // օգտագործել s-ը, եթե t==str
           int i;             // օգտագործել i֊ն, եթե t==num
   };

   void f(Entry* p)
   {
           if (p->t == str)
                   cout << p->s;
            // ...
   }
````

`s` և `i` անդամները երբեք չեն կարող օգտագործվել միևնույն ժամանակ, հետևաբար տարածքն զբաղեցրած է անտեղի։ Սա կարող ենք նորից գրել՝ սահմանելով `s` և `i` փոփոխականները որպես `միավորման` անդամներ հետևյալ կերպ․

````c++
   union Value {
          char* s;
          int i;
   };
````
Լեզուն չի հետևում, թե որ արժեքն է պահվում `միավորման` կողմից, այնպես, որ դա պետք է անի ծրագրավորողը․

````c++
   struct Entry {
           char* name;
           Type t;
           Value v;          // օգտագործել v.s արժեքը, եթե t==str; օգտագործել v.i, եթե t==num
   };

   void f(Entry* p)
   {
           if (p->t == str)
                    cout << p->v.s
           // ...
   }
````

Maintaining the correspondence between a *type field* (here, `t` ) and the type held in a `union` is errorprone. To avoid errors, one can encapsulate a union so that the correspondence between a type field and access to the union members is guaranteed. At the application level, abstractions relying on such tagged unions are common and useful, but use of ‘‘naked’’ union s is best minimized.

## 2.5 Թվարկումներ

Ի լրումն դասերի C++ լեզուն ունի? օգտագործողի սահմանած տիպի պարզ ձև, որի համար մենք կարող ենք թվարկել արժեքները․

````c++
   enum class Color {red, blue, green};
   enum class Traffic_light {green, yellow, red};

   Color col = Color::red;
   Traffic_light light = Traffic_light::red;
```

Ուշադրություն դարձրեք, որ թվարկված արժեքները (օր․ `red`) գտնվում են իրենց `enum class`֊ի տեսանելիության տիրույթում, հետևաբար նրանք կարող են բազմիցս օգտագործվել  տարբեր `enum class`֊ների մեջ՝ առանց շփոթություն առաջացնելու։ Օրինակ `Color::red` արժեքը `Color`֊ի `red` արժեքն է, որը տարբերվում է `Traffic_light::red` արժեքից։

Թվարկումներն օգտագործվում են ամբողջ արժեքների փոքր խմբեր ներկայացնելու համար։ Դրանք օգտագործվում են կոդն ավելի ընթեռնելի դարձնելու համար և ավելի քիչ են ենթակա սխալների, քան դա կլիներ  այն դեպքում, եթե ունենայինք սիմվոլիկ (մնեմոնիկ) թվարկումների անուններ, որոնք չեն օգտագործվել։

`class` արմատական բառը `enum`֊ից հետո ցույց է տալիս, որ թվարկումը խստորեն տիպիզացված է և նրա արժեքները գնտվում են `enum`֊ի տեսանելիության տիրույթում։ Լինելով առանձին տիպեր,`enum class`֊ներն օգնում են կանխել հաստատունների անսպասելի սխալ գործածությունը։ Մասնավորապես նշեմ, որ մենք չենք կարող շփոթել `Traffic_light`֊ի և `Color`֊ի արժեքները․

````c++
   Color x= red;	// սխալ` ո՞ր red֊ը
   Color y = Traffic_light::red;	// սխալ՝ նշված red֊ը Color տիպի չէ
   Color z = Color::red;	// OK
````

Նմանապես, մենք չենք կարող անվերապահորեն խառնել `Color`֊ը և ամբողջ արժեքները՝

````c++
   int i = Color::red;	// սխալ՝ Color::red֊ը int չէ
   Color c = 2;	// սխալ` 2-ը Color չէ
````

Լռությամբ `enum class`֊ն ունի միայն հավասարության, սկզբնարժեքավորման և համեմատության գործողությունները (օր․`==` և `<`; §1.5) սահմանված։ Բայց թվարկումն օգտագործողի սահմանած տիպ է, հետևաբար մենք ինքներս կարող ենք սահմանել  օպերատորներ նրա համար․

````c++
   Traffic_light& operator++(Traffic_light& t)
           // նախածանցային ինկրեմենտ՝ ++
   {
            switch(t){
            case Traffic_light::green:	return t = Traffic_light::yellow;
            case Traffic_light::yellow;	return t = Traffic_light::red;
            case Traffic_light::red;	return t = Traffic_light::green;
            } 
   }

   Traffic_light next = ++light;	// next֊ը դառնում է Traffic_light::green
````

Եթե չեք ցանկանում հստակ նշել թվարկությունների անունները և ուզում եք, որ թվարկությունների արժեքները լինեն `int`եր (առանց բացահայտ ձևափոխման անհրաժեշտության), դուք կարող եք հեռացնել  `class` արմատական բառը `enum class`֊ից, որպեսզի ստանաք «սովորական» `enum`: «Սովորական» `enum`֊ի թվարկությունների արժեքները մուտք են գործում միևնույն տեսանելիության տիրույթ, որտեղ, որ իրենց  `enum`-ի անունն է և ոչ բացահայտ կերպով ձևափոխվում են իրենց ամբողջ արժեքների։ Օրինակ․

````c++
   enum Color {red, green, blue};
   int col = green;
```` 
Այստեղ `col`֊ը ստանում է `1` արժեքը։ Լռությամբ թվարկությունների ամբողջ արժեքներն սկսվում են `0`֊ից և աճում են մեկով յուրաքանչյուր ավելացող թվարկության հետ։ «Սովորական» `enum`-ները C++-ում (և C-ում) գոյություն ունեն ամենավաղ ժամանակներից, և թեև նրանց վարքն ավելի վատ է կազմակերպված, նրանք դեռևս գործածելի են ժամանակակից կոդերում։


## Խորհուրդներ

1. Այս գլխում ներկայացված նյութը մոտավորապես համապատասխանում է նրան, ինչ որ շատ ավելի մանրամասն շարադրված է [Stroustrup,2013]֊ի, 8֊րդ գլխում։
2. Կազմակերպե՛ք իրար հետ ինչ֊որ կապ ունեցող տվյալները տվյալների կառուցվածքների (`struct`ներ կամ `class`ներ) մեջ; §2.2։
3. Ներկայացրե՛ք ինտերֆեյսի և իրականացման միջև տարբերությունը ՝ օգտագործելով `class`; §2.3։
4. `struct`ը նույն `class`ն է՝ լռությամբ `public` անդամներով; §2.3։
5. Սահմանե՛ք կոնստրուկտորներ՝ `class`ների սկզբնարժեքավորումը երաշխավորելու և պարզեցնելու համար;§2.3։
6. Խուսափե՛ք «մերկ» `union`ներից; շրջապատե՛ք դրանք դասով տիպի դաշտի հետ; §2.4:
7. Օգտագործե՛ք թվարկումները անվանված հաստատունների խումբ ներկյացնելու համար; §2.5։
8. Նախընտրե՛ք `class enum`ները «սովորական» `enum`ներից՝ անակնկալները մինիմալի հասցնելու համար; §2.5:
9. Սահմանե՛ք գործողություններ թվարկումների վրա՝ ապահով և պարզ օգտագործման համար; §2.5:















 








   








