# Օգտագործողի սահմանած տիպեր


Don't Panic!
-Douglas Adams

* Ներածություն
* Տվյալների կառուցվածքներ
* Դասեր
* Միավորումներ
* Թվարկումներ
* Խորհուրդներ


## 2.1 Ներածություն

Այն տիպերը, որոնք կարող են ստեղծվել ֆունդամենտալ տիպերից (§1.5), `const` մոդիֆիկատորի (§1.7)  և հայտարարման օպերատորների (§1.8) միջոցով, մենք կոչում ենք *ներդրված տիպեր* ։ C++ լեզուն ունի ներդրված տիպերի և գործողությունների հարուստ բազմություն, բայց հատուկ ցածր մակարդակում։ Նրանք անմիջականորեն և արդյունավետորեն արտացոլում են կոմպյուտերի ապարատային պայմանական հնարավորությունները։ Այնուամենայնիվ, նրանք ծրագրավորողին չեն տրամադրում բարձր մակարդակի գործիքներ հարմար ձևով բարդ ծրագրեր գրելու համար։ Փոխարենը C++ լեզուն հավելում է ներդրված տիպերն ու գոծողությունները *աբստրակցիայի մեխանիզմների* իմաստավորված բազմությունով, որից ծրագրավորողները, կարող են ստեղծել այդպիսի բարձր մակարդակի գործիքներ։ C++ լեզվում աբստրակցիայի մեխանիզմներն առաջին հերթին մշակվել են, որպեսզի թույլ տան ծրագրավորողներին մշակել և իրականացնել իրենց սեփական տիպերը՝ համապատասխան ներկայացմամբ և գործողություններով, և որպեսզի ծրագրավորողները կարողանան պարզ և կոկիկ? օգտագործել տվյալ տիպերը։ C++ լեզվում այն տիպերը, որոնք ստեղծվում են ներդված տիպերից դուրս՝ օգտագործելով C++֊ի աբստրակցիայի մեխանիզմները կոչվում են *օգտագործողի սահմանած տիպեր*։ Դրանք ներկայացված են որպես դասեր և թվարկումներ։ Այս գրքի մեծ մասը նվիրված է օգտագործողի կողմից սահմանված տիպերի մշակմանը, իրականացմանը և օգտագործմանը։ Այս գլխի մնացած մասը ներկայացնում է հենց այդ նպատակի համար անհրաժեշտ ամենապարզ և հիմնական գործիքները։ 4-5֊րդ գլուխները աբստրակցիայի մեխանիզմների և նրանց առաջարկած ծրագրավորման ոճի ամբողջական նկարագրւմն է։ 6-13֊րդ գլուխները ներկայացնում են ակնարկ ստանդարտ գրադարանի մասին, և քանի որ ստանդարտ գրադարանը հիմնականում բաղկացած է օգտագործողի սահմանած տիպերից, ներկայացվում են օրինակներ, թե ինչ կարող ենք կառուցել, օգտագործելով 1-5 գլուխներում ներկայացված լեզվի հարմարություններն ու ծրագրավորման տեխնիկան։

## 2.2 Կառուցվածքներ

Նոր տիպ կառուցելու առաջին քայլը հաճախ անհրաժեշտ տարրերի համախմբումն է տվյալների կառուցվածքի մեջ՝ `struct`.

````c++
   struct Vector {
        int sz;                       // տարրերի քանակը
        double* elem;          // ցուցիչ տարրերի վրա
   };
````

`Vector`֊ի այս նախնական տարբերակը բաղկացած է `int` տիպի և `double*` տիպի տարրերից։

`Vector` տիպի փոփոխականը կարող է սահմանվել հետևյալ կերպ․
````c++
   Vector v;
````
Այնուամենայնիվ, նա ինքն իրենով շատ գործածական չէ, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի վրա ցույց չի տալիս։ Որպեսզի այն օգտակար լինի, մենք պետք է `v`-ին տանք որոշ  տարրեր, որոնց վրա այն ցույց կտա։ Օրինակ, `Vector`֊ը մենք կարող ենք կառուցել հետևյալ ձևով․
````c++
   void vector_init(Vector& v, int s)
   {
         v.elem = new double[s];   //առանձնացնել s հատ double տիպի թվերի զանգված
         v.sz = s;
   }
````
Ահա, `v`֊ի `elem` անդամն ստանում է ցուցիչ՝ ստեղծված `new` օպերատորի կողմից և `v`֊ի `sz` անդամն ստանում է տարրերի քանակը։ `&`(ամպերսանդի) նշանը `Vector&` արգումենտի մեջ ցույց է տալիս, որ `v`֊ն մենք փոխանցում ենք ոչ `const` հղումով (§1.8); այդ ձևով`vector_init()`ֆունկցիան կարող է փոփոխության ենթարկել իրեն փոխանցված վեկտորը։

   `new` օպերատորն առանձնացնում է հիշողություն այն տարածքից, որը կոչվում է *ազատ տարածք* (հայտնի է նաև որպես *դինամիկ հիշողություն* և *heap*)։ Ազատ տարածքում տեղադրված օբյեկտները, անկախ են այն տեսանելիության տիրույթից, որտեղ որ ստեղծվել են և "կան", մինչև որ չեն հեռացվում՝ օգտագործելով `delete` օպերատոր (§4.2.2)։

`Vector`֊ի պարզ կիրառումն ունի հետևյալ տեսքը․
````c++
   double read_and_sum(int s)
         // կարդում է s ամբողջ թվերը cin֊ից և վերադարձնում նրանց գումարը; ենթադրվում է, որ s-ը պետք է լինի դրական
   {
         Vector v;
         vector_init(v,s);               // առանձնացնել s հատ տարր v-ի համար
         for (int i=0; i!=s; ++i)
               cin >> v.elem[i];       // կարդալ տարրերը

         double sum = 0;
         for (int i=0; i!=s; ++i)
               sum+=v.elem[i];       // ստանալ տարրերի գումարը
         return sum;
   }
````

Դեռ երկար ճանապարհ պետք է անցնել, մինչև որ մեր `Vector`֊ը դառնա գեղեցիկ և ճկուն, ինչպիսին որ ստանդարտ գրադարանի `vector`֊ն է։ Մասնավորապես, `Vector`-ի օգտագործողը պետք է իմանա նրա նկարագրության յուրաքանչյուր մասնիկը։ Այս գլխի մնացած մասը և հաջորդ երկու գլուխները աստիճանաբար զարգացնում են `Vector`֊ը, որպես օրինակ լեզվի հնարավորությունների և տեխնիկական հնարքների։ 9-րդ գլուխը ներկայացնում է ստանդարտ գրադարանի `vector`֊ը, որը պարունակում է բազմաթիվ գեղեցիկ գործիքներ։ 

   Ես օգտագործում եմ `vector`֊ը և ստանդարտ գրադարանի մյուս բաղկացուցիչները որպես օրինակներ՝

   * լուսաբանելու համար լեզվի հնարավորություններն ու ձևավորման տեխնիկան, և 
   * ձեզ օգնելու համար սովորելու և օգտագործելու ստանդարտ գրադարանի բաղադրիչ մասերը։

Մի՛ վերաիմաստավորեք ստանդարտ գրադարանի բաղադրիչները, ինչպիսիք են օրինակ, `vector`֊ը կամ `string`֊ը, օգտագործեք դրանք։

   Մենք `.`(կետ)֊ը օգտագործում ենք, որպեսզի կարողանանք դիմել `struct` անդամներին անվան միջոցով (և հղման միջոցով) և `->` նշանը, որպեսզի կարողանանք դիմել `struct` անդամներին ցուցիչի միջոցով։ Օրինակ․

````c++
   void f(Vector v, Vector& rv, Vector* pv)
   {
         int i1 = v.sz;       // դիմում անվան միջոցով
         int i2 = rv.sz;      // դիմում հղման միջոցով
         int i4 = pv->sz;     // դիմում ցուցիչի միջոցով
   }
````

## 2.3 Դասեր

Տվյալներ ունենալը, որոնք նշված են իրենց վրա կատարվող գործողություններից առանձին, ունի առավելություններ, այնպիսին, ինչպիսին է օրինակ կարողությունը օգտագործել տվյալները կամայական սկզբունքով։ Այնուամենայնիվ, ներկայացման և գործողությունների միջև կապի համար անհրաժեշտ է ունենալ օգտագործողի սահմանած տիպ, որպեսզի ունենանք «իրական տիպին» անհրաժեշտ բոլոր հատկությունները։ Մասնավորապես մենք ցանկանում ենք նկարագրությունը անհասանելի պահել օգտագործողներից, այդպիսով թեթևացնելով օգտագործումը (կիրառումը)?, ապահովելով տվյալների երաշխավորված կայուն օգտագործումը և հետագայում մեզ թույլ տալով բարելավել նկարագրությունը (ներկայացումը)։ Այս նպատակին հասնելու համար, մենք պետք է տարբերակում դնենք տիպի (որն օգտագործվում է բոլորի կողմից) և նրա իրականացման (որը, կարող է դիմել այլ անհասանելի տվյալների) ինտերֆեյսների միջև։ Այս նպատակն իրագործող լեզվի մեխանիզմը կոչվում է *դաս*։ Դասի սահմանումից հետևում է, որ այն պետք է ունենա *անդամների* խումբ, որոնք կարող են լինել տվյալներ, ֆունկցիաներ կամ տիպ անդամներ։ Ինտերֆեյսը սահմանված է դասի `public` անդամներով և `private` անդամներով, որոնք հասանելի են միայն այդ ինտերֆեյսի միջոցով։ Օրինակ․

````c++
   class Vector {
   public:
         Vector (int s) :elem{new double[s]}, sz{s} {}   //կառուցում ենք Vector֊ը
         double& operator[](int i) {return elem[i];}         // դիմում էլեմենտին՝ subscripting
         int size() {return sz;}
   private:
         double* elem   // ցուցիչ էլեմենտների վրա
         int sz;               // էլեմենտների քանակը
   };
````

Վերևում նշվածն ունենալով, մենք կարող ենք սահմանել մեր նոր `Vector` տիպի փոփոխական։

````c++
   Vector v(6);      // 6 էլեմենտներով վեկտոր
````

Այստեղ կարող ենք `Vector` օբյեկտը ներկայացնել նաև գրաֆիկորեն․
նկար 2.3

Ըստ էության `Vector` օբյեկտը "handle" է, որը պարունակում է ցուցիչ `elem` տարրերի վրա, գումարած `sz` տարրերի քանակը։ Տարրերի քանակը (օրինակի մեջ քանակը 6 է) կարող է տատանվել մի `Vector` օբյեկտից մյուս `Vector` օբյեկտ և `Vector` օբյեկտը կարող է ունենալ տարբեր քանակի տարրեր տարբեր ժամանակներում (§4.2.3)։ Ինչևէ, `Vector` օբյեկտը միշտ ունի նույն չափը։ Վերջինս This is the basic technique for
handling varying amounts of information in C++: a fixed-size handle referring to a variable amount
of data ‘‘elsewhere’’ (e.g., on the free store allocated by new ; §4.2.2). How to design and use such
objects is the main topic of Chapter 4.

Այստեղ `Vector`֊ի ներկայացումը (`elem` և  `sz` անդամները) հասանելի է միայն `public` անդամների ապահոված ինտերֆեյսի միջոցով․ `Vector()`, `operator[]()` և `size()`։ §2.2֊ից `read_and_sum()` պարզեցված օրինակը հետևյալն է․

````c++
   double read_and_sum (int s)
   {
         Vector v(s);                                    // ստեղծվում է s տարրերի վեկտոր
         for (int i=0; i!=v.size(); ++i)
            cin >> v[i];                                 // կարդում ենք տարրերի մեջ

         double sum = 0;
         for (int i=0; i!=v.size(); ++i)
            sum+=v[i];                                 // ստանում ենք տարրերի գումարը
         return sum;
   }
````

Այն «ֆունկցիան», որն ունի միևնույն անունը, ինչ որ իր դասը, կոչվում է *կոնստրուկտոր*, դա այն ֆունկցիան է, որն օգտագործվում է դասի օբյեկտները կառուցելու համար։ Այսպիսով, `Vector()` կոնստրուկտորը փոխարինում է `vector_init()`֊ին §2.2֊ից։ Ի տարբերություն սովորական ֆունկցիայի, կոնստրուկտորը օգտագործվում է իր դասի օբյեկտները ինիցիալիզացնելու (սկզբնական արժեքներ տալու) համար։ Այսպիսով, սահմանելով կոնստրուկտորը մենք վերացնում ենք դասի ոչ ինիցիալիզացված փոփոխականներ ունենալու խնդիրը։ 

`Vector(int)`֊ը սահմանում է, թե ինչպես է կառուցվում `Vector` տիպի օբյեկտը։ Մասնավորապես նշվում է, որ նրան անհրաժեշտ է ամբողջ թիվ օբյեկտի կառուցման համար։ Այդ ամբողջ թիվն օգտագործվում է որպես տարրերի քանակ։ Կոնստրուկտորը ինիցիալիզացնում է `Vector`֊ի անդամները՝ օգտագործելով անդամների սկզբնական արժեքների ցանկը (ինիցիալիզացիոն լիստ)․

````c++
   :elem {new double[s]}, sz{}
````

Այստեղից հետևում է, որ սկզբում մենք ինիցիալիզացնում ենք `elem`֊ը ցուցիչով, որը ցույց է տալիս `double` տիպի `s` տարրերի վրա, որոնք ձեռք են բերվում ազատ տարածքում։ Հետո ինիցիալիզացնում ենք `sz`֊ն `s`֊ով։

Տարրերին դիմումը ապահովվում է ինդեքսավորման (subscript) ֆունկցիայի միջոցով, որը կոչվում է `operator[]`: Այն վերադարձնում է հղում համապատասխան տարրին (`double&`)։ 

`size()` ֆունկցիան տալիս է օգտագործողին տարրերի քանակը։

Obviously, error handling is completely missing, but we’ll return to that in §3.4. Similarly, we
did not provide a mechanism to ‘‘give back’’ the array of double s acquired by new ; §4.2.2 shows
how to use a destructor to elegantly do that.

Ստրուկտուրայի և դասի միջև չկա ոչ մի հիմնական տարբերություն․ ստրուկտուրան պարզապես դաս է՝ լռությամբ public անդամներով։ Օրինակ,  ստրուկտուրայի համար դուք կարող եք  սահմանել կոնստրուկտորներ և այլ ֆունկցիա֊անդմաներ։


##2.4 Միավորումներ
 
`Միավորումը` (`union`) այն տվյալների կառուցվածքն է (`a struct`), որի մեջ բոլոր անդամները տեղավորված են հիշողության մեջ միևնույն հասցեում, այնպես որ `միավորումը` զբաղեցնում է իր ամենամեծ անդամի հիշողության տարածքը։ Ինքնին `միավորումը` միաժամանակ կարող է պահել միայն իր մեկ անդամի արժեքը։ Օրինակ, դիտարկենք սիմվոլի մուտքագրման աղյուսակը, որն իր մեջ պահում է անուն և արժեք․

````c++
   enum Type {str, num};

   struct Entry {
           char* name;
           Type t;
           char* s;       // օգտագործել s-ը, եթե t==str
           int i;             // օգտագործել i֊ը, եթե t==num
   };

   void f(Entry* p)
   {
           if (p->t == str)
                   cout << p->s;
            // ...
   }
````

Այստեղ `s` և `i` անդամները երբեք չեն կարող օգտագործվել միևնույն ժամանակ, հետևաբար հիշողության տարածքն զբաղեցրած է անտեղի։ Սա կարող ենք նորից գրել՝ սահմանելով `s` և `i` փոփոխականները որպես `միավորման` անդամներ հետևյալ կերպ․

````c++
   union Value {
          char* s;
          int i;
   };
````

The language doesn’t keep track of which kind of value is held by a union , so the programmer must do that:

````c++
   struct Entry {
           char* name;
           Type t;
           Value v;          // օգտագործել v.s արժեքը, եթե t==str; օգտագործել v.i, եթե t==num
   };

   void f(Entry* p)
   {
           if (p->t == str)
                    cout << p->v.s
           // ...
   }
````

Maintaining the correspondence between a type field (here, t ) and the type held in a union is errorprone. To avoid errors, one can encapsulate a union so that the correspondence between a type field and access to the union members is guaranteed. At the application level, abstractions relying on such tagged unions are common and useful, but use of ‘‘naked’’ union s is best minimized.

## 2.5 Թվարկումներ

C++ լեզուն դասերին ավելացնում է  օգտագործողի սահմանած տիպի մեկ պարզ ձև, որի համար մենք կարող ենք թվարկել արժեքներ․

````c++
   enum class Color {red, blue, green};
   enum class Traffic_light {green, yellow, red};

   Color col = Color::red;
   Traffic_light light = Traffic_light::red;
```

Նշենք, որ թվարկված արժեքները (օր․ `red`) գտնվում են իրենց `enum class`֊ի տեսանելիության տիրույթում, հետևաբար նրանք կարող են բազմիցս օգտագործվել  տարբեր `enum class`֊երի մեջ՝ առանց շփոթություն առաջացնելու։ Օրինակ `Color::red` արժեքը `Color`֊ի `red` արժեքն է, որը տարբերվում է `Traffic_light::red` արժեքից։

Թվարկումներն օգտագործվում են ամբողջ թվերի փոքր խմբեր ներկայացնելու համար։ Դրանք օգտագործվում են կոդն ավելի ընթեռնելի դարձնելու համար և ավելի քիչ են ենթարկվում սխալների than it would have been had the symbolic (and mnemonic) enumerator names not been used.

`class` անունը `enum`֊ից հետո ցույց է տալիս, որ թվարկման տիպը խստորեն որոշված է և նրա թվարկված արժեքներն ունեն իրենց տեսանելիության տիրույթը։ Լինելով առանձնացված տիպեր `enum class`֊երն օգնում են կանխել հաստատունների պատահական սխալ գործածությունը։ Մասնավորապես մենք չենք կարող շփոթել `Traffic_light`֊ի և `Color`֊ի արժեքները․

````c++
   Color x= red;                              // սխալ է․ պետք է նշել, թե որ red արժեքն է
   Color y = Traffic_light::red;         // սխալ է․ սա Color֊ի red արժեքը չէ
   Color z = Color::red;                   // ճիշտ է
````

Նմանապես, չենք կարող խառնել `Color` թվարկման արժեքները և ամբողջ թվերը․

````c++
   int i = Color::red;                         // սխալ է․ Color::red֊ը ամբողջ թիվ չէ
   Color c = 2;                                 // սխալ է․ 2-ը Color չէ
````

Լռությամբ `enum class`֊ն ունի սահմանված հավասարության, ինիցիալիզացիայի և համեմատության գործողությունները (օր․`==` և `<`; §1.5)։ Սակայն թվարկումն օգտագործողի կողմից սահմանված տիպ է, հետևաբար մենք ինքներս կարող ենք նրա համար սահմանել  օպերատորներ․

````c++
   Traffic_light& operator++(Traffic_light& t)
           // նախածանցային ինկրեմենտ՝ ++
   {
            switch(t){
            case Traffic_light::green:      return t = Traffic_light::yellow;
            case Traffic_light::yellow;      return t = Traffic_light::red;
            case Traffic_light::red;           return t = Traffic_light::green;
            } 
   }

   Traffic_light next = ++light;
````

Եթե չեք ցանկանում խստորեն նշել թվարկման անունները և ուզում եք, որ արժեքները լինեն `ամբողջ`ներ (առանց բացահայտ ձևափոխման), դուք կարող եք հեռացնել  `class` անունը `enum class`֊ից՝ ստանալու համար «պարզ» `թվարկում` (`enum`): «Պարզ» `թվարկման` թվարկված անունները մուտքագրվում են տեսանելիության միևնույն տիրույթում, որտեղ, որ իրենց  `թվարկման` անունն է և ոչ ակնհայտորեն ձևափոխվում են իրենց ամբողջ արժեքներին։ Օրինակ․

````c++
   enum Color {red, green, blue};
   int col = green;
```` 
Այստեղ `col`֊ը ստանում է `1` արժեքը։ Լռությամբ թվարկվող անունների ամբողջ արժեքներն սկսում են `0`֊ից և ավելանում են մեկով յուրաքանչյուր թվարկվող անվան հետ։ «Հասարակ» `թվարկումները` եղել են C++-ում (և C-ում) ամենավաղ օրերից, և թեև նրանց վարքը այնքան էլ լավը չէ, դրանք ընթացիկ կոդերում էլ գործածելի են։


## Խորհուրդներ

1. Այս գլխի նյութը մոտավորապես համապատասխանում է [Stroustrup,2013] գրքի, 8֊րդ գլխում շատ ավելի մանրամասն շարադրված նյութին։
2. Իրար հետ կապ ունեցող տվյալները համակարգեք տվյալների կառուցվածքի մեջ (`տվյալների կառուցվածքներ` կամ `դասեր`); §2.2։
3. Represent the distinction between an interface and an implemetation using a class ; §2.3.
4. `Տվյալների կառուցվածքը` նույն `դասն` է լռությամբ `public` անդամներով; §2.3։
5. Սահմանեք կոնստրուկտորներ, որպեսզի պարզեցվի և երաշխավորվի `դասերի` ինիցիալիզացիան։
6. Խուսափե՛ք «միայնակ» `միավորումներից`; շրջափակեք դրանք դասով ?; §2.4:
7. Օգտագործե՛ք թվարկումները անվանված հաստատունների խումբ ներկյացնելու համար; §2.5
8. Նախընտրե՛ք `class enum` թվարկումները «հասարակ» `թվարկումներից`, անսպասելի դեպքերը քչացնելու համար; §2.5:
9. Սահմանեք գործողություններ թվարկուների վրա՝ ապահով և պարզ օգտագործման համար; §2.5:















 








   








