# Օգտագործողի սահմանած տիպերը

* Ներածություն
* Ստրուկտուրաներ
* Դասեր
* Միավորումներ
* Թվարկումներ
* Խորհուրդներ


## 2.1 Ներածություն

Այն տիպերը, որոնք ստեղծվում են հիմնական տիպերի (§1.5), `const` մոդիֆիկատորի (§1.7)  և հայտարարման օպերատորների (§1.8) միջոցով, կոչվում են *ներդրված տիպեր* ։ C++ լեզուն ունի ներդրված տիպերի և գործողությունների հարուստ բազմություն, բայց հատուկ ցածր մակարդակում։ Նրանք անմիջականորեն և արդյունավետորեն արտացոլում են կոմպյուտերի ապարատային պայմանական հնարավորությունները։ Այնուամենայնիվ, նրանք ծրագրավորողին չեն տրամադրում բարձր մակարդակի գործիքներ հարմար ձևով բարդ ծրագրեր գրելու համար։ Փոխարենը C++ լեզուն հավելում է ներդրված տիպերն ու գոծողությունները *աբստրակցիայի մեխանիզմների* իմաստավորված բազմությունով, որից ծրագրավորողները, կարող են ստեղծել այդպիսի բարձր մակարդակի գործիքներ։ C++ լեզվում աբստրակցիայի մեխանիզմներն առաջին հերթին մշակվել են, որպեսզի թույլ տան ծրագրավորողներին մշակել և իրականացնել իրենց սեփական տիպերը՝ համապատասխան ներկայացմամբ և գործողություններով, և որպեսզի ծրագրավորողները կարողանան պարզ և կոկիկ? օգտագործել տվյալ տիպերը։ C++ լեզվում այն տիպերը, որոնք ստեղծվում են ներդված տիպերից դուրս՝ օգտագործելով C++֊ի աբստրակցիայի մեխանիզմները կոչվում են *օգտագործողի սահմանած տիպեր*։ Դրանք ներկայացված են որպես դասեր և թվարկումներ։ Այս գրքի մեծ մասը նվիրված է օգտագործողի կողմից սահմանված տիպերի մշակմանը, իրականացմանը և օգտագործմանը։ Այս գլխի մնացած մասը ներկայացնում է հենց այդ նպատակի համար անհրաժեշտ ամենապարզ և հիմնական գործիքները։ 4-5֊րդ գլուխները աբստրակցիայի մեխանիզմների և նրանց առաջարկած ծրագրավորման ոճի ամբողջական նկարագրւմն է։ 6-13֊րդ գլուխները ներկայացնում են ակնարկ ստանդարտ գրադարանի մասին, և քանի որ ստանդարտ գրադարանը հիմնականում բաղկացած է օգտագործողի սահմանած տիպերից, ներկայացվում են օրինակներ, թե ինչ կարող ենք կառուցել, օգտագործելով 1-5 գլուխներում ներկայացված լեզվի հարմարություններն ու ծրագրավորման տեխնիկան։

## 2.2 Ստրուկտուրաtighterներ

Նոր տիպ կառուցելու առաջին քայլը հաճախ տարրերի կազմակերպումն է? , որի համար անհրաժեշտ է տվյալների ստրուկտուրա՝ `struct`:

````c++
   struct Vector {
      int sz;                // տարրերի քանակը
      double* elem;   // ցուցիչ տարրերի վրա
   }
````

`Vector`֊ի առաջին տարբերակը բաղկացած է `int` և `double*` տարրերից։

   `Vector` տիպի փոփոխականը սահմանվում է հետևյալ կերպ․

   ````c++
   Vector v;
   ````
Ինքնին, այն շատ չի օգտագործվում, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի վրա ցույց չի տալիս։ Որպեսզի `v`֊ն օգտագործելի լինի, մենք պետք է  նրան տանք տարրեր՝ ցույց տալու համար։ Օրինակ, մենք կարող ենք կազմել `Vector`֊ը հետևյալ կերպ․

````c++
   void vector_init(Vector& v, int s)
   {
         v.elem = new double[s];   //
         v.sz = s;
   }
````

Այսպիսով, `v`֊ի `elem` անդամը ստանում է `new` օպերատորի միջոցով ստեղծված ցուցիչ և `v`֊ի `sz` անդամը ստանում է էլեմենտների քանակը։ `&` նշանը `Vector&`֊ի մեջ ցույց է տալիս, որ մենք `v`֊ն փոխանցում ենք ոչ հաստատուն հղումով (§1.8); այսպիսով, `vector_init()`ֆունկցիան կարող է փոփոխել իրեն փոխանցված վեկտորը։

   `New` օպերատորը հիշողության տարածք է առանձնացնում այն տարածքից, որը կոչվում է *ազատ տարածք* (որը հայտնի է նաև *դինամիկ հիշողություն* և *heap*)։ Այն օբյեկտները, որոնք առանձնացված են ազատ տարածքում, անկախ են իրենց տեսանելիության տիրույթից, որտեղ որ ստեղծվել են և "գոյություն ունեն", մինչև որ չեն ջնջվում `delete` օպերատորի կողմից (§4.2.2)։

`Vector`֊ի պարզ օգտագործումն ունի հետևյալ տեսքը․

````c++
   double read_and_sum(int s)
         // կարդում է s ամբողջ թվերը cin֊ից և վերադարձնում նրանց գումարը; ենթադրվում է, որ s-ը պետք է լինի դրական
   {
         Vector v;
         vector_init(v,s);               // v-ի համար առանձնացնում է s տարրերը
         for (int i=0; i!=s; ++i)
               sum+=v.elem[i];       // կարդում ենք տարրերի մեջ

         double sum = 0;
         for (int i=0; i!=s; ++i)
               sum+=v.elem[i];      // ստանում ենք տարրերի գումարը
         return sum;
   }
````

Դեռ երկար ճանապարհ պետք է անցնել, մինչև որ մեր `Vector`֊ը դառնա գեղեցիկ և ճկուն, ինչպիսին որ ստանդարտ գրադարանի `vector`֊ն է։ Մասնավորապես, `Vector`-ի օգտագործողը պետք է իմանա նրա նկարագրության յուրաքանչյուր մասնիկը։ Այս գլխի մնացած մասը և հաջորդ երկու գլուխները աստիճանաբար զարգացնում են `Vector`֊ը, որպես օրինակ լեզվի հնարավորությունների և տեխնիկական հնարքների։ 9-րդ գլուխը ներկայացնում է ստանդարտ գրադարանի `vector`֊ը, որը պարունակում է բազմաթիվ գեղեցիկ գործիքներ։ 

   Ես օգտագործում եմ `vector`֊ը և ստանդարտ գրադարանի մյուս բաղկացուցիչները որպես օրինակներ՝

   * լուսաբանելու համար լեզվի հնարավորություններն ու ձևավորման տեխնիկան, և 
   * ձեզ օգնելու համար սովորելու և օգտագործելու ստանդարտ գրադարանի բաղադրիչ մասերը։

Մի՛ վերաիմաստավորեք ստանդարտ գրադարանի բաղադրիչները, ինչպիսիք են օրինակ, `vector`֊ը կամ `string`֊ը, օգտագործեք դրանք։

   Մենք `.`(կետ)֊ը օգտագործում ենք, որպեսզի կարողանանք դիմել `struct` անդամներին անվան միջոցով (և հղման միջոցով) և `->` նշանը, որպեսզի կարողանանք դիմել `struct` անդամներին ցուցիչի միջոցով։ Օրինակ․

````c++
   void f(Vector v, Vector& rv, Vector* pv)
   {
         int i1 = v.sz;       // դիմում անվան միջոցով
         int i2 = rv.sz;      // դիմում հղման միջոցով
         int i4 = pv->sz;   // դիմում ցուցիչի միջոցով
   }
````

## 2.3 Դասեր

Տվյալներ ունենալը, որոնք նշված են իրենց վրա կատարվող գործողություններից առանձին, ունի առավելություններ, այնպիսին, ինչպիսին է օրինակ կարողությունը օգտագործել տվյալները կամայական սկզբունքով։ Այնուամենայնիվ, ներկայացման և գործողությունների միջև կապի համար անհրաժեշտ է ունենալ օգտագործողի սահմանած տիպ, որպեսզի ունենանք «իրական տիպին» անհրաժեշտ բոլոր հատկությունները։ Մասնավորապես մենք ցանկանում ենք նկարագրությունը անհասանելի պահել օգտագործողներից, այդպիսով թեթևացնելով օգտագործումը (կիրառումը)?, ապահովելով տվյալների երաշխավորված կայուն օգտագործումը և հետագայում մեզ թույլ տալով բարելավել նկարագրությունը (ներկայացումը)։ Այս նպատակին հասնելու համար, մենք պետք է տարբերակում դնենք տիպի (որն օգտագործվում է բոլորի կողմից) և նրա իրականացման (որը, կարող է դիմել այլ անհասանելի տվյալների) ինտերֆեյսների միջև։ Այս նպատակն իրագործող լեզվի մեխանիզմը կոչվում է *դաս*։ Դասի սահմանումից հետևում է, որ այն պետք է ունենա *անդամների* խումբ, որոնք կարող են լինել տվյալներ, ֆունկցիաներ կամ տիպ անդամներ։ Ինտերֆեյսը սահմանված է դասի `public` անդամներով և `private` անդամներով, որոնք հասանելի են միայն այդ ինտերֆեյսի միջոցով։ Օրինակ․

````c++
   class Vector {
   public:
         Vector (int s) :elem{new double[s]}, sz{s} {}   //կառուցում ենք Vector֊ը
         double& operator[](int i) {return elem[i];}         // դիմում էլեմենտին՝ subscripting
         int size() {return sz;}
   private:
         double* elem   // ցուցիչ էլեմենտների վրա
         int sz;               // էլեմենտների քանակը
   };
````

Վերևում նշվածն ունենալով, մենք կարող ենք սահմանել մեր նոր `Vector` տիպի փոփոխական։

````c++
   Vector v(6);      // 6 էլեմենտներով վեկտոր
````

Այստեղ կարող ենք `Vector` օբյեկտը ներկայացնել նաև գրաֆիկորեն․
նկար 2.3










 








   





## 2.2 Ստրուկտուրաներ

Նոր տիպի կառուցման մեջ հաճախ տարրերի կազմակերպման համար անհրաժեշտ է տվյալների ստրուկտուրա՝ `struct`:

````c++
   struct Vector {
      int sz;      //տարրերի քանակը
      double* elem;   //ցուցիչ տարրերի վրա
   };
````

`Vector`֊ի առաջին տարբերակը բաղկացած է `int`֊ից և `double*`֊ից։

`Vector` տիպի փոփոխականը կարող է սահմանվել հետևյալ կերպ․

````c++
   Vector v;
````

Ինչևէ, ինքնըստինքյան սա չունի մեծ գործածություն, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի վրա ցույց չի տալիս։ Օրինակի համար մենք կարող ենք կազմել `Vector`֊ը հետևյալ կերպ․

````c++
   void vector_init(Vector& v, int s)
   {
      v.elem = new double[s];   //սահմանում է զանգված s հատ double֊ների համար
      v.sz = s;

   }
````

Այստեղ `v`֊ի `elem` անդամը ստանում է ցուցիչ, որն ստեղծվում է `new` օպերատորի միջոցով և `v`֊ի `sz` անդամը ստանում է տարրերի քանակը։ `&` նշանը `Vector&`֊ի մեջ ցույց է տալիս, որ մենք `v`֊ն փոխանցում ենք ոչ կոնստանտ հղումով (§1.8); այդպիսով `vector_init()`֊ը կարող է փոփոխել իրեն փոխանցված վեկտորը։

`new` օպերատորը հատկացնում է հիշողություն այնպիսի տարածքից, որը կոչվում է *ազատ store* (որն այլ կերպ կոչվում է *դինամիկ հիշողություն* և *heap*)։ Ազատ store֊ում ստեղծված օբյեկտները անկախ են այն տիրույթից, որտեղ նրանք ստեղծվել են և «գոյություն ունեն» մինչև չեն ջնջվում `delete` օպերատորի միջոցով (§4.2.2):

`Vector`֊ի պարզ օգտագործման ձևը հետևյալն է՝

````c++
   double read_and_sum(int s)
      //կարդում է s ամբողջ թվերը cin-ի միջոցով և վերադարձնում է նրանց գումարը; ենթադրվում է, որ s֊ը, պետք է լինի դրական
   {
      Vector v;
      vector_init(v,s);
      for(int i = 0; i != s; ++i)
         cin >> v.elem[i];

      double sum = 0;
      for(int i = 0; i != s; ++i)
         sum += v.elem[i];

      return sum;
   }
````








