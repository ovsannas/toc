# Օգտագործողի սահմանած տիպերը

* Ներածություն
* Ստրուկտուրաներ
* Դասեր
* Միավորումներ
* Թվարկումներ
* Խորհուրդներ


## 2.1 Ներածություն

Այն տիպերը, որոնք ստեղծվում են հիմնական տիպերի (§1.5), `const` մոդիֆիկատորի (§1.7)  և հայտարարման օպերատորների (§1.8) միջոցով, կոչվում են *ներդրված տիպեր* ։ C++ լեզուն ունի ներդրված տիպերի և գործողությունների հարուստ բազմություն, բայց հատուկ ցածր մակարդակում։ Նրանք անմիջականորեն և արդյունավետորեն արտացոլում են կոմպյուտերի ապարատային պայմանական հնարավորությունները։ Այնուամենայնիվ, նրանք ծրագրավորողին չեն տրամադրում բարձր մակարդակի գործիքներ հարմար ձևով բարդ ծրագրեր գրելու համար։ Փոխարենը C++ լեզուն հավելում է ներդրված տիպերն ու գոծողությունները *աբստրակցիայի մեխանիզմների* իմաստավորված բազմությունով, որից ծրագրավորողները, կարող են ստեղծել այդպիսի բարձր մակարդակի գործիքներ։ C++ լեզվում աբստրակցիայի մեխանիզմներն առաջին հերթին մշակվել են, որպեսզի թույլ տան ծրագրավորողներին մշակել և իրականացնել իրենց սեփական տիպերը՝ համապատասխան ներկայացմամբ և գործողություններով, և որպեսզի ծրագրավորողները կարողանան պարզ և կոկիկ? օգտագործել տվյալ տիպերը։ C++ լեզվում այն տիպերը, որոնք ստեղծվում են ներդված տիպերից դուրս՝ օգտագործելով C++֊ի աբստրակցիայի մեխանիզմները կոչվում են *օգտագործողի սահմանած տիպեր*։ Դրանք ներկայացված են որպես դասեր և թվարկումներ։ Այս գրքի մեծ մասը նվիրված է օգտագործողի կողմից սահմանված տիպերի մշակմանը, իրականացմանը և օգտագործմանը։ Այս գլխի մնացած մասը ներկայացնում է հենց այդ նպատակի համար անհրաժեշտ ամենապարզ և հիմնական գործիքները։ 4-5֊րդ գլուխները աբստրակցիայի մեխանիզմների և նրանց առաջարկած ծրագրավորման ոճի ամբողջական նկարագրւմն է։ 6-13֊րդ գլուխները ներկայացնում են ակնարկ ստանդարտ գրադարանի մասին, և քանի որ ստանդարտ գրադարանը հիմնականում բաղկացած է օգտագործողի սահմանած տիպերից, ներկայացվում են օրինակներ, թե ինչ կարող ենք կառուցել, օգտագործելով 1-5 գլուխներում ներկայացված լեզվի հարմարություններն ու ծրագրավորման տեխնիկան։


## 2.2 Ստրուկտուրաներ

Նոր տիպի կառուցման մեջ հաճախ տարրերի կազմակերպման համար անհրաժեշտ է տվյալների ստրուկտուրա՝ `struct`:

````c++
   struct Vector {
      int sz;      //տարրերի քանակը
      double* elem;   //ցուցիչ տարրերի վրա
   };
````

`Vector`֊ի առաջին տարբերակը բաղկացած է `int`֊ից և `double*`֊ից։

`Vector` տիպի փոփոխականը կարող է սահմանվել հետևյալ կերպ․

````c++
   Vector v;
````

Ինչևէ, ինքնըստինքյան սա չունի մեծ գործածություն, քանի որ `v`֊ի `elem` ցուցիչը ոչ մի բանի վրա ցույց չի տալիս։ Օրինակի համար մենք կարող ենք կազմել `Vector`֊ը հետևյալ կերպ․

````c++
   void vector_init(Vector& v, int s)
   {
      v.elem = new double[s];   //սահմանում է զանգված s հատ double֊ների համար
      v.sz = s;

   }
````

Այստեղ `v`֊ի `elem` անդամը ստանում է ցուցիչ, որն ստեղծվում է `new` օպերատորի միջոցով և `v`֊ի `sz` անդամը ստանում է տարրերի քանակը։ `&` նշանը `Vector&`֊ի մեջ ցույց է տալիս, որ մենք `v`֊ն փոխանցում ենք ոչ կոնստանտ հղումով (§1.8); այդպիսով `vector_init()`֊ը կարող է փոփոխել իրեն փոխանցված վեկտորը։

`new` օպերատորը հատկացնում է հիշողություն այնպիսի տարածքից, որը կոչվում է *ազատ store* (որն այլ կերպ կոչվում է *դինամիկ հիշողություն* և *heap*)։ Ազատ store֊ում ստեղծված օբյեկտները անկախ են այն տիրույթից, որտեղ նրանք ստեղծվել են և «գոյություն ունեն» մինչև չեն ջնջվում `delete` օպերատորի միջոցով (§4.2.2):

`Vector`֊ի պարզ օգտագործման ձևը հետևյալն է՝

````c++
   double read_and_sum(int s)
      //կարդում է s ամբողջ թվերը cin-ի միջոցով և վերադարձնում է նրանց գումարը; ենթադրվում է, որ s֊ը, պետք է լինի դրական
   {
      Vector v;
      vector_init(v,s);
      for(int i = 0; i != s; ++i)
         cin >> v.elem[i];

      double sum = 0;
      for(int i = 0; i != s; ++i)
         sum += v.elem[i];

      return sum;
   }
````








