# Դասեր

Those types are not "abstract";
they are as real as `int` and `float`.
-Doug Mcllroy


* Ներածություն
* Կոնկրետ տիպեր
      Թվաբանական տիպեր; Կոնտեյներ; Կոնտեյներների ինիցիալիզացիա
* Աբստրակտ տիպեր
* Վիրտուալ ֆունկցիաներ
* Դասերի հիերարխիա
      Ակնհայտ ձևափոխում; Հիերարխիայի առավելությունները; Hierarchy Navigation; Խուսափում ռեսուրսների հոսքից
* Կրկնօրինակում և տեղաշարժում
      Կոնտեյներների կրկնօրինակում; Կոնտեյներների տեղաշարժում; Հիմնական գործողությունները; Ռեսուրսների կառավարում; Suppressing Operations
* Խորհուրդներ


## 4.1 Ներածություն

Այս և հաջորդ գլուխները նպատակ ունեն գաղափար տալ C++ լեզվի աջակցության մասին աբստրակցիայի և ռեսուրսների ղեկավարման համար՝ առանց շատ մանրամասնությունների․
* Այս գլուխը ոչ պաշտոնապես ներկայացնում է նոր տիպերի (*օգտագործողի սահմանած տիպեր*) սահմանման և կիրառման ճանապարհները։ Մասնավորապես այն ներկայացնում է հիմնական հատկությունները, իրականացման տեխնիկան և լեզվական գործիքները, որոնք կիրառվում են *կոնկրետ դասերի*, *աբստրակտ դասերի*, և *դասերի հիերարխիայի* համար։
* Հաջորդ գլուխը ներկայացնում է շաբլոնները՝ որպես պարամետրիզացված տիպերի մեխանիզմ և and algorithms with (other) types and algorithms․ Հաշվարկները օգտագործողի սահմանած տիպերի և ներդրված տիպերի վրա ներկայացված են որպես ֆունկցիաներ, երբեմն որպես *ընդհանրացված ֆունկցիաներ* և *ֆունկցիաների օբյեկտներ*։ 

Սրանք լեզվի այն հնարավորություններն են, որոնք աջակցություն ունեն ծրագրավորման այն ոճերի կողմից, որոնք հայտնի են որպես *օբյկետ֊կողմնորոշված ծրագրավորում* և  *ընդհանրացված ծրագրավորում*։ 6-13 գլուխները հասցնում են ավարտին այս թեման՝ ներկայացնելով օրինակներ ստանդարտ գրադարանի հնարավորություններով և դրանց կիրառումով։

C++ լեզվի կենտրոնական առանձնահատկությունը (գործիքը) *դասն* է։ Դասը օգտագործողի սահմանած տիպ է, որը նախատեսված է ծրագրի կոդում ներկայացնելու որևէ հասկացություն։ Երբ, որ մեր ծրագրի ձևակերպումն ունենում է ինչ֊որ օգտակար կոնցեպցիա, գաղափար, էություն և այլն, մենք փորձում ենք այն ներկայացնել ծրագրի մեջ որպես դաս, այնպես, որ այդ հասկացությունը լինի կոդի մեջ, այլ ոչ թե մեր գլխում, ձևակերպման փաստաթղթի մեջ կամ մի քանի մեկնաբանություններում։ Այն ծրագիրը, որը կառուցված է լավ ընտրված դասերի խմբից, շատ ավելի հեշտ է հասկանալ և ստանալ right than one that builds every thing directly in terms of the built-in types. Մասնավոր դեպքերում դասերը հաճախ նրանք են, ինչ որ առաջարկում են գրադարանները։

Ըստ էության, լեզվի բոլոր գործիքները բացի ֆունդամենտալ տիպերից, օպերա տորներից և արտահայտություններից, նրա համար են, որպեսզի օգնեն սահմանել ավելի լավ դասեր կամ օգտագործեն դրանք ավելի հարմար ձևով։ «Ավելի լավ» ասելով ես նկատի ունեմ ավելի ճիշտ, ավելի հեշտ սպասարկվող, ավելի օգտավետ, ավելի էլեգանտ, ավելի հեշտ օգտագործելու համար, ավելի հեշտ կարդալու համար և ավելի հեշտ քննարկելու համար։ Ծրագրավորման տեխնիկաների մեծ մասը հենվում է առանձնահատուկ նշանակության դասերի ձևավորման և իրականացման վրա։ Ծրագրավորողների պահանջներն ու ճաշակները չափազանց տարբեր են։ Հետևաբար դասերի սատարումն էլ (support) լայն է։ Այստեղ մենք կդիտարկենք հիմնական support երեք կարևոր տեսակի դասերը․

* Կոնկրետ դասեր (§4.2)
* Աբստրակտ դասեր (§4.3)
* Դասեր դասերի հիերարխիաներում (§4.5)

Օգտակար դասերի ապշեցնող քանակը պարզվում է այս երեք տեսակներից որևէ մեկն է։ Դեռ ավելին, դասերը կարող են դիտարկվել որպես այս երեք տեսակների ավելի պարզ տարբերակներ կամ իրականացված են՝ օգտագործելով այդ դասերի համար օգտագործված տեխնիկաների կոմբինացիաները։


## 4.2 Կոնկրետ տիպեր

*Կոնկրետ դասերի* հիմնական գաղափարn այն է, որ նրանք իրենց պահում են "ներդրված տիպերի նման"։ Օրինակ, կոմպլեքս թվի տիպը և infinite-precision ամբողջ տիպը շատ նման են ներդրված `int` տիպին, բացի նրանից, իհարկե, որ նրանք ունեն իրենց սեփական սեմանտիկան և գործողությունների խմբերը։ Նմանապես `vector`֊ը և `string`֊ը շատ նման են ներդրված զանգվածներին, չհաշված, որ նրանք are better behaved։ (§7.2, §8.3, §9.2)։

Կոնկրետ տիպերի որոշիչ բնութագրությունն այն է, որ նրա ներկայացումը նրա սահմանման մի մասն է։ Կարևոր շատ դեպքերում, օրինակ `vector`֊ի դեպքում, այդ ներկայացումը մեկ կամ մի քանի ցուցիչ է՝ ուղղված տվյալների վրա, որոնք գտնվում են մեկ այլ տեղում, բայց այն ներկա է կոնկրետ դասի յուրաքանչյուր օբյեկտում։ Սա թույլ է տալիս, որպեսզի իրականացումներն օպտիմալ էֆեկտիվ լինեն ժամանակի և տեղի մեջ։ Մասնավորապես, այն թույլ է տալիս մեզ

* տեղադրել կոնկրետ տիպերի օբյեկտները ստեկի մեջ, ստատիկ առանձնացված հիշողության մեջ և այլ օբյեկտներում (§1.6);
* դիմել ուղիղ օբյեկտներին (ոչ միայն ցուցիչների կամ հղումների միջոցով);
* ինիցիալիզացնել օբյեկտներն անմիջապես և ամբողջությամբ (օր․ օգտագործելով կոնստրուկտորներ; §2.3); և
* պատճենել օբյեկտները (§4.6)

Ներկայացումը կարող է լինել գաղտնի (այնպես, ինչպես `Vector`֊ի համար է; §2.3) և հասանելի միայն ֆունկցիա֊անդամների միջոցով, բայց այն կա։ Հետևաբար, եթե ներկայացումը փոփոխվում է որևէ էական կերպով, օգտագործողը պետք է recompile. Սա է կոնկրետ տիպեր ունենալու գինը, որոնք ճշտորեն վարվում են ներդրված տիպերի նման։ Այն տիպերը, որոնք հաճախ չեն փոխվում, և որտեղ լոկալ փոփոխականներն ապահովում են շատ անհրաժեշտ պարզություն և էֆեկտիվություն, նրանց համար այս դեպքը ընդունելի է և հաճախ իդեալական։ Ճկունությունը մեծացնելու համար կոնկրետ տիպը իր ներկայացման մեծ մասը կարող է պահել հիշողության ազատ տարածքում (free store) (դինամիկ հիշողություն, heap) և դիմել նրանց այն մասի միջոցով, որը տեղադրված է դասի օբյեկտի մեջ։ Հենց այս ճանապարհով էլ իրականացվել են `vector` և `string` դասերը; they can be considered resource handles with carefully crafted interfaces.

### 4.2.1 Թվաբանական տիպ

«Օգտագործողի կողմից սահմանած ամենադասական թվաբանական տիպը» `complex` տիպն է․

````c++
   class complex {
      double re, im;   // երկու իրական թվերի ներկայացում
   public:
      complex (double r, double i) :re{r}, im{i} {}   // կառուցել կոմպլեքս տիպ երկու սկալյարներից
      complex (double r) :re{r}, im{0} {}   // կառուցել կոմպլեքս տիպ մեկ սկալյարից
      complex () :re{0}, im{0} {}   // լռությամբ կոմպլեքս տիպ։ {0,0}

      double real() const {return re;}
      void real (double d) {re = d;}
      double imag() const {return im;}
      void imag (double d) {im = d;}

      complex& operator += (complex z) {re += z.re, im += z.im; returnn *this;}   // գումարել re֊ին և im֊ին
// և վերադարձնել արդյունքը
      complex& operator -= (complex z) {re -= z.re, im -= z.im; return *this;}

      complex& operator *= (complex);   // 
      complex& operator /= (complex);   //
};
````

Սա ստանդարտ գրադարանի `complex` տիպի թեթևակի պարզեցրած տարբերակն է (§12.4)։ Դասի սահմանումն ինքնին պարունակում է միայն գործողություններ, որոնք պահանջում են մուտք ներկայացման մեջ։ Ներկայացումը պարզ է և պայմանական։ Պրակտիկ պատճառների համար այն պետք է համատեղելի լինի այն բանի հետ, ինչ որ  Ֆորտրանն էր ապահովում 50 տարի առաջ, և մեզ անհրաժեշտ են օպերատորների պայմանական խումբ։ Տրամաբանական պահանջներին գումարած `complex`֊ը պետք է լինի էֆեկտիվ կամ էլ այն կմնա չօգտագործված։ Սա ենթադրում է, որ պարզ գործողությունները պետք է լինեն ներսում։ Սա նշանակում է, որ պարզ գործողությունները (այնպիսիք, ինչպիսիք են օրինակ կոնստրուկտորները, `+=`, և `imag()`) պետք է իրականացված լինեն առանց ֆունկցիաների կանչերի ստեղծված մեքենայական կոդում։ Այն ֆունկցիաները, որոնք սահմանված են դասի մեջ ներկառուցված են լռությամբ։ Հնարավոր է բացահայտորեն պահանջել ներկառուցում՝ ֆունկցիայի հայտարարության առջևից  դնելով `inline` բառը։ An industrial-strength `complex` (ինչպիսին ստանդարտ գրադարանինն է) զգուշորեն իրականացված է կատարելու համար համապատասխան ներկառուցում։

Այն կոնստրուկտորը, որը կարող է կանչվել առանց որևէ արգումենտի կոչվում է *լռությամբ կոնստրուկտոր*։ Այսպիսով, `complex()`֊ը `complex`֊ի լռությամբ կոնստրուկտորն է։ Սահմանելով լռությամբ կոնստրուկտոր դուք վերացնում եք հնարավորությունը ունենալու այդ տիպի ոչ ինիցիալիզացված փոփոխականներ։

`const` նշիչները իրական և երևակայական մասեր վերադարձնող ֆունկցիաների վրա, ցույց են տալիս, որ այդ ֆունկցիաները չեն ձևափոխում այն օբյեկտը, որի համար որ նրանք կանչվել են։

Շատ օգտակար գործողություններ չեն պահանջում ուղիղ դիմում `complex` տիպի ներկայացմանը, այդպիսով նրանք կարող են սահմանվել դասի սահմանումից առանձին․

````c++
   complex operator+(complex a, complex b) {return a += b;}
   complex operator-(complex a, complex b) {return a -= b;}
   complex operator-(complex a) {return {-a.real(), -a.imag()};}      // ունար հանում
   complex operator*(complex a, complex b) {return a *= b;}
   complex operator/(complex a, complex b) {return a /= b;}
````

Այստեղ ես օգտագործում եմ այն փաստը, որ արժեքով փոխանցված արգումենտը պատճենվում է, հետևաբար ես կարող եմ ձևափոխել արգումենտը առանց կպնելու կանչողի կրկնօրինակին և օգտագործել արդյունքը որպես վերադարձվող արժեք։

`==` և `!=` գործողությունների սահմանումները are straightforward՝

````c++
   bool operator ==(complex a, complex b)      // հավասար են
   {
      return a.real() == b.real() && a.imag() ==b.imag();
   }

   bool operator != (complex a, complex b)      // հավասար չեն
   {
      return !(a == b);
   }

   complex sqrt(complex);      // the definition is elsewhere

   // ...
````

`complex` դասը կարող է օգտագործվել այսպես․

````c++
   void f(complex z)
   {
      complex a{2.3};      // կառուցել {2.3, 0.0} 2.3֊ից
      complex b{1/a};
      complex c {a+z*complex{1, 2.3}};
      // ...
      if (c != b)
            c = -(b/a) + 2*b;
   }
````

Կոմպիլյատորը ձևափոխում է այն օպերատորները, որոնք ներառում են `complex` թվեր, համապատասխան ֆունկցիաների կանչերի։ Օրինակ `c != b` նշանակում է `operator != (c,b)` և `1/a`նշանակում է `operator/(complex{1}, a)`։

Օգտագործողի սահմանած  օպերատորները («գերբեռնված օպերատորները») պետք է օգտագործվեն զգուշորեն և պայմանականորեն։ Սինտաքսիսը ֆիքսված է լեզվի կողմից, այնպես որ դուք չեք կարող սահմանել ունար `/` գործողություն։ Նաև հնարավոր չէ փոխել օպերատորի նշանակությունը ներդրված տիպերի համար, այնպես որ դուք չեք կարող վերասահմանել `+`֊ը `int`֊երը հանելու համար։

## 4.2.2 Կոնտեյներ

*Կոնտեյները* օբյեկտ է, որը պահում է էլեմենտների հավաքածու, այսպիսով մենք կոչում ենք `Vector`֊ը կոնտեյներ, որովհետև այն այն տիպի օբյեկտներից է, որոնք կոնտեյներներ են։ Ինչպես, որ սահմանվել է §2.3֊ում, `Vector`֊ը `double`արժեքների անհիմն կոնտեյներ չէ՝ այն շատ պարզ է հասկանալու համար, հաստատում է օգտակար ինվարիանտ (§3.4.2), ապահովում է range-checked դիմում (§3.4.1) և ապահովում է `size()` ֆունկցիա, որը մեզ թույլ է տալիս անցնել նրա էլեմենտների վրայով։ Ինչևէ, այն ունի ճակատագրական սխալ՝ այն տեղադրում է էլեմենտներն օգտագործելով `new` օպերատորը բայց երբեք չի ազատում այդ տարածքները։ Սա լավ գաղափար չէ, քանի որ չնայած որ C++ լեզուն սահմանում է ինտերֆեյս garbage collector֊ի համար (§4.6.4), երաշխավորված չէ, որ one is available to make unused memory available for new objects. Որոշ միջավայրերում դուք չեք կարող օգտագործել հավաքիչը և երբեմն դու նախընտրում ես ջնջման ավելի ճշգրիտ հսկողություն տրամաբանական կամ էֆեկտիվության պատճառներից ելնելով։ Մեզ անհրաժեշտ է այնպիսի մեխանիզմ, որը կհավաստիացնի, որ այն հիշողությունը, որն առանձնացվել է կոսնտրուկտորի կողմից, ազատվել է; այդ մեխանիզմը *դեստրուկտորն է*․

````c++
   class Vector {
   private:
         double* elem;      // elem֊ը ցույց է տալիս sz հատ double֊ների զանգվածի վրա
         int sz;
   public:
         Vector(int s) : elem{new double[s]}, sz{s}      // կոնստրուկտոր՝ ստանալ ռեսուրսներ
         {
               for (int i = 0; i != s; ++i)      // ինիցիալիզացնել էլեմենտները
                     elem[i] = 0;
         }

         ~Vector() {delete[] elem;}      // դեստրուկտոր՝ բաց թողնել ռեսուրսները

         double& operator[](int i);
         int size() const;
   };
````

Դեստրուկտորի անունը հանդիսանում է`~` օպերատորի լրացումը, որից հետո գալիս է դասի անունը; այն հանդիսանում է կոնստրուկտորի լրացում։ `Vector`֊ի կոնստրուկտորն առանձնացնում է ինչ֊որ չափի հիշողություն հիշողության ազատ տարածքում՝ (որը կոչվում է նաև *heap* կամ *դինամիկ տարածք*) օգտագործելով `new` օպերատորը։ Դեստրուկտորը մաքրում է ազատելով այդ տարածքը՝ օգտագործելով `delete` օպերատորը։ Այս ամենը կատարվում է առանց `Vector`֊ի օգտագործողների միջամտության։ Օգտագործողները պարզապես ստեղծում և օգտագործում են `Vector`֊ներ այնքան, ինչքան որ փոփոխականները ներդրված տիպերի։ Օրինակ․

````c++
   void fct(int n)
   {
         Vector v(n);

         // ... v-ի կիրառումը

         {
               Vector v2(2*n);
               // ... v֊ի և v2֊ի կիրառումը
         } // v2-ը այստեղ ջնջվում է

          // ․․․ v֊ի կիրառումը ..

   } // v֊ն ջնջվում է այստեղ
````

`Vector`֊ը ենթարկվում է միևնույն կանոններին անվանելու, տեսանելիության տիրույթի, տարածքի, կյանքի տևողության և այլն համար (§1.6), ինչպես որ անում է ներդրված տիպը, այնպիսին ինչպիսին է `int`֊ը և `char`֊ը։ Այս `Vector`֊ը պարզեցված է by leaving out error handling; տե՛ս §3.4։ 

   Կոնստրուկտոր/դեստրուկտոր կոմբինացիան շատ էլեգանտ տեխնիկաների հիմքն է։ Մասնավորապես այն համարվում է C++ լեզվի հիմնական ռեսուրսների կառավարման տեխնիկաների մեծ մասի հիմքը (§11.2)։ Եկեք նայենք `Vector`֊ի գրաֆիկական լուսաբանումը․

նկար գլուխ 4.2.2

Կոնստրուկտորը հարկ եղած ձևով տեղադրում է էլեմենտները և ինիցիալիզացնում է `Vector`֊ը։ Դեստրուկտորը դատարկում է էլեմենտները։ Այս *handle-to-data model*֊ը շատ լավ կիրառվում է՝ ղեկավարելու համար այն տվյալները, որոնք կարող են փոփոխվել չափով, օբյեկտի կյանքի տևողության ընթացքում։ Ռեսուրսների ձեռքբերման տեխնիկան կոնստրուկտորում և դրանց բացթողնումը դեստրուկտորում, որը հայտնի է որպես Resource Acquisition Is Initialization or RAII, մեզ թույլ է տալիս վերացնել «մերկ `new`գործողությունները» that is, to avoid allocations in general code
and keep them buried inside the implementation of well-behaved abstractions. Similarly, ‘‘naked delete operations’’ should be avoided. Avoiding naked new and naked delete makes code far less error-prone and far easier to keep free of resource leaks (§11.2).

## 4.2.3 Կոնտեյներների ինիցիալիզացում

Կոնտեյները տարրերը պահելու համար է, ակնհայտորեն մեզ անհրաժեշտ են հարմար ճանապարհներ տարրերը կոնտեյների մեջ ստանալու համար։ Մենք կարող ենք handle դա՝ ստեղծելով `Vector`՝ համապատասխան թվով տարրերով և հետո վերագրենք նրանց արժեքներ, բայց որպես կանոն մյուս տարբերակները ավելի առաջնակարգ են։ Այստեղ ես ուղղակի նշում եմ երկու ամենակիրառվողները․
* _Ինիցիալիզացիոն լիստով կոնստրուկտոր՝_ ինիցիալիզացնել տարրերի ցանկով։
* `push_back()․` Ավելացնել նոր տարր հաջորդականության (ետևից) վերջում։ 

Վերջիններս կարող են հայտարարվել հետևյալ կերպ․

````c++
   class Vector {
   public:
            Vector (std::initializer_list<double>);      // ինիցիալիզացնել իրական թվերի ցանկով
            // ...
            void push_back(double);            // ավելացնել էլեմենտ վերջից՝ մեծացնելով չափը մեկով
            // ...
   };
````

`push_back`֊ն օգտակար է պատահական քանակի տարրերի ներմուծման դեպքում։ Օրինակ

````c++
   Vector read(istream& is)
   {
         Vector v;
         for (double d; is >> d;)      // կարդալ սահող ստորակետով արժեքները d ֊ի մեջ
               v.push_back(d);            // ավելացնել v֊ին
         return v;
   }
````

Ներմուծման ցիկլն ավարտվում է ֆայլի վերջով (end-of-file) կամ ֆորմատավորման սխալով։ Մինչև դա, յուրաքանչյուր կարդացվող թիվ ավելացվում է `Vector`֊ին և այսպես մինչև վերջ, `v`֊ի չափը կարդացած տարրերի քանակն է։ Ես օգտագործել եմ `for`֊արտահայտությունը նախընտրելով ավելի ընդունված պայմանական `while`֊արտահայտությունից, որպեսզի `d`֊ի տեսանելիության տիրույթը սահմանափակ ցիկլի ներսում։ The way to provide Vector with a move constructor, so that returning a potentially huge amount of data from read() is cheap, is explained in §4.6.2.

`std::initializer_list`-ը, որն օգտագործվել է սահմանելու համար ինիցիալիզացիոն լիստով կոնստրուկտոր, ստանդարտ գրադարանի տիպ է, որը հայտնի է կոմպիլյատորին․ երբ մենք օգտագործում ենք `{}`֊ցուցակ, այնպիսին, ինչպիսինն է `{1,2,3,4}`֊ը, կոմպիլյատորը կստեղծի օբյեկտ `initializer_list` տիպով, որպեսզի տա ծրագրին։ Այսպիսով, մենք կարող ենք գրել․

````c++
   Vector v1 = {1,2,3,4,5};                   // v1֊ն ունի 5 տարր
   Vector v2 = {1.23, 3.45, 6.7, 8};      // v2֊ն ունի 4 տարր
````

`Vector`֊ի ինիցիալիզացիոն լիստով կոնստրուկտորը կարող էր սահմանվել հետևյալ կերպ․

````c++
   Vector::Vector(std::initializer_list<double> lst)      // ինիցիալիզացնել ցանկով
            :elem{new double[lst.size()]}, sz{static_cast<int>(lst.size())}
   {
            copy(lst.begin(), lst.end(), elem);            // պատճենել lst֊ից elem֊ի մեջ (§10.6)
   }
````

Ես օգտագործում եմ տգեղ `static_cast`֊ը՝ (§14.2.3) ձևափոխելու համար ինիցիալիզացիոն լիստի չափը `int` տիպի: Սա շատ մանրացրած է, քանի որ հնարավորությունը, որ ձեռքով գրված տարրերի քանակը մեծ կլինի ամենամեծ ամբողջից (32,767 16֊բիթ ամբողջների համար և 2,147,483,647 32-բիթ ամբողջների համար) շատ քիչ հավանական է: Ինչևէ it is worth remembering that the type system has no common sense. Այն գիտի փոփոխականների հնարավոր արժեքների մասին ավելի, քան փաստացի արժեքների մասին, so it might complain where there is no actual violation։ Ինչևէ, վաղ թե ուշ, այդպիսի զգուշացումները կփրկեն ծրագրավորողին վատ սխալներից։

`static_cast` հրամանը չի ստուգում այն արժեքը, որը որ ձևափոխում է; ծրագրավորողը հույս ունի, որ այն ճիշտ է օգտագործում։ Միշտ չէ, որ սա լավ ենթադրություն է, այնպես որ, եթե կասկածում եք, ստուգեք արժեքը։ Տիպի բացահայտ ձևափոխումներից (often called casts to remind you that they are used to prop up something broken) ավելի լավ է հրաժարվել։ Տիպերի համակարգի խելամիտ օգտագործումը և լավ ձևավորված գրադարանները մեզ թույլ են տալիս բացառել չստուգված վարքը բարձր մակարդակի ծրագրերում։

# 4.3 Աբստրակտ տիպեր












 
