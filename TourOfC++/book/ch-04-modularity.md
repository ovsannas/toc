# Դասեր

Those types are not "abstract";
they are as real as `int` and `float`.
-Doug Mcllroy


* Ներածություն
* Կոնկրետ տիպեր
      Թվաբանական տիպեր; Կոնտեյներ; Կոնտեյներների ինիցիալիզացիա
* Աբստրակտ տիպեր
* Վիրտուալ ֆունկցիաներ
* Դասերի հիերարխիա
      Ակնհայտ ձևափոխում; Հիերարխիայի առավելությունները; Hierarchy Navigation; Խուսափում ռեսուրսների հոսքից
* Կրկնօրինակում և տեղաշարժում
      Կոնտեյներների կրկնօրինակում; Կոնտեյներների տեղաշարժում; Հիմնական գործողությունները; Ռեսուրսների կառավարում; Suppressing Operations
* Խորհուրդներ


## 4.1 Ներածություն

Այս և հաջորդ գլուխները նպատակ ունեն գաղափար տալ C++ լեզվի աջակցության մասին աբստրակցիայի և ռեսուրսների ղեկավարման համար՝ առանց շատ մանրամասնությունների․
* Այս գլուխը ոչ պաշտոնապես ներկայացնում է նոր տիպերի (*օգտագործողի սահմանած տիպեր*) սահմանման և կիրառման ճանապարհները։ Մասնավորապես այն ներկայացնում է հիմնական հատկությունները, իրականացման տեխնիկան և լեզվական գործիքները, որոնք կիրառվում են *կոնկրետ դասերի*, *աբստրակտ դասերի*, և *դասերի հիերարխիայի* համար։
* Հաջորդ գլուխը ներկայացնում է շաբլոնները՝ որպես պարամետրիզացված տիպերի մեխանիզմ և and algorithms with (other) types and algorithms․ Հաշվարկները օգտագործողի սահմանած տիպերի և ներդրված տիպերի վրա ներկայացված են որպես ֆունկցիաներ, երբեմն որպես *ընդհանրացված ֆունկցիաներ* և *ֆունկցիաների օբյեկտներ*։ 

Սրանք լեզվի այն հնարավորություններն են, որոնք աջակցություն ունեն ծրագրավորման այն ոճերի կողմից, որոնք հայտնի են որպես *օբյկետ֊կողմնորոշված ծրագրավորում* և  *ընդհանրացված ծրագրավորում*։ 6-13 գլուխները հասցնում են ավարտին այս թեման՝ ներկայացնելով օրինակներ ստանդարտ գրադարանի հնարավորություններով և դրանց կիրառումով։

C++ լեզվի կենտրոնական առանձնահատկությունը (գործիքը) *դասն* է։ Դասը օգտագործողի սահմանած տիպ է, որը նախատեսված է ծրագրի կոդում ներկայացնելու որևէ հասկացություն։ Երբ, որ մեր ծրագրի ձևակերպումն ունենում է ինչ֊որ օգտակար կոնցեպցիա, գաղափար, էություն և այլն, մենք փորձում ենք այն ներկայացնել ծրագրի մեջ որպես դաս, այնպես, որ այդ հասկացությունը լինի կոդի մեջ, այլ ոչ թե մեր գլխում, ձևակերպման փաստաթղթի մեջ կամ մի քանի մեկնաբանություններում։ Այն ծրագիրը, որը կառուցված է լավ ընտրված դասերի խմբից, շատ ավելի հեշտ է հասկանալ և ստանալ right than one that builds every thing directly in terms of the built-in types. Մասնավոր դեպքերում դասերը հաճախ նրանք են, ինչ որ առաջարկում են գրադարանները։

Ըստ էության, լեզվի բոլոր գործիքները բացի ֆունդամենտալ տիպերից, օպերա տորներից և արտահայտություններից, նրա համար են, որպեսզի օգնեն սահմանել ավելի լավ դասեր կամ օգտագործեն դրանք ավելի հարմար ձևով։ «Ավելի լավ» ասելով ես նկատի ունեմ ավելի ճիշտ, ավելի հեշտ սպասարկվող, ավելի օգտավետ, ավելի էլեգանտ, ավելի հեշտ օգտագործելու համար, ավելի հեշտ կարդալու համար և ավելի հեշտ քննարկելու համար։ Ծրագրավորման տեխնիկաների մեծ մասը հենվում է առանձնահատուկ նշանակության դասերի ձևավորման և իրականացման վրա։ Ծրագրավորողների պահանջներն ու ճաշակները չափազանց տարբեր են։ Հետևաբար դասերի սատարումն էլ (support) լայն է։ Այստեղ մենք կդիտարկենք հիմնական support երեք կարևոր տեսակի դասերը․

* Կոնկրետ դասեր (§4.2)
* Աբստրակտ դասեր (§4.3)
* Դասեր դասերի հիերարխիաներում (§4.5)

Օգտակար դասերի ապշեցնող քանակը պարզվում է այս երեք տեսակներից որևէ մեկն է։ Դեռ ավելին, դասերը կարող են դիտարկվել որպես այս երեք տեսակների ավելի պարզ տարբերակներ կամ իրականացված են՝ օգտագործելով այդ դասերի համար օգտագործված տեխնիկաների կոմբինացիաները։


## 4.2 Կոնկրետ տիպեր

*Կոնկրետ դասերի* հիմնական գաղափարն այն է, որ նրանք իրենց պահում են "ներդրված տիպերի նման"։ Օրինակ, կոմպլեքս թվի տիպը և անվերջ֊չափողականությամբ(infinite-precision) ամբողջ տիպը շատ նման են ներդրված `int` տիպին, բացի նրանից, իհարկե, որ նրանք ունեն իրենց սեփական սեմանտիկան և գործողությունների բազմությունը։ Նմանապես `vector`֊ը և `string`֊ը շատ նման են ներդրված զանգվածների տիպին, չհաշված, որ նրանց վարքը ավելի լավ է կազմակերպված (§7.2, §8.3, §9.2)։

Կոնկրետ տիպի որոշիչ բնութագիրն այն է, որ նրա ներկայացումը նրա սահմանման մի մասն է։ Կարևոր շատ դեպքերում, օրինակ `vector`֊ի դեպքում, այդ ներկայացումը մեկ կամ մի քանի ցուցիչ է՝ ուղղված հիշողության ինչ֊որ տեղում գտնվող տվյալների վրա, բայց այդ ցուցիչն առկա է այդ կոնկրետ դասի յուրաքանչյուր օբյեկտում։ Դա թույլ է տալիս, որ իրականացումները լինեն օպտիմալ էֆեկտիվ ժամանակի և տարածության մեջ։ Մասնավորապես դա մեզ թույլ է տալիս
* կոնկրետ տիպերի օբյեկտները ստեղծել ստեկի մեջ, ստատիկ առանձնացված հիշողության մեջ և ուրիշ օբյեկտների մեջ (§1.6);
* ուղղակիորեն դիմել օբյեկտներին (և ոչ միայն ցուցիչների կամ հղումների միջոցով);
* անմիջապես և ամբողջությամբ արժեքավորել օբյեկտները(օր․ օգտագործելով կոնստրուկտորները; §2.3); և
* պատճենել օբյեկտները (§4.6)

Ներկայացումը կարող է լինել փակ (ինչպիսին այն `Vector`֊ի համար է; §2.3) և հասանելի միայն անդամ֊ֆունկցիաների միջոցով, բայց այն գոյություն ունի։ Հետևաբար, եթե ներկայացումը փոփոխվում է ինչ֊որ էական կերպով, օգտագործողը պետք է այն նորից կոմպիլյացնի։ Սա է այն գինը , որը վճարում ենք, որպեսզի ունենանք ճշտորեն ներդրված տիպերի  նման վարք ունեցող կոնկրետ տիպեր։ Հաճախակի չփոփոխվող տիպերի համար և որտեղ լոկալ փոփոխականներն ապահովում են շատ անհրաժեշտ պարզություն և էֆեկտիվություն, սա ընդունելի և հաճախ իդեալական է։ Ճկունության ավելացնելու համար կոնկրետ տիպը իր ներկայացման մեծ մասը կարող է պահել հիշողության ազատ տարածքում (free store) (դինամիկ հիշողություն, heap) և դիմել նրանց հենց դասի օբյեկտի մեջ գտնվող մասով։ Հենց այս ձևով են իրականացվել `vector` և `string` դասերը; նրանք կարող են համարվել ռեսուրսների մշակիչներ զգուշորեն կազմակերպված ինտերֆեյսերով։

### 4.2.1 Թվաբանական տիպ

«Օգտագործողի կողմից սահմանած ամենադասական թվաբանական տիպը» `complex` տիպն է․

````c++
   class complex {
      double re, im;   // երկու իրական թվերի ներկայացում
   public:
      complex (double r, double i) :re{r}, im{i} {}   // կառուցել կոմպլեքս տիպ երկու սկալյարներից
      complex (double r) :re{r}, im{0} {}   // կառուցել կոմպլեքս տիպ մեկ սկալյարից
      complex () :re{0}, im{0} {}   // լռությամբ կոմպլեքս տիպ։ {0,0}

      double real() const {return re;}
      void real (double d) {re = d;}
      double imag() const {return im;}
      void imag (double d) {im = d;}

      complex& operator += (complex z) {re += z.re, im += z.im; returnn *this;}   // գումարել re֊ին և im֊ին
// և վերադարձնել արդյունքը
      complex& operator -= (complex z) {re -= z.re, im -= z.im; return *this;}

      complex& operator *= (complex);   // 
      complex& operator /= (complex);   //
};
````

Սա ստանդարտ գրադարանի `complex` տիպի թեթևակի պարզեցրած տարբերակն է (§12.4)։ Դասի սահմանումն ինքնին պարունակում է միայն գործողություններ, որոնք պահանջում են մուտք ներկայացման մեջ։ Ներկայացումը պարզ է և պայմանական։ Պրակտիկ պատճառների համար այն պետք է համատեղելի լինի այն բանի հետ, ինչ որ  Ֆորտրանն էր ապահովում 50 տարի առաջ, և մեզ անհրաժեշտ են օպերատորների պայմանական խումբ։ Տրամաբանական պահանջներին գումարած `complex`֊ը պետք է լինի էֆեկտիվ կամ էլ այն կմնա չօգտագործված։ Սա ենթադրում է, որ պարզ գործողությունները պետք է լինեն ներսում։ Սա նշանակում է, որ պարզ գործողությունները (այնպիսիք, ինչպիսիք են օրինակ կոնստրուկտորները, `+=`, և `imag()`) պետք է իրականացված լինեն առանց ֆունկցիաների կանչերի ստեղծված մեքենայական կոդում։ Այն ֆունկցիաները, որոնք սահմանված են դասի մեջ ներկառուցված են լռությամբ։ Հնարավոր է բացահայտորեն պահանջել ներկառուցում՝ ֆունկցիայի հայտարարության առջևից  դնելով `inline` բառը։ An industrial-strength `complex` (ինչպիսին ստանդարտ գրադարանինն է) զգուշորեն իրականացված է կատարելու համար համապատասխան ներկառուցում։

Այն կոնստրուկտորը, որը կարող է կանչվել առանց որևէ արգումենտի կոչվում է *լռությամբ կոնստրուկտոր*։ Այսպիսով, `complex()`֊ը `complex`֊ի լռությամբ կոնստրուկտորն է։ Սահմանելով լռությամբ կոնստրուկտոր դուք վերացնում եք հնարավորությունը ունենալու այդ տիպի ոչ ինիցիալիզացված փոփոխականներ։

`const` նշիչները իրական և երևակայական մասեր վերադարձնող ֆունկցիաների վրա, ցույց են տալիս, որ այդ ֆունկցիաները չեն ձևափոխում այն օբյեկտը, որի համար որ նրանք կանչվել են։

Շատ օգտակար գործողություններ չեն պահանջում ուղիղ դիմում `complex` տիպի ներկայացմանը, այդպիսով նրանք կարող են սահմանվել դասի սահմանումից առանձին․

````c++
   complex operator+(complex a, complex b) {return a += b;}
   complex operator-(complex a, complex b) {return a -= b;}
   complex operator-(complex a) {return {-a.real(), -a.imag()};}      // ունար հանում
   complex operator*(complex a, complex b) {return a *= b;}
   complex operator/(complex a, complex b) {return a /= b;}
````

Այստեղ ես օգտագործում եմ այն փաստը, որ արժեքով փոխանցված արգումենտը պատճենվում է, հետևաբար ես կարող եմ ձևափոխել արգումենտը առանց կպնելու կանչողի կրկնօրինակին և օգտագործել արդյունքը որպես վերադարձվող արժեք։

`==` և `!=` գործողությունների սահմանումները are straightforward՝

````c++
   bool operator ==(complex a, complex b)      // հավասար են
   {
      return a.real() == b.real() && a.imag() ==b.imag();
   }

   bool operator != (complex a, complex b)      // հավասար չեն
   {
      return !(a == b);
   }

   complex sqrt(complex);      // the definition is elsewhere

   // ...
````

`complex` դասը կարող է օգտագործվել այսպես․

````c++
   void f(complex z)
   {
      complex a{2.3};      // կառուցել {2.3, 0.0} 2.3֊ից
      complex b{1/a};
      complex c {a+z*complex{1, 2.3}};
      // ...
      if (c != b)
            c = -(b/a) + 2*b;
   }
````

Կոմպիլյատորը ձևափոխում է այն օպերատորները, որոնք ներառում են `complex` թվեր, համապատասխան ֆունկցիաների կանչերի։ Օրինակ `c != b` նշանակում է `operator != (c,b)` և `1/a`նշանակում է `operator/(complex{1}, a)`։

Օգտագործողի սահմանած  օպերատորները («գերբեռնված օպերատորները») պետք է օգտագործվեն զգուշորեն և պայմանականորեն։ Սինտաքսիսը ֆիքսված է լեզվի կողմից, այնպես որ դուք չեք կարող սահմանել ունար `/` գործողություն։ Նաև հնարավոր չէ փոխել օպերատորի նշանակությունը ներդրված տիպերի համար, այնպես որ դուք չեք կարող վերասահմանել `+`֊ը `int`֊երը հանելու համար։

## 4.2.2 Կոնտեյներ

*Կոնտեյները* օբյեկտ է, որը պահում է էլեմենտների հավաքածու, այսպիսով մենք կոչում ենք `Vector`֊ը կոնտեյներ, որովհետև այն այն տիպի օբյեկտներից է, որոնք կոնտեյներներ են։ Ինչպես, որ սահմանվել է §2.3֊ում, `Vector`֊ը `double`արժեքների անհիմն կոնտեյներ չէ՝ այն շատ պարզ է հասկանալու համար, հաստատում է օգտակար ինվարիանտ (§3.4.2), ապահովում է range-checked դիմում (§3.4.1) և ապահովում է `size()` ֆունկցիա, որը մեզ թույլ է տալիս անցնել նրա էլեմենտների վրայով։ Ինչևէ, այն ունի ճակատագրական սխալ՝ այն տեղադրում է էլեմենտներն օգտագործելով `new` օպերատորը բայց երբեք չի ազատում այդ տարածքները։ Սա լավ գաղափար չէ, քանի որ չնայած որ C++ լեզուն սահմանում է ինտերֆեյս garbage collector֊ի համար (§4.6.4), երաշխավորված չէ, որ one is available to make unused memory available for new objects. Որոշ միջավայրերում դուք չեք կարող օգտագործել հավաքիչը և երբեմն դու նախընտրում ես ջնջման ավելի ճշգրիտ հսկողություն տրամաբանական կամ էֆեկտիվության պատճառներից ելնելով։ Մեզ անհրաժեշտ է այնպիսի մեխանիզմ, որը կհավաստիացնի, որ այն հիշողությունը, որն առանձնացվել է կոսնտրուկտորի կողմից, ազատվել է; այդ մեխանիզմը *դեստրուկտորն է*․

````c++
   class Vector {
   private:
         double* elem;      // elem֊ը ցույց է տալիս sz հատ double֊ների զանգվածի վրա
         int sz;
   public:
         Vector(int s) : elem{new double[s]}, sz{s}      // կոնստրուկտոր՝ ստանալ ռեսուրսներ
         {
               for (int i = 0; i != s; ++i)      // ինիցիալիզացնել էլեմենտները
                     elem[i] = 0;
         }

         ~Vector() {delete[] elem;}      // դեստրուկտոր՝ բաց թողնել ռեսուրսները

         double& operator[](int i);
         int size() const;
   };
````

Դեստրուկտորի անունը հանդիսանում է`~` օպերատորի լրացումը, որից հետո գալիս է դասի անունը; այն հանդիսանում է կոնստրուկտորի լրացում։ `Vector`֊ի կոնստրուկտորն առանձնացնում է ինչ֊որ չափի հիշողություն հիշողության ազատ տարածքում՝ (որը կոչվում է նաև *heap* կամ *դինամիկ տարածք*) օգտագործելով `new` օպերատորը։ Դեստրուկտորը մաքրում է ազատելով այդ տարածքը՝ օգտագործելով `delete` օպերատորը։ Այս ամենը կատարվում է առանց `Vector`֊ի օգտագործողների միջամտության։ Օգտագործողները պարզապես ստեղծում և օգտագործում են `Vector`֊ներ այնքան, ինչքան որ փոփոխականները ներդրված տիպերի։ Օրինակ․

````c++
   void fct(int n)
   {
         Vector v(n);

         // ... v-ի կիրառումը

         {
               Vector v2(2*n);
               // ... v֊ի և v2֊ի կիրառումը
         } // v2-ը այստեղ ջնջվում է

          // ․․․ v֊ի կիրառումը ..

   } // v֊ն ջնջվում է այստեղ
````

`Vector`֊ը ենթարկվում է միևնույն կանոններին անվանելու, տեսանելիության տիրույթի, տարածքի, կյանքի տևողության և այլն համար (§1.6), ինչպես որ անում է ներդրված տիպը, այնպիսին ինչպիսին է `int`֊ը և `char`֊ը։ Այս `Vector`֊ը պարզեցված է by leaving out error handling; տե՛ս §3.4։ 

   Կոնստրուկտոր/դեստրուկտոր կոմբինացիան շատ էլեգանտ տեխնիկաների հիմքն է։ Մասնավորապես այն համարվում է C++ լեզվի հիմնական ռեսուրսների կառավարման տեխնիկաների մեծ մասի հիմքը (§11.2)։ Եկեք նայենք `Vector`֊ի գրաֆիկական լուսաբանումը․

նկար գլուխ 4.2.2

Կոնստրուկտորը հարկ եղած ձևով տեղադրում է էլեմենտները և ինիցիալիզացնում է `Vector`֊ը։ Դեստրուկտորը դատարկում է էլեմենտները։ Այս *handle-to-data model*֊ը շատ լավ կիրառվում է՝ ղեկավարելու համար այն տվյալները, որոնք կարող են փոփոխվել չափով, օբյեկտի կյանքի տևողության ընթացքում։ Ռեսուրսների ձեռքբերման տեխնիկան կոնստրուկտորում և դրանց բացթողնումը դեստրուկտորում, որը հայտնի է որպես Resource Acquisition Is Initialization or RAII, մեզ թույլ է տալիս վերացնել «մերկ `new`գործողությունները» that is, to avoid allocations in general code
and keep them buried inside the implementation of well-behaved abstractions. Similarly, ‘‘naked delete operations’’ should be avoided. Avoiding naked new and naked delete makes code far less error-prone and far easier to keep free of resource leaks (§11.2).

## 4.2.3 Կոնտեյներների ինիցիալիզացում

Կոնտեյները տարրերը պահելու համար է, ակնհայտորեն մեզ անհրաժեշտ են հարմար ճանապարհներ տարրերը կոնտեյների մեջ ստանալու համար։ Մենք կարող ենք handle դա՝ ստեղծելով `Vector`՝ համապատասխան թվով տարրերով և հետո վերագրենք նրանց արժեքներ, բայց որպես կանոն մյուս տարբերակները ավելի առաջնակարգ են։ Այստեղ ես ուղղակի նշում եմ երկու ամենակիրառվողները․
* _Ինիցիալիզացիոն լիստով կոնստրուկտոր՝_ ինիցիալիզացնել տարրերի ցանկով։
* `push_back()․` Ավելացնել նոր տարր հաջորդականության (ետևից) վերջում։ 

Վերջիններս կարող են հայտարարվել հետևյալ կերպ․

````c++
   class Vector {
   public:
            Vector (std::initializer_list<double>);      // ինիցիալիզացնել իրական թվերի ցանկով
            // ...
            void push_back(double);            // ավելացնել էլեմենտ վերջից՝ մեծացնելով չափը մեկով
            // ...
   };
````

`push_back`֊ն օգտակար է պատահական քանակի տարրերի ներմուծման դեպքում։ Օրինակ

````c++
   Vector read(istream& is)
   {
         Vector v;
         for (double d; is >> d;)      // կարդալ սահող ստորակետով արժեքները d ֊ի մեջ
               v.push_back(d);            // ավելացնել v֊ին
         return v;
   }
````

Ներմուծման ցիկլն ավարտվում է ֆայլի վերջով (end-of-file) կամ ֆորմատավորման սխալով։ Մինչև դա, յուրաքանչյուր կարդացվող թիվ ավելացվում է `Vector`֊ին և այսպես մինչև վերջ, `v`֊ի չափը կարդացած տարրերի քանակն է։ Ես օգտագործել եմ `for`֊արտահայտությունը նախընտրելով ավելի ընդունված պայմանական `while`֊արտահայտությունից, որպեսզի `d`֊ի տեսանելիության տիրույթը սահմանափակ ցիկլի ներսում։ The way to provide Vector with a move constructor, so that returning a potentially huge amount of data from read() is cheap, is explained in §4.6.2.

`std::initializer_list`-ը, որն օգտագործվել է սահմանելու համար ինիցիալիզացիոն լիստով կոնստրուկտոր, ստանդարտ գրադարանի տիպ է, որը հայտնի է կոմպիլյատորին․ երբ մենք օգտագործում ենք `{}`֊ցուցակ, այնպիսին, ինչպիսինն է `{1,2,3,4}`֊ը, կոմպիլյատորը կստեղծի օբյեկտ `initializer_list` տիպով, որպեսզի տա ծրագրին։ Այսպիսով, մենք կարող ենք գրել․

````c++
   Vector v1 = {1,2,3,4,5};                   // v1֊ն ունի 5 տարր
   Vector v2 = {1.23, 3.45, 6.7, 8};      // v2֊ն ունի 4 տարր
````

`Vector`֊ի ինիցիալիզացիոն լիստով կոնստրուկտորը կարող էր սահմանվել հետևյալ կերպ․

````c++
   Vector::Vector(std::initializer_list<double> lst)      // ինիցիալիզացնել ցանկով
            :elem{new double[lst.size()]}, sz{static_cast<int>(lst.size())}
   {
            copy(lst.begin(), lst.end(), elem);            // պատճենել lst֊ից elem֊ի մեջ (§10.6)
   }
````

Ես օգտագործում եմ տգեղ `static_cast`֊ը՝ (§14.2.3) ձևափոխելու համար ինիցիալիզացիոն լիստի չափը `int` տիպի: Սա շատ մանրացրած է, քանի որ հնարավորությունը, որ ձեռքով գրված տարրերի քանակը մեծ կլինի ամենամեծ ամբողջից (32,767 16֊բիթ ամբողջների համար և 2,147,483,647 32-բիթ ամբողջների համար) շատ քիչ հավանական է: Ինչևէ it is worth remembering that the type system has no common sense. Այն գիտի փոփոխականների հնարավոր արժեքների մասին ավելի, քան փաստացի արժեքների մասին, so it might complain where there is no actual violation։ Ինչևէ, վաղ թե ուշ, այդպիսի զգուշացումները կփրկեն ծրագրավորողին վատ սխալներից։

`static_cast` հրամանը չի ստուգում այն արժեքը, որը որ ձևափոխում է; ծրագրավորողը հույս ունի, որ այն ճիշտ է օգտագործում։ Միշտ չէ, որ սա լավ ենթադրություն է, այնպես որ, եթե կասկածում եք, ստուգեք արժեքը։ Տիպի բացահայտ ձևափոխումներից (often called casts to remind you that they are used to prop up something broken) ավելի լավ է հրաժարվել։ Տիպերի համակարգի խելամիտ օգտագործումը և լավ ձևավորված գրադարանները մեզ թույլ են տալիս բացառել չստուգված վարքը բարձր մակարդակի ծրագրերում։

# 4.3 Աբստրակտ տիպեր

`complex`֊ի և `Vector`֊ի նման տիպերը կոչվում են *կոնկրետ տիպեր*, քանի որ նրանց ներկայացումը նրանց սահմանման մի մասն է։ Սրանով նրանք հիշեցնում են ներդրված տիպերը։ Դրան հակառակ, *աբստրակտ տիպը* տիպ է, որն ամբողջությամբ մեկուսացնում է օգտագործողին իրականացման մանրամասնություններից։ Դրան հասնելու համար մենք անջատում ենք ինտերֆեյսը ներկայացումից և տալիս ենք իսկական լոկալ փոփոխականներ։ Քանի որ մենք ոչ մի բան չգիտենք աբստրակտ տիպի ներկայացման մասին (և ոչ նույնիսկ նրա չափը), մենք պետք է տեղադրենք օբյեկտները հիշողության ազատ տարածքում (free store) (§4.2.2) և պետք է դիմենք նրանց հղումների կամ ցուցիչների միջոցով (§1.8, §11.2.1)։

Սկզբում մենք սահմանում ենք `Container` դասի ինտերֆեյսը, որը կձևավորի մեր `Vector` դասի մի քանի աբստրակտ տարբերակներ․

````c++
   class Container {
   public:
            virtual double& operator[](int) = 0;      // մաքուր վիրտուալ ֆունկցիա
            virtual int size() const = 0;                    // const անդամով ֆունկցիա (§4.2.1)
            virtual ~Container() {}                        // դեստրուկտոր (§4.2.2)
   };
```` 

Այս դասը մաքուր ինտերֆեյս է ավելի ուշ սահմանված կոնտեյներներ նշելու համար։ `virtual` բառը նշանակում է, որ «կարող է վերասահմանվել դասի մեջ հետագայում՝ ժառանգելով այս մեկից»։ Զարմանալի չէ, որ `virtual` հայտարարված ֆունկցիան կոչվում է *վիրտուալ ֆունկցիա*։ `Container`֊ից բխած դասը ապահովում է իրականացում `Container`֊ի ինտերֆեյսի համար։ The curious `= 0` սինտաքսիսն ասում է, որ ֆունկցիան *մաքուր վիրտուալ ֆունկցիա է*; սա նշանակում է, որ `Container`֊ից բխած ինչ֊որ դաս *պետք է* սահմանի այդ ֆունկցիան։ Այդ պատճառով, հնարավոր չէ ուղղակի սահմանել  `Container` օբյեկտ; `Container`֊ը կարող է ուղղակի ծառայել որպես ինտերֆեյս այն դասին, որն իրականացնում է իր `operator[]()` և `size()` ֆունկցիաները։ Այն դասը, որն ունի մաքուր վիրտուալ ֆունկցիա, կոչվում է *աբստրակտ դաս*։ 

   Այս `Container`֊ը կարող է օգտագործվել հետևյալ կերպ․

````c++
   void use (Container& c)
   {
         const int sz = c.size();

         for (int i = 0; i != sz; ++i)
               cout << c[i] << '\n';
   }
````

Ուշադրություն դարձրեք, թե ինչպես է `use()`֊ը օգտագործում `Container`֊ի ինտերֆեյսը, ամբողջությամբ անտեսելով իրականացման դետալները։ Այն օգտագործում է `size()`֊ը և`[]`֊ը առանց որևէ գաղափարի, թե նրանց իրականացումը ինչ տիպ է ապահովում։ Այն դասը, որն ապահովում է ինտերֆեյս այլ դասերի բազմության համար, հաճախ կոչվում է *պոլիմորֆիկ տիպ*։ 

   Ինչպես, որ հատուկ է աբստրակտ դասերին, `Container`֊ը չունի կոնստրուկտոր։ Վերջիվերջո, այն չունի որևէ տվյալ արժեքավորելու համար։ Մյուս կողմից `Container`֊ը ունի դեստրուկտոր և այդ դեստրուկտորը `virtual` է։ Կրկին, սա բնորոշ է աբստրակտ դասերին, քանի որ նրանք հակված են փոփոխվելու հղումների և ցուցիչների միջոցով, և որևէ մեկը, ով ջնջում է այն ցուցիչի միջոցով, գաղափար չունի, թե ինչ ռեսուրսներ են ստացվում ? նրա իրականացումով; տես նաև §4.5.

   Այն կոնտեյները, որն իրականացնում է այն ֆունկցիաները, որոնք պահանջվում են `Container` աբստրակտ դասի սահմանված ինտերֆեյսի կողմից, կարող է օգտագործել `Vector` կոնկրետ դասը․

````c++
   class Vector_container : public Container {    // Vector֊կոնտեյները իրականացնում է Container֊ը
         Vector v;
   public: 
            Vector_container (int s) : v(s) {}   // s տարրերի վեկտոր
            ~Vector_container() {}

            double& operator[](int i) {return v[i];}
            int size() const {return v.size();}
   };
````

`public:` բառը կարող է կարդացվել որպես «ժառանգված է» կամ «ենթատեսակ»։ Ասում են, որ `Vector_container` դասը *ժառանգված է* `Container` դասից և `Container` դասը `Vector_container` դասի *բազային* դասն է։ Այլընտրանքային տերմինոլոգիան անվանում է `Vector_container`֊ը և `Container`֊ը *ենթադաս* և *ծնող դաս* համապատասխանաբար։ Ասում են, որ ժառանգված դասը ժառանգում է իր բազային դասի անդամները, այսպիսով բազային և ժառանգված դասերի օգտագործումը սովորաբար կոչվում է *ժառանգում*։ 

`operator[]()` և `size()` անդամներն, ասում են *վերասահմանում են* *(override)* համապատասխան անդամները `Container` բազային դասում։ Դեստրուկտորը (`~Vector_container()`) վերասահմանում է բազային դասի դեստրուկտորը (`Container()`)։ Ուշադրություն դարձրեք, որ դեստրուկտոր անդամը (`~Vector()`) ոչ ակնհայտորեն կանչվում է իր դասի դեստրուկտորի կողմից (`~Vector_container()`)։ 

`use(Container&)`֊ի նման ֆունկցիայի համար, որպեսզի կարողանա օգտագործել `Container`֊ը՝ ամբողջությամբ անտեսելով իրականացման դետալները, որոշ այլ ֆունկցիաներ պետք է ստեղծեն մի օբյեկտ, որի վրա այն կարող է աշխատել։ Օրինակ․

````c++
   void g()
   {
         Vector_container vc {10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0};
         use (vc);
   }
````

Քանի դեռ `use()`֊ը չգիտի `Vector_container`֊ի ինտերֆեյսի մասին, բայց գիտի միայն `Container`֊ի ինտերֆեյսը, այն կաշխատի `Container`-ի մեկ ուրիշ իրականացման համար։ Օրինակ․

````c++
   class List_container : public Container {      // List_container֊ն իրականացնում է Container֊ը
         std::list<double> ld;      //  (ստանդարտ֊գրադարան) իրական թվերի ցուցակ (§9.3)
   public: 
            List_container() {}      // դատարկ ցուցակ
            List_container (initializer_list <double> il) : ld{il} {}
            ~List_container() {}

            double & operator[](int i);
            int size() const {return ld.size();}

   };

   double & List_container::operator[] (int i)
   {
         for (auto & x : ld) {
               if (i == 0) return x;
               --i;
         }
         throw out_of_range ("List container");
   }
````

Այստեղ ներկայացումը ստանդարտ գրադանի `list<double>`_ն է։ Սովորաբար ես չեմ իրականացնի կոնտեյները subscript գործողությամբ, օգտագործելով `list`֊ը, որովհետև `list`֊ի ներկայացումը subscripting is atrocious compared to vector subscripting։ Ինչևէ, այստեղ ես ցանկացա ցույց տալ մի իրականացում, որը հիմնովին տարբերվում է սովորականից։ 

   Ֆունկցիան կարող է ստեղծել `List_container` և ունենալ `use()` այն օգտագործելու համար․

````c++
   void h()
   {
         List_container lc = {1,2,3,4,5,6,7,8,9};
         use (lc);
   }
````

Այստեղ կարևոր կետն այն է, որ `use(Container &)`֊ը գաղափար չունի, թե ով է իր արգումենտը՝ `Vector_container`֊ը, `List_container`֊ը կամ մեկ ուրիշ կոնտեյներ; այն կարիք չունի դա իմանալու։ Այն կարող է օգտագործել ցանկացած տեսակի `Container`: Սա գիտի միայն `Container`֊ի սահմանած ինտերֆեյսը։ Հետևաբար կարիք չկա վերակոմպիլյացիայի ենթարկել`use(Container &)`֊ը, եթե փոխվում է `List_container`_ի իրականացումը կամ `Container`֊ից ստացված բոլորովին նոր դաս է օգտագործվում։

Այս ճկունության շրջված կողմն այն է, որ օբյեկտների հետ պետք է աշխատել ցուցիչների կամ հղումների միջոցով (§4.6, §11.2.1)։


## 4.4 Վիրտուալ ֆունկցիաներ

Եկեք դիտարկենք կրկին `Container` դասի կիրառումը․

````c++
   void use (Container & c)
   {
         const int sz = c.size();

         for (int i = 0; i != sz; ++i)
                  cout << c[i] << '\n';
   }
````

Ինչպե՞ս է `c[i]`֊ի կանչը `use()`֊ում լուծվում ճիշտ `operator[]()`֊ի կողմը։ Երբ `h()`֊ն կանչում է `use()`֊ին, պետք է կանչվի `List_container`֊ի `operator[]()` ֆունկցիա֊անդամը։ Երբ `g()`֊ն կանչում է `use()`֊ին, պետք է կանչվի `Vector_container`֊ի `operator[]()` ֆունկցիա֊անդամը։ Այս լուծմանը հասնելու համար `Container`դասի օբյեկտը պետք է պարունակի ինֆորմացիա, որը թույլ կտա նրան  կատարման ժամանակ ընտրել կանչի համար ճիշտ ֆունկցիան։ The usual implementation technique is for the compiler to convert the name of a virtual function into an index into a table of pointers to functions. Այդ աղյուսակը սովորաբար կոչվում է *վիրտուալ ֆունկցիաների աղյուսակ* կամ պարզապես `vtbl`։ Վիրտուալ ֆունկցիաներով յուրաքանչյուր դաս ունի իր սեփական `vtbl`, որն իդենտիֆիկացնում է նրա վիրտուալ ֆունկցիաները։ Սա գրաֆիկորեն կարելի է ներկայացնել հետևյալ կերպ․

նկար 4.4

`vtbl`֊ի ֆունկցիաները թույլ են տալիս օբյեկտին ունենալ ճիշտ կիրառություն, նույնիսկ եթե օբյեկտի չափը և նրա տվյալների դասավորությունը հայտնի չեն կանչողին։ Կանչողի (caller) իրականացման մեջ պետք է հայտնի լինի միայն `vtbl`֊ի ցուցիչի տեղը `Container`֊ում և յուրաքանչյուր վիրտուալ ֆունկցիայի համար օգտագործվող ինդեքսը։ Այս վիրտուալ կանչի մեխանիզմը կարող է դառնալ այնքան էֆեկտիվ, որքան «նորմալ ֆունկցիայի կանչի» մեխանիզմն է (within 25%)։ Its space overhead is one pointer in each object of a class with virtual functions plus one `vtbl` for each such class.


## 4.5 Դասերի հիերարխիան

`Container` դասի օրինակը դասերի հիերարխիայի շատ պարզ օրինակ է։ *դասերի հիերարխիան* դասերի խումբ է ordered in a lattice created by derivation (e.g., : public )։ Մենք օգտագործում ենք դասերի հիերարխիան, որպեսզի ներկայացնենք աստիճանական կապեր ունեցող հասկացություններ, այսպես օրինակ․ «Հրշեջ մեքենան բեռնատար մեքենայի մի տեսակ է, որն էլ համարվում է փոխադրամիջոցի մի տեսակ» և «Ժպտացող դեմքը շրջանի մի տեսակ է, որն էլ համարվում է պատկերի տեսակներից մեկը»։ Հարյուրավոր դասերով կազմված հսկա հիերարխիաները, որոնք և՛ խորն են և՛ լայն են, շատ կիրառելի են։ Որպես semi-realistic դասական օրինակ, եկեք դիտարկենք պատկերները էկրանի վրա․

նկար 4.5

Սլաքները ցույց են տալիս ժառանգական կապերը։ Օրինակ, `Circle` դասը ստացվել է `Shape` դասից։ Այս պարզ դիագրամը կոդում ներկայացնելու համար, առաջին հերթին պետք է նկարագրենք մի դաս, որը սահմանում է բոլոր պատկերների ընդհանուր հատկությունները․

````c++
   class Shape {
   public:
            virtual Point center() const = 0;      // մաքուր վիրտուալ ֆունկցիա
            virtual void move (Point to) = 0;

            virtual void draw() const = 0;         // draw on current "Canvas"
            virtual void rotate (int angle) = 0; 

            virtual ~Shape() {}                        // դեստրուկտոր
            // ...
   };
````

Բնականաբար, այդ ինտերֆեյսն աբստրակտ դաս է․ as far as representation is concerned, ամեն մի `Shape`֊ի համար *ոչ մի բան* ընդհանուր չէ (բացի ցուցիչի տեղը `vtbl`֊ի վրա)։ Տալով այս սահմանումը, մենք կարող ենք գրել ընդհանուր ֆունկցիաներ, որոնք աշխատում են պատկերների վրա ցույց տվող ցուցիչների վեկտորների հետ․

````c++
   void rotate_all (vector <Shape*>& v, int angle)   // պտտել v֊ի տարրերը angle աստիճանով
   {
         for (auto p : v)
                p -> rotate(angle);
   }
````

Առանձին պատկեր սահմանելու համար, մենք պետք է հաղորդենք, որ այն `Shape` է և նշենք նրա մասնավոր հատկությունները (ներմուծելով նրա վիրտուալ ֆունկցիաները)․

````c++
   class Circle : public Shape {
   public:
            Circle (Point p, int rr);         // կոնստրուկտոր

            Point center() const {return x;}
            void move (Point to) {x = to;}
            void draw() const;
            void rotate(int) {}            // գեղեցիկ պարզ ալգորիթմ
   private:
            Point x;            // կենտրոնը
            int r;                // ռադիուս
   };
````









  















