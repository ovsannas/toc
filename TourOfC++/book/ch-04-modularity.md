# Դասեր

Those types are not "abstract";
they are as real as `int` and `float`.
-Doug Mcllroy


* Ներածություն
* Կոնկրետ տիպեր
      Թվաբանական տիպեր; Կոնտեյներ; Կոնտեյներների ինիցիալիզացիա
* Աբստրակտ տիպեր
* Վիրտուալ ֆունկցիաներ
* Դասերի հիերարխիա
      Ակնհայտ ձևափոխում; Հիերարխիայի առավելությունները; Hierarchy Navigation; Խուսափում ռեսուրսների հոսքից
* Կրկնօրինակում և տեղաշարժում
      Կոնտեյներների կրկնօրինակում; Կոնտեյներների տեղաշարժում; Հիմնական գործողությունները; Ռեսուրսների կառավարում; Suppressing Operations
* Խորհուրդներ


## 4.1 Ներածություն

Այս և հաջորդ գլուխները նպատակ ունեն գաղափար տալ C++ լեզվի աջակցության մասին աբստրակցիայի և ռեսուրսների ղեկավարման համար՝ առանց շատ մանրամասնությունների․
* Այս գլուխը ոչ պաշտոնապես ներկայացնում է նոր տիպերի (*օգտագործողի սահմանած տիպեր*) սահմանման և կիրառման ճանապարհները։ Մասնավորապես այն ներկայացնում է հիմնական հատկությունները, իրականացման տեխնիկան և լեզվական գործիքները, որոնք կիրառվում են *կոնկրետ դասերի*, *աբստրակտ դասերի*, և *դասերի հիերարխիայի* համար։
* Հաջորդ գլուխը ներկայացնում է շաբլոնները՝ որպես պարամետրիզացված տիպերի մեխանիզմ և and algorithms with (other) types and algorithms․ Հաշվարկները օգտագործողի սահմանած տիպերի և ներդրված տիպերի վրա ներկայացված են որպես ֆունկցիաներ, երբեմն որպես *ընդհանրացված ֆունկցիաներ* և *ֆունկցիաների օբյեկտներ*։ 

Սրանք լեզվի այն հնարավորություններն են, որոնք աջակցություն ունեն ծրագրավորման այն ոճերի կողմից, որոնք հայտնի են որպես *օբյկետ֊կողմնորոշված ծրագրավորում* և  *ընդհանրացված ծրագրավորում*։ 6-13 գլուխները հասցնում են ավարտին այս թեման՝ ներկայացնելով օրինակներ ստանդարտ գրադարանի հնարավորություններով և դրանց կիրառումով։

C++ լեզվի կենտրոնական առանձնահատկությունը (գործիքը) *դասն* է։ Դասը օգտագործողի սահմանած տիպ է, որը նախատեսված է ծրագրի կոդում ներկայացնելու որևէ հասկացություն։ Երբ, որ մեր ծրագրի ձևակերպումն ունենում է ինչ֊որ օգտակար կոնցեպցիա, գաղափար, էություն և այլն, մենք փորձում ենք այն ներկայացնել ծրագրի մեջ որպես դաս, այնպես, որ այդ հասկացությունը լինի կոդի մեջ, այլ ոչ թե մեր գլխում, ձևակերպման փաստաթղթի մեջ կամ մի քանի մեկնաբանություններում։ Այն ծրագիրը, որը կառուցված է լավ ընտրված դասերի խմբից, շատ ավելի հեշտ է հասկանալ և ստանալ right than one that builds every thing directly in terms of the built-in types. Մասնավոր դեպքերում դասերը հաճախ նրանք են, ինչ որ առաջարկում են գրադարանները։

Ըստ էության, լեզվի բոլոր գործիքները բացի ֆունդամենտալ տիպերից, օպերա տորներից և արտահայտություններից, նրա համար են, որպեսզի օգնեն սահմանել ավելի լավ դասեր կամ օգտագործեն դրանք ավելի հարմար ձևով։ «Ավելի լավ» ասելով ես նկատի ունեմ ավելի ճիշտ, ավելի հեշտ սպասարկվող, ավելի օգտավետ, ավելի էլեգանտ, ավելի հեշտ օգտագործելու համար, ավելի հեշտ կարդալու համար և ավելի հեշտ քննարկելու համար։ Ծրագրավորման տեխնիկաների մեծ մասը հենվում է առանձնահատուկ նշանակության դասերի ձևավորման և իրականացման վրա։ Ծրագրավորողների պահանջներն ու ճաշակները չափազանց տարբեր են։ Հետևաբար դասերի սատարումն էլ (support) լայն է։ Այստեղ մենք կդիտարկենք հիմնական support երեք կարևոր տեսակի դասերը․

* Կոնկրետ դասեր (§4.2)
* Աբստրակտ դասեր (§4.3)
* Դասեր դասերի հիերարխիաներում (§4.5)

Օգտակար դասերի ապշեցնող քանակը պարզվում է այս երեք տեսակներից որևէ մեկն է։ Դեռ ավելին, դասերը կարող են դիտարկվել որպես այս երեք տեսակների ավելի պարզ տարբերակներ կամ իրականացված են՝ օգտագործելով այդ դասերի համար օգտագործված տեխնիկաների կոմբինացիաները։


## 4.2 Կոնկրետ տիպեր

*Կոնկրետ դասերի* հիմնական գաղափարn այն է, որ նրանք իրենց պահում են "ներդրված տիպերի նման"։ Օրինակ, կոմպլեքս թվի տիպը և infinite-precision ամբողջ տիպը շատ նման են ներդրված `int` տիպին, բացի նրանից, իհարկե, որ նրանք ունեն իրենց սեփական սեմանտիկան և գործողությունների խմբերը։ Նմանապես `vector`֊ը և `string`֊ը շատ նման են ներդրված զանգվածներին, չհաշված, որ նրանք are better behaved։ (§7.2, §8.3, §9.2)։

Կոնկրետ տիպերի որոշիչ բնութագրությունն այն է, որ նրա ներկայացումը նրա սահմանման մի մասն է։ Կարևոր շատ դեպքերում, օրինակ `vector`֊ի դեպքում, այդ ներկայացումը մեկ կամ մի քանի ցուցիչ է՝ ուղղված տվյալների վրա, որոնք գտնվում են մեկ այլ տեղում, բայց այն ներկա է կոնկրետ դասի յուրաքանչյուր օբյեկտում։ Սա թույլ է տալիս, որպեսզի իրականացումներն օպտիմալ էֆեկտիվ լինեն ժամանակի և տեղի մեջ։ Մասնավորապես, այն թույլ է տալիս մեզ

* տեղադրել կոնկրետ տիպերի օբյեկտները ստեկի մեջ, ստատիկ առանձնացված հիշողության մեջ և այլ օբյեկտներում (§1.6);
* դիմել ուղիղ օբյեկտներին (ոչ միայն ցուցիչների կամ հղումների միջոցով);
* ինիցիալիզացնել օբյեկտներն անմիջապես և ամբողջությամբ (օր․ օգտագործելով կոնստրուկտորներ; §2.3); և
* պատճենել օբյեկտները (§4.6)

Ներկայացումը կարող է լինել գաղտնի (այնպես, ինչպես `Vector`֊ի համար է; §2.3) և հասանելի միայն ֆունկցիա֊անդամների միջոցով, բայց այն կա։ Հետևաբար, եթե ներկայացումը փոփոխվում է որևէ էական կերպով, օգտագործողը պետք է recompile. Սա է կոնկրետ տիպեր ունենալու գինը, որոնք ճշտորեն վարվում են ներդրված տիպերի նման։ Այն տիպերը, որոնք հաճախ չեն փոխվում, և որտեղ լոկալ փոփոխականներն ապահովում են շատ անհրաժեշտ պարզություն և էֆեկտիվություն, նրանց համար այս դեպքը ընդունելի է և հաճախ իդեալական։ Ճկունությունը մեծացնելու համար կոնկրետ տիպը իր ներկայացման մեծ մասը կարող է պահել հիշողության ազատ տարածքում (free store) (դինամիկ հիշողություն, heap) և դիմել նրանց այն մասի միջոցով, որը տեղադրված է դասի օբյեկտի մեջ։ Հենց այս ճանապարհով էլ իրականացվել են `vector` և `string` դասերը; they can be considered resource handles with carefully crafted interfaces.

### 4.2.1 Թվաբանական տիպ

«Օգտագործողի կողմից սահմանած ամենադասական թվաբանական տիպը» `complex` տիպն է․

````c++
   class complex {
      double re, im;   // երկու իրական թվերի ներկայացում
   public:
      complex (double r, double i) :re{r}, im{i} {}   // կառուցել կոմպլեքս տիպ երկու սկալյարներից
      complex (double r) :re{r}, im{0} {}   // կառուցել կոմպլեքս տիպ մեկ սկալյարից
      complex () :re{0}, im{0} {}   // լռությամբ կոմպլեքս տիպ։ {0,0}

      double real() const {return re;}
      void real (double d) {re = d;}
      double imag() const {return im;}
      void imag (double d) {im = d;}

      complex& operator += (complex z) {re += z.re, im += z.im; returnn *this;}   // գումարել re֊ին և im֊ին
// և վերադարձնել արդյունքը
      complex& operator -= (complex z) {re -= z.re, im -= z.im; return *this;}

      complex& operator *= (complex);   // 
      complex& operator /= (complex);   //
};
````

Սա ստանդարտ գրադարանի `complex` տիպի թեթևակի պարզեցրած տարբերակն է (§12.4)։ Դասի սահմանումն ինքնին պարունակում է միայն գործողություններ, որոնք պահանջում են մուտք ներկայացման մեջ։ Ներկայացումը պարզ է և պայմանական։ Պրակտիկ պատճառների համար այն պետք է համատեղելի լինի այն բանի հետ, ինչ որ  Ֆորտրանն էր ապահովում 50 տարի առաջ, և մեզ անհրաժեշտ են օպերատորների պայմանական խումբ։ Տրամաբանական պահանջներին գումարած `complex`֊ը պետք է լինի էֆեկտիվ կամ էլ այն կմնա չօգտագործված։ Սա ենթադրում է, որ պարզ գործողությունները պետք է լինեն ներսում։ Սա նշանակում է, որ պարզ գործողությունները (այնպիսիք, ինչպիսիք են օրինակ կոնստրուկտորները, `+=`, և `imag()`) պետք է իրականացված լինեն առանց ֆունկցիաների կանչերի ստեղծված մեքենայական կոդում։ Այն ֆունկցիաները, որոնք սահմանված են դասի մեջ ներկառուցված են լռությամբ։ Հնարավոր է բացահայտորեն պահանջել ներկառուցում՝ ֆունկցիայի հայտարարության առջևից  դնելով `inline` բառը։ An industrial-strength `complex` (ինչպիսին ստանդարտ գրադարանինն է) զգուշորեն իրականացված է կատարելու համար համապատասխան ներկառուցում։

Այն կոնստրուկտորը, որը կարող է կանչվել առանց որևէ արգումենտի կոչվում է *լռությամբ կոնստրուկտոր*։ Այսպիսով, `complex()`֊ը `complex`֊ի լռությամբ կոնստրուկտորն է։ Սահմանելով լռությամբ կոնստրուկտոր դուք վերացնում եք հնարավորությունը ունենալու այդ տիպի ոչ ինիցիալիզացված փոփոխականներ։

`const` նշիչները իրական և երևակայական մասեր վերադարձնող ֆունկցիաների վրա, ցույց են տալիս, որ այդ ֆունկցիաները չեն ձևափոխում այն օբյեկտը, որի համար որ նրանք կանչվել են։

Շատ օգտակար գործողություններ չեն պահանջում ուղիղ դիմում `complex` տիպի ներկայացմանը, այդպիսով նրանք կարող են սահմանվել դասի սահմանումից առանձին․

````c++
   complex operator+(complex a, complex b) {return a += b;}
   complex operator-(complex a, complex b) {return a -= b;}
   complex operator-(complex a) {return {-a.real(), -a.imag()};}      // ունար հանում
   complex operator*(complex a, complex b) {return a *= b;}
   complex operator/(complex a, complex b) {return a /= b;}
````

Այստեղ ես օգտագործում եմ այն փաստը, որ արժեքով փոխանցված արգումենտը պատճենվում է, հետևաբար ես կարող եմ ձևափոխել արգումենտը առանց







 
