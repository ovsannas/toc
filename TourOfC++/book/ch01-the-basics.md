
# Հիմունքներ

Մեր առաջին գործը այն կլինի, որ սպանենք բոլոր օրենսգետներին։

Հենրի VI, Մաս II, Արարված չորրորդ, Տեսարան երկրորդ

* Ներածություն
* Ծրագրեր
* Hello, World!
* Ֆունկցիաներ
* Տիպեր, փոփոխականներ և թվաբանություն
* Տեսանելիության տիրույթ և կյանքի տևողություն
* Հաստատուններ
* Ցուցիչներ, զանգվածներ և հղումներ
* Պայմաններ ստուգում
* Խորհուրդներ

## Ներածություն

Այս գլուխը ոչ խիստ ձևով ներկայացնում է C++ լեզուն, C++-ի հիշողության և հաշվարկման մոդելները, և ծրագրերում կոդի կազմակերպման հիմնական մեխանիզմները։ Դրանք լեզվի այն հնարավորություններն են, որոնք ավելի հաճախ հանդիպում են C լեզվում և այդ ոճը երբեմն կոչվում է _պրոցեդուրային ծրագրավորում_։

## Ծրագրեր

C++-ը կոմպիլյացվող լեզու է։ Գործարկվող ծրագրի սկզբնական տեքստը պետք է մշակվի կոմպիլյատորով, որը ստեղծում է օբյեկտային ֆայլերը, վերջիններս էլ միավորվում են կապակցող ծրագրով և ստեղծվում է կատարվող ծրագիրը։ Սովորաբար C++ լեզվով գրված ծրագիրը բաղկացած է մի քանի սկզբնական ֆայլերից (ավելի հաճախ պարզապես՝ ֆայլեր)։ ?? Կատարվող ծրագիրը ստեղծվում է որոշակի ապարատ-համակարգ զույգի համար․ այն տեղափոխելի չէ, ասենք, Mac-ից Windows-ի։ Երբ խոսում ենք C++ ծրագրերի տեղափոխելիության մասին, սովորաբար նկատի ունենք նախնական տեքստերի տեղափոխելիությունը, այսինքն՝ նախնական տեքստերը կարող են հաջողությամբ կոմպիլյացվել և կատարվել տերբեր համակարգերում։

ISO C++ ստանդարտը սահմանում է էությունների երկու տեսակներ․
* Լեզվի միջուկի հատկություններ, ինչպիսիք են ներդրված տիպերը (օրինակ՝ `char` և `int`) և ցիկլերը (օրինակ՝ `for` և `while` հրամանները)։
* Ստանդարտ գրադարանի բաղադրիչներ, ինչպիսիք են կոնտեյներները (օրինակ՝ `vector` և `map`) և ներմուծման/արտածման գործողությունները (օրինակ՝ `<<` և `getline()`)։



## 1.3 Hello, World!

C++ ֊ ի ամենափոքր ծրագիրն է՝

````c++
int main() {}		// the minimal C++ program
````

Էստեղ սահմանվում է `main` ֆունկցիան, որը ոչ մի արգումենտ չի ստանում և ոչ մի բան չի կատարում։

C++-ում ձևավոր փակագծերը, `{}`, ցույց են տալիս խմբավորում:?? Այստեղ նրանք ցույց են տալիս ֆունկցիայի մարմնի սկիզբն ու վերջը։ Կրկնակի թեք գծերով, `//`, սկսվում է մեկնաբանություն, որը ձգվում է մինչև տողի վերջը։ Մեկնաբանությունը կարդացողի համար է, կոմպիլյատորը դա անտեսում է։ 

C++ -ի ցանկացած ծրագիր պետք է ունենա ճշտորեն (անպայման, հստակ ???) մեկ գլոբալ ֆունկցիա `main()` անունով։ Ծրագիրն սկսվում է այդ ֆունկցիայի կատարումով։ `int` արժեքը, որը վերադարձնում է `main()` ֆունկցիան, եթե այն գոյություն ունի, ծրագրի վերադարձվող արժեքն է «համակարգին»։ Եթե ոչ մի արժեք չի վերադարձվում, համակարգը կստանա արժեք, որը ցույց է տալիս բարեհաջող ավարտ։ Զրոյից տարբեր արժեքը `main`֊ից վերադարձվող ցույց է տալիս ծրագրի սխալ աշխատանք (խափանում)։ Ոչ բոլոր օպերացիոն համակարգերն ու աշխատանքային միջավայրերն են օգտագործում այդ վերադարձվող արժեքը. Linux/Unix-ի վրա հիմնված աշխատանքային միջավայրերը often do, but Windows-based environments rarely do.

Որպես կանոն, ծրագիրն անպայման արտածում է ինչ֊որ բան։ Ներքևում գրված է ծրագիր, որն էկրանին գրում է Hello, World!

````c++
#include <iostream>
int main()
{
std::cout<<"Hello, World!\n";
}
````

`#include <iostream>` տողը կոմպիլյատորին հրահանգում է ներառել ստանդարտ ներմուծման/արտածման միջոցների սահմանումները `iostream` ֆայլից։ Առանց այդ սահմանումների

````c++
std::cout<<"Hello, World!\n"
````

արտահայտությունը իմաստ չի ունենա (չի կատարվի)։ `<<` (տեղադրել) օպերատորը գրում է իր երկրորդ արգումենտը առաջինի մեջ։ Հետևաբար `"Hello World!\n"` տողը գրվում է `std::cout` ստանդարտ արտածման հոսքի մեջ։ Տողը սիմվոլների հաջորդականություն է՝ շրջապատված կրկնակի չակերտներով։ Տողի մեջ թարս թեք գիծը `\` իրենից հետո մեկ այլ սիմվոլի հետ միասին նշանակում է «հատուկ սիմվոլ»։ Այս դեպքում `\n`֊ը նոր տողի սիմվոլն է, այնպես որ `Hello, World!` գրված սիմվոլներից հետո հետեևում է նոր տող։

`std`֊ն նշում է (հատկորոշում է), որ `cout` անունը գտնվում է ստանդարտ գրադարանի անվանատարածքում (3.3)։ Ես սովորաբար բաց եմ թողնում `std::`֊ն՝ ստանդարտ հնարավորությունները քննարկելիս․ 3.3֊ը ցույց է տալիս, թե ինչպես անվանատարածքի անունները դարձնել տեսանելի առանց բացահայտ նշելու։

Իրականում ամբողջ գործարկվող (կատարվող,աշխատող) կոդը տեղադրվում է ֆունկցիաների մեջ և ուղղակիորեն կամ անուղղակիորեն կանչվում `main()`֊ից։ Օրինակ․

````c++
#include <iostream>	//ներառել ("ներմուծել") Ն/Ա գրադարանի սահմանումները

using namespace std;	//`std` անվանատիրույթի անունները դարձնում է տեսանելի առանց `std::`֊ի (?3.3)

double square(double x)	//square a double precision floating-point number
{
return x*x;
}

void print_square(double x)
{
cout<<"the square of"<<x<<"is"<<square(x)<<"\n";
}

int main()
{
print_square(1.234); 	//print: the square of 1.234 is 1.52276
}
````

`void` վերադարձվող արժեքը ցույց է տալիս, որ ֆունկցիան արժեք չի վերադարձնում։


##1.4 Ֆունկցիաներ

C++ ծրագրում հիմնական ճանապարհը խնդիր լուծելու ֆունկցիայի կանչն է այդ խնդրի լուծման համար։ Հայտարարելով ֆունկցիա մենք գրում ենք խնդրի լուծման ընթացքը, գործողությունների հաջորդականությունը: Մենք չենք կարող կանչել ֆունկցիան, եթե նախօրոք այն չենք հայտարարել։ 

Ֆունկցիայի հայտարարման մեջ տրվում է ֆունկցիայի անունը, վերադարձվող արժեքի տիպը (եթե գոյություն ունի) և արգումենտների քանակն ու տիպերը, որոնք պետք է առաջարկվեն կանչի ժամանակ։ Օրինակ․

````c++
Elem* next_elem();	//արգումենտներ չկան; վերադարձնում է ցուցիչ Elem֊ի վրա (Elem*)
void exit(int);		//ստանում է int տիպի արգումենտ; ոչինչ չի վերադարձնում
double sqrt(double);	//ստանում է double տիպի արժեք; վերադարձնում է double
````

Ֆունկցիայի հայտարարության մեջ վերադարձվող արժեքի տիպը գրվում է ֆունկցիայի անունից առաջ, իսկ արգումենտների տիպերը՝ ֆունկցիայի անվանումից հետո փակագծերի մեջ։
 
The semantics of argument passing are identical to the semantics of copy initialization. That is, argument types are checked and implicit argument type conversion takes place when necessary(?1.5). Օրինակ․

````c++
double s2 = sqrt(2);	//կանչվում է sqrt() ֆունկցիան double{2} արգումենտով
double s3 = sqrt("three");	//սխալ․ sqrt() ֆունկցիան պահանջում է double տիպի արգումենտ
````

The value of such compile-time checking and type conversion should not be underestimated.

Ֆունկցիայի հայտարարության մեջ կարող են լինել արգումենտների անունները։ Դա կարող է լինել օգնություն ծրագիրը կարդացողին, բայց քանի դեռ չի գրվել ֆունկցայի սահմանումը, կոմպիլյատորը ուղղակի անտեսում է արգումենտների անունները։ Օրինակ․

````c++
double sqrt(double d);	//վերադարձնում է d֊ի քառակուսի արմատը
double square(double);	//վերադարձնում է արգումենտի քառակուսի արմատը
````

Ֆունկցիայի տիպը բաղկացած է վերադարձվող արժեքի տիպից և արգումենտների տիպերից։ Դասի անդամ ֆունկցիաների համար դասի անունը նույնպես ֆունկցիայի տիպի մի մասն է (§2.3,§4.2.1)։ Օրինակ․

````c++
double get(const vector<double>& vec, int index);	//տիպը՝ double(const vector<double>&,int)
char& String::operator[](int index); 		//տիպը՝ char& String::(int)
````

Մենք ցանկանում ենք, որպեսզի մեր կոդը լինի հասկանալի գրված, քանի որ դա առաջին քայլն է maintainability. Ծրագիրը հասկանալի դարձնելու առաջին քայլը հաշվարկային խնդիրները փոքր, հասկանալի մասերի բաժանելն է (դասերի և ֆունկցիաների տեսքով) և դրանք անվանելը։ Այդպիսի ֆունկցիաները ապահովում են հաշվարկների հիմնական բառարանը, ինչպես օրինակ տիպերը (ներդրված և օգտատերի կողմից սահմանված) ապահովում են տվյալների հիմնական բառարանը։ C++ լեզվի ստանդարտ ալգորիթմները (օր․ find, sort և iota) ապահովում են լավ սկիզբ (գլուխ 10)։ Դրանց հիման վրա մենք կարող ենք գրել ֆունկցիաներ, որոնք լուծում են ընթացիկ կամ հատուկ խնդիրներ ավելի մեծ հաշվարկների համար։

The number of errors in code correlates strongly with the amount of code and the complexity of
the code. Both problems can be addressed by using more and shorter functions.Ֆունկցիայի օգտագործումը հատուկ խնդիր լուծելու համար, հաճախ մեզ փրկում է ծրագրի մեջտեղում մեկ այլ հատուկ կոդ գրելուց;making it a function forces us to name the activity and document its dependencies.

Եթե երկու ֆունկցիա սահմանված են միևնույն անունով, բայց տարբեր տիպի արգումենտներով, այդ դեպքում կոմպիլյատորը յուրաքանչյուր կանչի համար կընտրի համապատասխանը։ Օրինակ․

````c++
void print(int);	//ստանում է որպես արգումենտ ամբողջ թիվ
void print(double);	//ստանում է սահող ստորակետով թիվ
void print(string);	//ստանում է որպես արգումենտ տող

void user()
{
print(42);			//կանչվում է print(int) ֆունկցիան
print(9.65);			//կանչվում է print(double) ֆունկցիան
print("D is for Digital");	//կանչվում է print(string)
}
````

Եթե երկու ալտերնատիվ ֆունկցիա կանչվում են, և նրանցից ոչ մեկը ավելի նախընտրելի չէ մյուսից, կանչը համարվում է ոչ միանշանակ (անորոշ), և կոմպիլյատորը հայտնում է սխալի մասին։ Օրինակ․

````c++
void print(int,double);
void print(double,int);

void user2()
{
print(0,0);	//սխալ․անորոշ է
}
````

Սա կոչվում է ֆունկցիայի գերբեռնվածություն (գերբեռնում) և ընդհանուր ծրագրավորման մեջ էական մաս է կազմում (§5.4)։ Գերբեռնված ֆունկցիայի ժամանակ, միևնույն անունով յուրաքանչյուր ֆունկցիա պետք է ունենա միևնույն սեմանտիկան (իմաստը)։ Դրա օրինակն են Print() ֆունցիաները․ յուրաքանչյուր print() տպում է իր արգումենտը։


##1.5 Տիպեր, փոփոխականներ և թվաբանություն







