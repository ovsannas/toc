
# Հիմունքներ

Մեր առաջին գործը այն կլինի, որ սպանենք բոլոր օրենսգետներին։

Հենրի VI, Մաս II, Արարված չորրորդ, Տեսարան երկրորդ

* Ներածություն
* Ծրագրեր
* Hello, World!
* Ֆունկցիաներ
* Տիպեր, փոփոխականներ և թվաբանություն
* Տեսանելիության տիրույթ և կյանքի տևողություն
* Հաստատուններ
* Ցուցիչներ, զանգվածներ և հղումներ
* Պայմաններ ստուգում
* Խորհուրդներ

## Ներածություն

Այս գլուխը ոչ խիստ ձևով ներկայացնում է C++ լեզուն, C++-ի հիշողության և հաշվարկման մոդելները, և ծրագրերում կոդի կազմակերպման հիմնական մեխանիզմները։ Դրանք լեզվի այն հնարավորություններն են, որոնք ավելի հաճախ հանդիպում են C լեզվում և այդ ոճը երբեմն կոչվում է _պրոցեդուրային ծրագրավորում_։

## Ծրագրեր

C++-ը կոմպիլյացվող լեզու է։ Գործարկվող ծրագրի սկզբնական տեքստը պետք է մշակվի կոմպիլյատորով, որը ստեղծում է օբյեկտային ֆայլերը, վերջիններս էլ միավորվում են կապակցող ծրագրով և ստեղծվում է կատարվող ծրագիրը։ Սովորաբար C++ լեզվով գրված ծրագիրը բաղկացած է մի քանի սկզբնական ֆայլերից (ավելի հաճախ պարզապես՝ ֆայլեր)։ ?? Կատարվող ծրագիրը ստեղծվում է որոշակի ապարատ-համակարգ զույգի համար․ այն տեղափոխելի չէ, ասենք, Mac-ից Windows-ի։ Երբ խոսում ենք C++ ծրագրերի տեղափոխելիության մասին, սովորաբար նկատի ունենք նախնական տեքստերի տեղափոխելիությունը, այսինքն՝ նախնական տեքստերը կարող են հաջողությամբ կոմպիլյացվել և կատարվել տերբեր համակարգերում։

ISO C++ ստանդարտը սահմանում է էությունների երկու տեսակներ․
* Լեզվի միջուկի հատկություններ, ինչպիսիք են ներդրված տիպերը (օրինակ՝ `char` և `int`) և ցիկլերը (օրինակ՝ `for` և `while` հրամանները)։
* Ստանդարտ գրադարանի բաղադրիչներ, ինչպիսիք են կոնտեյներները (օրինակ՝ `vector` և `map`) և ներմուծման/արտածման գործողությունները (օրինակ՝ `<<` և `getline()`)։



## 1.3 Hello, World!

C++ ֊ ի ամենափոքր ծրագիրն է՝

````c++
int main() {}		// the minimal C++ program
````

Էստեղ սահմանվում է `main` ֆունկցիան, որը ոչ մի արգումենտ չի ստանում և ոչ մի բան չի կատարում։

C++-ում ձևավոր փակագծերը, `{}`, ցույց են տալիս խմբավորում:?? Այստեղ նրանք ցույց են տալիս ֆունկցիայի մարմնի սկիզբն ու վերջը։ Կրկնակի թեք գծերով, `//`, սկսվում է մեկնաբանություն, որը ձգվում է մինչև տողի վերջը։ Մեկնաբանությունը կարդացողի համար է, կոմպիլյատորը դա անտեսում է։ 

C++ -ի ցանկացած ծրագիր պետք է ունենա ճշտորեն (անպայման, հստակ ???) մեկ գլոբալ ֆունկցիա `main()` անունով։ Ծրագիրն սկսվում է այդ ֆունկցիայի կատարումով։ `int` արժեքը, որը վերադարձնում է `main()` ֆունկցիան, եթե այն գոյություն ունի, ծրագրի վերադարձվող արժեքն է «համակարգին»։ Եթե ոչ մի արժեք չի վերադարձվում, համակարգը կստանա արժեք, որը ցույց է տալիս բարեհաջող ավարտ։ Զրոյից տարբեր արժեքը `main`֊ից վերադարձվող ցույց է տալիս ծրագրի սխալ աշխատանք (խափանում)։ Ոչ բոլոր օպերացիոն համակարգերն ու աշխատանքային միջավայրերն են օգտագործում այդ վերադարձվող արժեքը. Linux/Unix-ի վրա հիմնված աշխատանքային միջավայրերը often do, but Windows-based environments rarely do.

Որպես կանոն, ծրագիրն անպայման արտածում է ինչ֊որ բան։ Ներքևում գրված է ծրագիր, որն էկրանին գրում է Hello, World!

````c++
#include <iostream>
int main()
{
std::cout<<"Hello, World!\n";
}
````

`#include <iostream>` տողը կոմպիլյատորին հրահանգում է ներառել ստանդարտ ներմուծման/արտածման միջոցների սահմանումները `iostream` ֆայլից։ Առանց այդ սահմանումների

````c++
std::cout<<"Hello, World!\n"
````

արտահայտությունը իմաստ չի ունենա (չի կատարվի)։ `<<` (տեղադրել) օպերատորը գրում է իր երկրորդ արգումենտը առաջինի մեջ։ Հետևաբար `"Hello World!\n"` տողը գրվում է `std::cout` ստանդարտ արտածման հոսքի մեջ։ Տողը սիմվոլների հաջորդականություն է՝ շրջապատված կրկնակի չակերտներով։ Տողի մեջ թարս թեք գիծը `\` իրենից հետո մեկ այլ սիմվոլի հետ միասին նշանակում է «հատուկ սիմվոլ»։ Այս դեպքում `\n`֊ը նոր տողի սիմվոլն է, այնպես որ `Hello, World!` գրված սիմվոլներից հետո հետեևում է նոր տող։

`std`֊ն նշում է (հատկորոշում է), որ `cout` անունը գտնվում է ստանդարտ գրադարանի անվանատարածքում (3.3)։ Ես սովորաբար բաց եմ թողնում `std::`֊ն՝ ստանդարտ հնարավորությունները քննարկելիս․ 3.3֊ը ցույց է տալիս, թե ինչպես անվանատարածքի անունները դարձնել տեսանելի առանց բացահայտ նշելու։

Իրականում ամբողջ գործարկվող (կատարվող,աշխատող) կոդը տեղադրվում է ֆունկցիաների մեջ և ուղղակիորեն կամ անուղղակիորեն կանչվում `main()`֊ից։ Օրինակ․

````c++
#include <iostream>	//ներառել ("ներմուծել") Ն/Ա գրադարանի սահմանումները

using namespace std;	//`std` անվանատիրույթի անունները դարձնում է տեսանելի առանց `std::`֊ի (?3.3)

double square(double x)	//square a double precision floating-point number
{
return x*x;
}

void print_square(double x)
{
cout<<"the square of"<<x<<"is"<<square(x)<<"\n";
}

int main()
{
print_square(1.234); 	//print: the square of 1.234 is 1.52276
}
````

`void` վերադարձվող արժեքը ցույց է տալիս, որ ֆունկցիան արժեք չի վերադարձնում։


##1.4 Ֆունկցիաներ

C++ ծրագրում հիմնական ճանապարհը խնդիր լուծելու ֆունկցիայի կանչն է այդ խնդրի լուծման համար։ Հայտարարելով ֆունկցիա մենք գրում ենք խնդրի լուծման ընթացքը, գործողությունների հաջորդականությունը: Մենք չենք կարող կանչել ֆունկցիան, եթե նախօրոք այն չենք հայտարարել։ 

Ֆունկցիայի հայտարարման մեջ տրվում է ֆունկցիայի անունը, վերադարձվող արժեքի տիպը (եթե գոյություն ունի) և արգումենտների քանակն ու տիպերը, որոնք պետք է առաջարկվեն կանչի ժամանակ։ Օրինակ․

````c++
Elem* next_elem();	//արգումենտներ չկան; վերադարձնում է ցուցիչ Elem֊ի վրա (Elem*)
void exit(int);		//ստանում է int տիպի արգումենտ; ոչինչ չի վերադարձնում
double sqrt(double);	//ստանում է double տիպի արժեք; վերադարձնում է double
````

Ֆունկցիայի հայտարարության մեջ վերադարձվող արժեքի տիպը գրվում է ֆունկցիայի անունից առաջ, իսկ արգումենտների տիպերը՝ ֆունկցիայի անվանումից հետո փակագծերի մեջ։
 
The semantics of argument passing are identical to the semantics of copy initialization. That is, argument types are checked and implicit argument type conversion takes place when necessary(?1.5). Օրինակ․

````c++
double s2 = sqrt(2);	//կանչվում է sqrt() ֆունկցիան double{2} արգումենտով
double s3 = sqrt("three");	//սխալ․ sqrt() ֆունկցիան պահանջում է double տիպի արգումենտ
````

The value of such compile-time checking and type conversion should not be underestimated.

Ֆունկցիայի հայտարարության մեջ կարող են լինել արգումենտների անունները։ Դա կարող է լինել օգնություն ծրագիրը կարդացողին, բայց քանի դեռ չի գրվել ֆունկցայի սահմանումը, կոմպիլյատորը ուղղակի անտեսում է արգումենտների անունները։ Օրինակ․

````c++
double sqrt(double d);	//վերադարձնում է d֊ի քառակուսի արմատը
double square(double);	//վերադարձնում է արգումենտի քառակուսի արմատը
````

Ֆունկցիայի տիպը բաղկացած է վերադարձվող արժեքի տիպից և արգումենտների տիպերից։ Դասի անդամ ֆունկցիաների համար դասի անունը նույնպես ֆունկցիայի տիպի մի մասն է (§2.3,§4.2.1)։ Օրինակ․

````c++
double get(const vector<double>& vec, int index);	//տիպը՝ double(const vector<double>&,int)
char& String::operator[](int index); 		//տիպը՝ char& String::(int)
````

Մենք ցանկանում ենք, որպեսզի մեր կոդը լինի հասկանալի գրված, քանի որ դա առաջին քայլն է maintainability. Ծրագիրը հասկանալի դարձնելու առաջին քայլը հաշվարկային խնդիրները փոքր, հասկանալի մասերի բաժանելն է (դասերի և ֆունկցիաների տեսքով) և դրանք անվանելը։ Այդպիսի ֆունկցիաները ապահովում են հաշվարկների հիմնական բառարանը, ինչպես օրինակ տիպերը (ներդրված և օգտատերի կողմից սահմանված) ապահովում են տվյալների հիմնական բառարանը։ C++ լեզվի ստանդարտ ալգորիթմները (օր․ find, sort և iota) ապահովում են լավ սկիզբ (գլուխ 10)։ Դրանց հիման վրա մենք կարող ենք գրել ֆունկցիաներ, որոնք լուծում են ընթացիկ կամ հատուկ խնդիրներ ավելի մեծ հաշվարկների համար։

The number of errors in code correlates strongly with the amount of code and the complexity of
the code. Both problems can be addressed by using more and shorter functions.Ֆունկցիայի օգտագործումը հատուկ խնդիր լուծելու համար, հաճախ մեզ փրկում է ծրագրի մեջտեղում մեկ այլ հատուկ կոդ գրելուց;making it a function forces us to name the activity and document its dependencies.

Եթե երկու ֆունկցիա սահմանված են միևնույն անունով, բայց տարբեր տիպի արգումենտներով, այդ դեպքում կոմպիլյատորը յուրաքանչյուր կանչի համար կընտրի համապատասխանը։ Օրինակ․

````c++
void print(int);	//ստանում է որպես արգումենտ ամբողջ թիվ
void print(double);	//ստանում է սահող ստորակետով թիվ
void print(string);	//ստանում է որպես արգումենտ տող

void user()
{
print(42);			//կանչվում է print(int) ֆունկցիան
print(9.65);			//կանչվում է print(double) ֆունկցիան
print("D is for Digital");	//կանչվում է print(string)
}
````

Եթե երկու ալտերնատիվ ֆունկցիա կանչվում են, և նրանցից ոչ մեկը ավելի նախընտրելի չէ մյուսից, կանչը համարվում է ոչ միանշանակ (անորոշ), և կոմպիլյատորը հայտնում է սխալի մասին։ Օրինակ․

````c++
void print(int,double);
void print(double,int);

void user2()
{
print(0,0);	//սխալ․անորոշ է
}
````

Սա կոչվում է ֆունկցիայի գերբեռնվածություն (գերբեռնում) և ընդհանուր ծրագրավորման մեջ էական մաս է կազմում (§5.4)։ Գերբեռնված ֆունկցիայի ժամանակ, միևնույն անունով յուրաքանչյուր ֆունկցիա պետք է ունենա միևնույն սեմանտիկան (իմաստը)։ Դրա օրինակն են Print() ֆունցիաները․ յուրաքանչյուր print() տպում է իր արգումենտը։


##1.5 Տիպեր, փոփոխականներ և թվաբանություն

C++֊ում յուրաքանչյուր անուն և արտահայտություն ունի տիպ, ըստ որի, որոշվում են նաև նրանց հետ կատարվող գործողությունները։ Օրինակ 

````c++
int inch;
````

հայտարարությունը նշում է, որ `inch`֊ը `int` տիպի է, այսինքն `inch`֊ը ամբողջ փոփոխական է։

*Հայտարարությունը* գրառում է (հաղորդագրություն է), որը ներկայացնում է ծրագրին փոփոխականի անունը։ Այն նշում է անվանված օբյեկտի տիպը․

* *Տիպը* սահմանում է (որոշում է) հնարավոր արժեքների և գործողությունների բազմությունը (ցանկացած օբյեկտի համար)։
* *Օբյեկտը* հիշողության մի մաս է, որը պարունակում է որևէ տիպի արժեք։
* *Արժեքը* բիթերի խումբ է՝ թարգմանված տիպին համապատասխան։
* *Փոփոխականը* անվանված օբեկտն է (այն օբյեկտն է, որն ունի անուն)։

C++ լեզուն առաջարկում է հիմնական տիպերի տեսակներ։ Օրինակ․

````c++
bool		//բուլյան (տրամաբանական), հնարավոր արժեքներն են ճիշտ և սխալ
char		//սիմվոլ, տառ, օրինակ 'a', 'z', և '9'
int		//ամբողջ թիվ, օրինակ -273, 42 և 1066
double		//կրկնակի ճշտությամբ սահող ստորակետով թիվ, օրինակ -273.15, 3.14 և 299793.0
unsigned	//դրական ամբողջ թիվ, օրինակ 0,1 և 999
````

Յուրաքանչյուր հիմնական տիպ համաձայնեցվում է ապարատային սարքավորումների հնարավորությունների հետ և ունի ֆիքսված չափ: Այդ չափն էլ որոշում է այն արժեքների դիապազոնը, որոնք կարող է ընդունել տիպը։
նկար 1.5.1

`char` տիպի փոփոխականը, այն բնական չափի է, որ կարողանա պահել մեկ սիմվոլ տվյալ մեքենայի մեջ (որպես կանոն 8 բիթ), իսկ մյուս տիպերի չափերը հաշվում են `char`֊ի չափի բազմապատիկներով։ Տիպի չափը կախված է մեքենայական իրականացումից (այսինքն տարբեր մեքենաներում կարող է տարբեր լինել), այն կարող ենք ստանալ `sizeof` օպերատորի միջոցով; օրինակ `sizeof(char)`֊ը հավասար է 1 և `sizeof(int)`֊ը հաճախ 4 է։

Թվաբանական գործողությունները կարող են օգտագործվել հետևյալ համապատասխան կոմբինացիաներում․

````c++
x+y	//գումարում
+x	//ունար գումարում
x-y	//հանում
-x	//ունար հանում
x*y	//բազմապատկում
x/t	//բաժանում
x%y	//ամբողջ թվերի բաժանումից ստացված մնացորդը
````

Նույն ձևով կարող են օգտագործվել նաև համեմատական գործողությունները․

````c++
x==y	//հավասար է
x!=y	//հավասար չէ
x<y	//փոքր է
x>y	//մեծ է
x<=y	//փոքր է կամ հավասար
x>=y	//մեծ է կամ հավասար
````

Դեռ ավելին, կան նաև տրամաբանական գործողություններ․

````c++
x&y	//բիթային և
x|y	//բիթային կամ
x^y	//բիթային բացառող կամ
~x	//բիթային լրացում
x&&y	//տրամաբանական և
x||y	//տրամաբանական կամ
````

Բիթային տրամաբանական գործողությունըA bitwise logical operator yield a result of their operand type for which the operation has been performed on each bit.&& և || տրամաբանական գործողությունները վերադարձնում են `true` կամ `false`՝ կախված իրենց օպերանդների արժեքներից։

Վերագրման և թվաբանական գործողությունների մեջ C++ լեզուն կատարում է (ներկայացնում է) բոլոր իմաստ ունեցող (հնարավոր) ձևափոխումները հիմնական տիպերի միջև այնպես, որ նրանք հնարավոր լինի ազատորեն միացնել․

````c++
void some_function()	//սահմանել ենք ֆունկցիա, որը ոչի մի արժեք չի վերադարձնում
{
double d=2.2;		//սահող ստորակետով թվին տվել ենք սկզբնական արժեք
int i=7;		//տվել ենք սկզբնական արժեք ամբողջ թվին
d = d+i;		//երկու թվերի գումարը վերագրում ենք d֊ին
i = d*i;		//երկու թվերի արտադրյալը վերագրում ենք i֊ին (կրճատում ենք d*i double արժեքը մինչև int)
}
````

Այն ձևափոխումները, որոնք օգտագործվում են արտահայտությունների մեջ կոչվում են *սովորական (գործածական) թվաբանական ձևափոխումներ* և երաշխավորում են, որ արտահայտությունները հաշվարկվում են իրենց օպերանդների բարձր ճշտությամբ։ Օրինակ `double` և `int` թվերի գումարումը կատարվում է՝ օգտագործելով կրկնակի ճշտությամբ սահող ստորակետով թվերի թվաբանությունը։

Նշենք, որ `=`֊ը վերագրման գործողությունն է, իսկ `==`֊ը ցույց է տալիս հավասարություն։

C++ լեզվում կա սկզբնական արժեքների գրառման մի քանի ձև․ մի ձևը `=` նշանի միջոցով է, որն օգտագործվել է վերևում և կա համընդհանուր ձև, երբ ձևավոր փակագծերի մեջ տալիս ենք սկզբնական արժեքների ցանկ, որոնք իրարից բաժանվում են ստորակետով, կամ ինչ որ բաժանիչով։ 

````c++
double d1 = 2.3;		//d1֊ին տրվում է 2.3 սկզբնական արժեքը
double d2 {2.3};		//d2-ին տրվում է 2.3 սկզբնական արժեքը
comples<double> z = 1;		//կոմպլեքս թիվ ներկայացված կրկնակի ճշտությամբ սահող ստորակետով թվի սկալյարնեով
complex<double> z2 {d1,d2};
complex<double> z3 = {1,2};	//=֊ը լրացուցիչ է {}֊ի հետ

vector<int> v{1,2,3,4,5,6};	//int֊երի վեկտոր
````

Վերագրման ձևը՝ `=`,ավելի տրադիցիոն է, եկել է C-ից, եթե կասկածում եք որը ընտրել, ընտրեք ձևավոր փակագծերը՝ `{}`։ Եթե ոչ մի տարբերություն էլ չլինի, այն կփրկի ձեզ այն ձևափոխություններից, որոնք կորցնում են ինֆորմացիայի մի մասը։ Օր․

````c++
int i1 = 7.2;		//i1-ը ստանում է 7 արժեքը
int i2{7.2};		//տալիս է սխալ՝ սահող ստորակետով թիվը ամբողջ թվի ձևափոխելուց
int i3 = {7.2};		//տալիս է սխալ՝ սահող ստորակետով թիվը ամբողջ թվի ձևափոխելուց (= նշանն էստեղ երկրորդական է)
````

Դժբախտաբար, ինֆորմացիան կորցնող ձևափոխումները, այսպես կոչված *նեղացող ձևափոխումները*, ինչպիսիք են օրինակ `double`֊ից `int`, `int`֊ից `char`, լեզվում թույլատրվում են և անուղղակի կերպով կատարվում են։ The problems caused by implicit narrowing conversions is a price paid for C compatibility (§14.3).

Հաստատունը (§1.7) չի կարող լինելA constant (§1.7) cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances. Պետք չէ ներկայացնել որևէ անուն, եթե չունեք համապատասխան արժեք նրա համար։ Օգտագործողի կողմից ստեղծված տիպերը (ինչպիսիք են օրինակ string, vector, Matrix, Motor_controller և Orc_warrior) կարող են սահմանվել, որպեսզի անուղղակի կերպով ստանան սկզբնական արժեքներ (§4.2.1)։

Երբ հայտարարում ենք որևէ փոփոխական և կարիքը չկա հստակ հաղորդել նրա տիպը when it can be deduced from the initializer:

````c++
auto b = true;		//a bool
auto ch = 'x';		//a char
auto i = 123; 		// an int
auto d = 1.2;		//a double
auto z = sqrt(y);	//z has the type of whatever sqrt(y) returns
````

`auto` բառի հետ օգտագործում ենք `=` նշանը With auto , we use the = because there is no potentially troublesome type conversion involved.

`auto` բառն օգտագործվում է այն դեպքում, երբ հատուկ պատճառ չկա բացահայտորեն նշելու փոփոխականի տիպը։ Հատուկ պատճառ կարող է համարվել այն, որ

*  սահմանումը, որտեղ նշում ենք տիպը, որպեսզի այն պարզ և տեսանելի լինի կարդացողին, զբաղեցնում է մեր կոդի մեծ տարածք։
* ցանկանում ենք, որ պարզ լինի փոփոխականի շրջակայքը կամ ճշտությունը (օր․ `double` թե՞ `float`)։

Օգտագործելով `auto` բառը, շատ անգամ խուսափում ենք ավելորդություններից և տիպերի երկար անուններ գրելուց։ Սա հատկապես կարևոր է ընդհանրացված ծրագրավորման մեջ, որտեղ օբյեկտի հստակ տիպը ծրագրավորողը կարող է չիմանալ և նաև տիպերի անունները կարող են շատ երկար լինել (§10.2)։

Բացի հիմնական (սովորական) թվաբանությունից և տրամաբանական օպերատորներից C++ լեզուն առաջարկում է ևս մի քանի օպերատոր՝ փոփոխականների հետ փոփոխություններ կատարելու համար (նպատակով).

````c++
x+=y	//x = x+y
++x	//ավելացում․ x = x+1
x-=y	//x = x-y
--x	//նվազում․ x = x-1
x*=y	//x=x*y 
x/=y	//x=x/y
x%=y	//x=x%y
````

Այս օպերատորները հակիրճ են, ընդունված և շատ հաճախ են օգտագործվում։


##1.6 Տեսանելիության տիրույթ և ժամկետ (կյանքի տևողություն)

Հայտարարության մեջ անունը ունի տեսանելիության տիրույթ․

* _Լոկալ տեսանելիության տիրույթ_․  ֆունկցիայում (§1.4) կամ lambda֊ում (§5.5) հայտարարված անունը կոչվում է _լոկալ անուն_։ Նրա տեսանելիության տիրույթը ձգվում է նրա հայտարարության տողից մինչև այն բլոկի վերջը, որտեղ այդ հայտարարությունը գործում է։ _Բլոկը_ ընկած է մեկ զույգ ձևավոր փակագծերի միջև՝ `{}`։ Ֆունկցիայի արգումենտների անունները համարվում են լոկալ անուններ։
* _Դասի տեսանելիության տիրույթ_․ այս անունը կոչվում է  _անդամի անուն_ (կամ _դասի անդամի անուն_), եթե այն սահմանվել է դասի մեջ (§2.2, §2.3, գլուխ 4) կամ `enum class` (§2.5): Նրա տեսանելիության տիրույթը ձգվում է հենց իր հայտարարության բացող փակագծով՝ `{` մինչև այդ հայտարարության վերջը։
* _Անվանատարածքի տեսանելիության տիրույթ_․ հայտարարված անունը կոչվում է _անվանատարածքի անդամի անուն_, եթե այն սահմանվել է անունների տիրությում (§3.3)՝ ցանկացած ֆունկցիայից, lambda֊ից (§5.5), դասից (§2.2, §2.3, գլուխ 4) կամ `enum class`֊ից դուրս (§2.5)։ Նրա տեսանելիության տիրույթը ձգվում է նրա հայտարարության կետից մինչև այդ անվանատարածքի վերջը։ 

Ցանկացած կառուցվածքից դուրս հայտարարված անունը կոչվում է _գլոբալ անուն_, և ասում ենք, որ այն գտնվում է _անունների գլոբալ տիրույթում_։

Որպես լրացում ասենք, որ կարող ենք ունենալ առանց անունների օբյեկտներ, որոնք ժամանակավոր են և `new` օպերատորով ստեղծված օբյեկտներ (§4.2.2): Օրինակ․

````c++
vector<int> vec;	//vec-ը գլոբալ անուն է (ամբողջ թվերի գլոբալ վեկտոր)
struct Record {
string name;		//name-ը անդամ է (string-ի անդամ է)
//...
};

void fct(int arg)	//fct-ն գլոբալ անուն է (գլոբալ ֆունկցիա)
			//arg֊ը լոկալ անուն է (ամբողջ տիպի արգումենտ)
{
string motto {"Who dares win"};	//motto֊ն լոկալ անուն է
auto p = new Record{"Hume"}; 	//p֊ն ցույց է տալիս առանց անվան Record֊ի վրա (որն ստեղծվել է new֊ով)
}
````

Օբյեկտը պետք է կառուցվի (այսինքն ստանա սկզբնական արժեքներ) մինչև իր օգտագործվելը և պետք է դադարի գործելուց իր տեսանելիության տիրույթի վերջում։ Անվանատարածքի օբյեկտի համար խափանման կետը ծրագրի վերջն է։ Անդամի համար խափանման կետը այն օբյեկտի խափանման կետն է, որի անդամն է մեր հայտարարած անունը։ `new`֊ով ստեղծված օբյեկտները աշխատում են, մինչև չեն ջնջվում `delete`֊ի կողմից (§4.2.2): 



## 1.7 Հաստատուններ














