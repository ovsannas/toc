
# Հիմունքները

Մեր առաջին գործը այն կլինի, որ սպանենք բոլոր օրենսգետներին։

Հենրի VI, Մաս II, Արարված չորրորդ, Տեսարան երկրորդ

* Ներածություն
* Ծրագրեր
* Hello, World!
* Ֆունկցիաներ
* Տիպեր, փոփոխականներ և թվաբանություն
* Տեսանելիության տիրույթ և կյանքի տևողություն
* Հաստատուններ
* Ցուցիչներ, զանգվածներ և հղումներ
* Պայմաններ ստուգում
* Խորհուրդներ

## 1.1 Ներածություն

Այս գլուխը ոչ խիստ ձևով ներկայացնում է C++ լեզուն, C++-ի հիշողության և հաշվարկման մոդելները, և ծրագրերում կոդի կազմակերպման հիմնական մեխանիզմները։ Դրանք լեզվի այն հնարավորություններն են, որոնք ավելի հաճախ հանդիպում են C լեզվում և այդ ոճը երբեմն կոչվում է _պրոցեդուրային ծրագրավորում_։

## 1.2 Ծրագրեր

C++-ը կոմպիլյացվող (թարգմանվող) լեզու է։ Գործարկվող ծրագրի սկզբնական տեքստը պետք է մշակվի կոմպիլյատորով, որը ստեղծում է օբյեկտային ֆայլերը, վերջիններս էլ միավորվում են կապակցող ծրագրով և ստեղծվում է կատարվող ծրագիրը։ Սովորաբար C++ լեզվով գրված ծրագիրը բաղկացած է մի քանի սկզբնական ֆայլերից (ավելի հաճախ պարզապես՝ ֆայլեր)։ ?? Կատարվող ծրագիրը ստեղծվում է որոշակի ապարատ-համակարգ զույգի համար․ այն տեղափոխելի չէ, ասենք, Mac-ից Windows-ի։ Երբ խոսում ենք C++ ծրագրերի տեղափոխելիության մասին, սովորաբար նկատի ունենք նախնական տեքստերի տեղափոխելիությունը, այսինքն՝ նախնական տեքստերը կարող են հաջողությամբ կոմպիլյացվել և կատարվել տարբեր համակարգերում։

ISO C++ ստանդարտը սահմանում է էությունների (իրերի) երկու տեսակ․
* Լեզվի միջուկի հատկություններ, ինչպիսիք են ներդրված տիպերը (օրինակ՝ `char` և `int`) և ցիկլերը (օրինակ՝ `for` և `while` հրամանները)։
* Ստանդարտ գրադարանի բաղադրիչներ, ինչպիսիք են կոնտեյներները (օրինակ՝ `vector` և `map`) և ներմուծման/արտածման գործողությունները (օրինակ՝ `<<` և `getline()`)։ 

Ստանդարտ գրադարանի բաղադրիչները C++ լեզվի ամենասովորական կոդերն են , որոնցով հարստացված է C++ լեզվի ցանկացած տարբերակ (իրականացում)։ Այդ պատճառով C++ լեզվի ստանդարտ գրադարանը կարող է իրականացվել հենց C++ լեզվի մեջ (և շատ քիչ է օգտագործվում մեքենայական կոդի հետ այնպիսի դեպքերում, ինչպիսին է օրինակ հոսքի կոնտեքստի փոփոխումը): This implies that C++ is
sufficiently expressive and efficient for the most demanding systems programming tasks.
C++ is a statically typed language. That is, the type of every entity (e.g., object, value, name,
and expression) must be known to the compiler at its point of use. The type of an object determines
the set of operations applicable to it.


## 1.3 Hello, World!

C++ լեզվով գրված ամենափոքր ծրագիրը հետևյալն է՝

````c++
int main() {}    // C++-ով գրված ամենակարճ ծրագիրը
````

Այստեղ սահմանվում է `main` ֆունկցիան, որը ոչ մի արգումենտ չի ստանում և ոչ մի գործողություն չի կատարում։

C++-ում ձևավոր փակագծերը՝ `{}`, ցույց են տալիս խմբավորում։ Այստեղ նրանք ցույց են տալիս ֆունկցիայի մարմնի սկիզբն ու վերջը։ Երկու թեք գծերով՝ `//`, սկսվում է մեկնաբանություն, որը շարունակվում է մինչև տողի վերջը։ Մեկնաբանությունը գրվում է ընթերցողի համար, կոմպիլյատորը դա անտեսում է։ 

C++-ով գրված ցանկացած ծրագիր պետք է ունենա `main()` անունով ճիշտ մեկ գլոբալ ֆունկցիա։ Ծրագիրն սկսվում է այդ ֆունկցիայի կատարումով։ `main()` ֆունկցիայի վերադարձրած `int` արժեքը, եթե այդպիսին կա, ծրագրի վերադարձրած արժեքն է «համակարգին»։ Եթե ոչ մի արժեք չի վերադարձվում, համակարգը կստանա բարեհաջող ավարտ նշանակող որևէ արժեք։ `main()` ֆունկցիայից վերադարձվող զրոյից տարբեր արժեքը նշանակում է ծրագրի խափանում։ Ոչ բոլոր օպերացիոն համակարգերն ու կատարման միջավայրերն են օգտագործում այդ վերադարձված արժեքը. Linux/Unix-ի վրա հիմնված միջավայրերը հաճախ օգտագործում են, իսկ Windows-ի վրա հիմնված համակարգերը՝ երբեմն։

Որպես կանոն ծրագիրն ինչ-որ արտածում է կատարում։ Ստորև գրված է ծրագիր, որն էկրանին տպում է Hello, World! արտահայտությունը։

````c++
#include <iostream>
int main()
{
    std::cout << "Hello, World!\n";
}
````

`#include <iostream>` տողը կոմպիլյատորին հրահանգում է `iostream` ֆայլից ծրագրին _կցել_ ստանդարտ ներմուծման/արտածման միջոցների սահմանումները։ Առանց այդ սահմանումների

````c++
std::cout << "Hello, World!\n"
````

արտահայտությունը իմաստ չի ունենա։ `<<` (ուղարկել) օպերատորը գրում է իր երկրորդ արգումենտը առաջինի մեջ։ Հետևաբար `"Hello World!\n"` տողը գրվում է `std::cout` ստանդարտ արտածման հոսքի մեջ։ Տողը սիմվոլների հաջորդականություն է՝ ներառված կրկնակի չակերտներում։ Տողի մեջ հակառակ թեք գիծը՝ `\`, իրենից հետո մեկ այլ նիշի հետ միասին նշանակում է «հատուկ սիմվոլ»։ Այս դեպքում `\n`֊ը նոր տողի սիմվոլն է. այսինքն գրված են `Hello, World!` նիշերը և դրանց հաջորդող նոր տողի նիշը։

`std::` նախդիրը ցուցյ է տալիս, որ `cout` անունը գտնվում է ստանդարտ գրադարանի անվունների տիրույթում (§3.3)։ Ստանդարտ գրադարանի հնարավոքրությունները քննարկելիս ես սովորաբար ես բաց եմ թողնում `std::`-ն։ §3.3 բաժնում ցույց է տրվում, թե ինչպես մի որևէ անունների տիրույթի անունները դարձնել տեսանելի՝ առանց անունների տիրույթը բացահայտ նշելու։

Ընդհանրապես ամբողջ կատարվող կոդը բաշխվում է ֆունկցիաների մեջ և ուղղակիորեն կամ անուղղակիորեն կանչվում `main()` ֆունկցիայից։ Օրինակ․

````c++
#include <iostream>  // կցել Ն/Ա գրադարանի սահմանումները

using namespace std; // `std` անունների տիրույթի անունները դարձնում է տեսանելի առանց `std::`֊ի (§3.3)

double square( double x ) // իրական թվի քառակուսին
{
    return x * x;
}

void print_square( double x )
{
    cout << x << "-ի քառակուսին " << square( x ) << "է \n";
}

int main()
{
    print_square( 1.234 );  // արտածում է. 1.234-ի քառակուսին 1.52276 է
}
````

Վերադարջվող արժեքի `void` տիպը ցույց է տալիս, որ ֆունկցիան արժեք չի վերադարձնում։


## 1.4 Ֆունկցիաներ

C++ ծրագրում ինչ-որ գործողություն կատարելու հիմնական եղանակը այդ գործողությունը նկարագրող ֆունկցիայի կանչն է։ Ֆունկցիայի սահմանումով մենք նկարագրում ենք խնդրի լուծման ընթացքը, գործողությունների հաջորդականությունը։ Հնարավոր չէ կանչել մի ֆունկցիա, որը նախապես չի սահմանվել։

Ֆունկցիայի հայտարարության մեջ տրվում է ֆունկցիայի անունը, վերադարձվող արժեքի տիպը (եթե գոյություն ունի) և արգումենտների քանակն ու տիպերը, որոնք պետք է տրամադրվեն կանչի ժամանակ։ Օրինակ․

````c++
Elem* next_elem();  // արգումենտներ չկան, վերադարձնում է Elem֊ի ցուցիչ
void exit( int );  // ստանում է int տիպի արգումենտ, ոչինչ չի վերադարձնում
double sqrt( double );  // ստանում և վերադարձնում է double տիպի արժեք
````

Ֆունկցիայի հայտարարության մեջ վերադարձվող արժեքի տիպը գրվում է ֆունկցիայի անունից առաջ, իսկ արգումենտների տիպերը՝ ֆունկցիայի անվանումից հետո փակագծերի մեջ։ 

Արգումենտների փոխանցման սեմանտիկան նույնն է՝ ինչ պատճենող արժեքավորման սեմանտիկան։ Այսինքն՝ արգումենտների տիպերը ստուգվում են և հարկ եղած դեպքում կատարվում է տիպերի անբացահայտ ձևափոխություն (§1.5)։ Օրինակ․

````c++
double s2 = sqrt( 2 );  // կանչվում է sqrt() ֆունկցիան double{2} արգումենտով
double s3 = sqrt( "three" );  // սխալ․ sqrt() ֆունկցիան պահանջում է double տիպի արգումենտ
````

Կոմպիլյացիայի ժամանակ կատարվող այսպիսի ստուգումներն ու տիպերի ձևափոխությունը չպետք է underestimated։ ??

Ֆունկցիայի հայտարարության մեջ կարող են նշվել նաև արգումենտների անունները։ Դա կարող է օգնել ծրագիրը կարդացողին, բայց քանի դեռ չի գրվել ֆունկցայի սահմանումը, կոմպիլյատորը պարզապես անտեսում է արգումենտների անունները։ Օրինակ․

````c++
double sqrt( double d );  // վերադարձնում է d֊ի քառակուսի արմատը
double square( double );  // վերադարձնում է արգումենտի քառակուսի արմատը
````

Ֆունկցիայի տիպը բաղկացած է վերադարձվող արժեքի տիպից և արգումենտների տիպերից։ Դասի անդամ-ֆունկցիաների համար դասի անունը նույնպես ֆունկցիայի տիպի մի մասն է (§2.3, §4.2.1)։ Օրինակ․

````c++
double get( const vector<double>& vec, int index );  // տիպը՝ double(const vector<double>&,int)
char& String::operator[]( int index );  // տիպը՝ char& String::(int)
````

Մեր նպատակն է գրել պարզ, ընթեռնելի կոդ, քանի որ դա ?? առաջին քայլն է maintainability։ ?? Ծրագիրը հասկանալի ?? դարձնելու առաջին քայլը հաշվարկային խնդիրները փոքր, հասկանալի մասերի բաժանելն է (դասերի և ֆունկցիաների տեսքով) և դրանց անուններ տալը։ ?? Այդպիսի ֆունկցիաները ապահովում են հաշվարկների հիմնական բառարանը, ինչպես օրինակ տիպերը (ներդրված և օգտատերի կողմից սահմանված) ապահովում են տվյալների հիմնական բառարանը։ ?? C++ լեզվի ստանդարտ ալգորիթմները (օր․ find, sort և iota) ապահովում են լավ սկիզբ (Գլուխ 10)։ Դրանք օգտագործելով կարող ենք գրել ֆունկցիաներ, որոնք լուծում են ընթացիկ կամ հատուկ խնդիրներ ավելի մեծ հաշվարկների համար։ ??

The number of errors in code correlates strongly with the amount of code and the complexity of the code։ Both problems can be addressed by using more and shorter functions։ Ֆունկցիայի օգտագործումը հատուկ խնդիր լուծելու համար, հաճախ մեզ փրկում է ծրագրի մեջտեղում մեկ այլ հատուկ կոդ գրելուց; making it a function forces us to name the activity and document its dependencies. ??

Եթե երկու ֆունկցիա սահմանված են միևնույն անունով, բայց տարբեր տիպի արգումենտներով, ապա ամեն մի կանչի համար կոմպիլյատորը կընտրի տվյալ կանչին համապատասխան տարբերակը։ Օրինակ․

````c++
void print( int );  // ստանում է որպես արգումենտ ամբողջ թիվ
void print( double );  // ստանում է սահող ստորակետով թիվ
void print( string );  // ստանում է որպես արգումենտ տող

void user()
{
    print( 42 );  // կանչվում է print(int) ֆունկցիան
    print( 9.65 );  // կանչվում է print(double) ֆունկցիան
    print( "D is for Digital" );  // կանչվում է print(string)
}
````

Եթե երկու տարբերակներ կարող են կանչվել, բայց նրանցից ոչ մեկն ավելի նախընտրելի չէ, ապա կանչը համարվում է ոչ միանշանակ, և կոմպիլյատորը հայտնում է սխալի մասին։ Օրինակ․

````c++
void print( int, double );
void print( double, int );

void user2()
{
   print( 0, 0 );  // սխալ․ անորոշություն
}
````

Սա կոչվում է ֆունկցիայի գերբեռնում ?? և ընդհանրացված ծրագրավորման հիմնական գաղափարներից է (§5.4)։ Գերբեռնված ֆունկցիայի դեպքում նույն անունն ունեցող ֆունկցիաները պետք է ունենան նույն սեմանտիկան (իմաստը)։ Դրա օրինակն են `print()` ֆունցիաները․ յուրաքանչյուր `print()` տպում է իր արգումենտը։


## 1.5 Տիպեր, փոփոխականներ և թվաբանություն

C++ լեզվում յուրաքանչյուր անուն և յուրաքանչյուր արտահայտություն ունի տիպ, ըստ որի, որոշվում են նաև նրա հետ կատարվող գործողությունները։ Օրինակ 

````c++
int inch;
````

հայտարարությունը նշում է, որ `inch`֊ը `int` տիպի է, այսինքն `inch`֊ը ամբողջ տիպի փոփոխական է։

_Հայտարարությունը_ ծրագրային արտահայտություն է, որը մտցնում է անունը ծրագրի մեջ։ Այն նշում է անվանված էության տիպը․

* _Տիպը_ սահմանում է հնարավոր արժեքների և հնարավոր գործողությունների բազմությունը (օբյեկտի համար)։ 
* _Օբյեկտը_ ինչ֊որ չափի հիշողություն է, որը պահում է որևէ տիպի արժեք։
* _Արժեքը_ բիթերի խումբ է, որը թարգմանված է համապատասխան իր տիպին։
* _Փոփոխականը_ անուն ունեցող օբյեկտն է։

C++ լեզուն առաջարկում է ֆունդամենտալ տիպերի բազմազանություն։ Օրինակ․

````c++
   bool           // տրամաբանական (բուլյան) տիպ, հնարավոր արժեքներն են ճիշտ և սխալ
   char           // սիմվոլի տիպ, օրինակ 'a', 'z', և '9'
   int              // ամբողջ թվի տիպ, օրինակ -273, 42 և 1066
   double       // կրկնակի ճշտությամբ սահող ստորակետով թվի տիպ, օրինակ -273.15, 3.14 և 299793.0
   unsigned   // ոչ բացասական ամբողջ թվի տիպ, օրինակ 0,1 և 999
````

Յուրաքանչյուր ֆունդամենտալ տիպ ուղղակիորեն համապատասխանում է ապարատային հնարավորություններին և ունի կոնկրետ չափ, որը սահմանում է այն արժեքների բազմությունը, որոնք կարող են տեղավորվել նրա մեջ։
նկար 1.5.1


`char` տիպի փոփոխականը այն բնական չափին է, որը տվյալ մեքենայի մեջ կարող է պահել մեկ սիմվոլ (որպես կանոն դա կազմում է 8 բիթ), մյուս տիպերի չափերը հաշվարկվում են `char`֊ի չափի բազմապատիկներով։ Տիպի չափը կախված է մեքենայական իրականացումից (այսինքն այն կարող է տարբեր մեքենաներում լինել տարբեր), և տիպի չափը կարող ենք ստանալ նաև `sizeof` օպերատորի միջոցով; օրինակ `sizeof(char)`֊ը հավասար է `1`֊ի և `sizeof(int)`֊ը հաճախ `4` է։

Թվաբանական գործողությունները կարող են օգտագործվել հետևյալ տիպի համապատասխան կոմբինացիաներում․

````c++
   x+y       // գումարում
   +x         // ունար գումարում
   x-y        // հանում
   -x          // ունար հանում
   x*y        // բազմապատկում
   x/t         // բաժանում
   x%y      // ամբողջ թվերից ստացված մնացորդ (մոդուլուս)
````

Նույն ձևով կարող են օգտագործվել նաև համեմատության գործողությունները․

````c++
   x==y	// հավասար է
   x!=y	// հավասար չէ
   x<y	// փոքր է
   x>y	// մեծ է
   x<=y	// փոքր է կամ հավասար
   x>=y	// մեծ է կամ հավասար
````

Դեռ ավելին, ապահովված են նաև տրամաբանական գործողություններ․

````c++
   x&y       // բիթային և
   x|y	// բիթային կամ
   x^y	// բիթային բացառող կամ
   ~x	// բիթային լրացում
   x&&y     // տրամաբանական և
   x||y	// տրամաբանական կամ
````

Բիթային տրամաբանական գործողությունըA bitwise logical operator yield a result of their operand type for which the operation has been performed on each bit.&& և || տրամաբանական գործողությունները վերադարձնում են `true` կամ `false`՝ կախված իրենց օպերանդների արժեքներից։

Վերագրման և թվաբանական գործողությունների մեջ C++ լեզուն կատարում է (ներկայացնում է) բոլոր իմաստ ունեցող (հնարավոր) ձևափոխումները հիմնական տիպերի միջև այնպես, որ նրանք հնարավոր լինի ազատորեն միացնել․

````c++
void some_function()	//սահմանել ենք ֆունկցիա, որը ոչի մի արժեք չի վերադարձնում
{
double d=2.2;		//սահող ստորակետով թվին տվել ենք սկզբնական արժեք
int i=7;		//տվել ենք սկզբնական արժեք ամբողջ թվին
d = d+i;		//երկու թվերի գումարը վերագրում ենք d֊ին
i = d*i;		//երկու թվերի արտադրյալը վերագրում ենք i֊ին (կրճատում ենք d*i double արժեքը մինչև int)
}
````

Այն ձևափոխումները, որոնք օգտագործվում են արտահայտությունների մեջ կոչվում են *սովորական (գործածական) թվաբանական ձևափոխումներ* և երաշխավորում են, որ արտահայտությունները հաշվարկվում են իրենց օպերանդների բարձր ճշտությամբ։ Օրինակ `double` և `int` թվերի գումարումը կատարվում է՝ օգտագործելով կրկնակի ճշտությամբ սահող ստորակետով թվերի թվաբանությունը։

Նշենք, որ `=`֊ը վերագրման գործողությունն է, իսկ `==`֊ը ցույց է տալիս հավասարություն։

C++ լեզվում կա սկզբնական արժեքների գրառման մի քանի ձև․ մի ձևը `=` նշանի միջոցով է, որն օգտագործվել է վերևում և կա համընդհանուր ձև, երբ ձևավոր փակագծերի մեջ տալիս ենք սկզբնական արժեքների ցանկ, որոնք իրարից բաժանվում են ստորակետով, կամ ինչ որ բաժանիչով։ 

````c++
double d1 = 2.3;		//d1֊ին տրվում է 2.3 սկզբնական արժեքը
double d2 {2.3};		//d2-ին տրվում է 2.3 սկզբնական արժեքը
comples<double> z = 1;		//կոմպլեքս թիվ ներկայացված կրկնակի ճշտությամբ սահող ստորակետով թվի սկալյարնեով
complex<double> z2 {d1,d2};
complex<double> z3 = {1,2};	//=֊ը լրացուցիչ է {}֊ի հետ

vector<int> v{1,2,3,4,5,6};	//int֊երի վեկտոր
````

Վերագրման ձևը՝ `=`,ավելի տրադիցիոն է, եկել է C-ից, եթե կասկածում եք որը ընտրել, ընտրեք ձևավոր փակագծերը՝ `{}`։ Եթե ոչ մի տարբերություն էլ չլինի, այն կփրկի ձեզ այն ձևափոխություններից, որոնք կորցնում են ինֆորմացիայի մի մասը։ Օր․

````c++
int i1 = 7.2;		//i1-ը ստանում է 7 արժեքը
int i2{7.2};		//տալիս է սխալ՝ սահող ստորակետով թիվը ամբողջ թվի ձևափոխելուց
int i3 = {7.2};		//տալիս է սխալ՝ սահող ստորակետով թիվը ամբողջ թվի ձևափոխելուց (= նշանն էստեղ երկրորդական է)
````

Դժբախտաբար, ինֆորմացիան կորցնող ձևափոխումները, այսպես կոչված *նեղացող ձևափոխումները*, ինչպիսիք են օրինակ `double`֊ից `int`, `int`֊ից `char`, լեզվում թույլատրվում են և անուղղակի կերպով կատարվում են։ The problems caused by implicit narrowing conversions is a price paid for C compatibility (§14.3).

Հաստատունը (§1.7) չի կարող լինելA constant (§1.7) cannot be left uninitialized and a variable should only be left uninitialized in extremely rare circumstances. Պետք չէ ներկայացնել որևէ անուն, եթե չունեք համապատասխան արժեք նրա համար։ Օգտագործողի կողմից ստեղծված տիպերը (ինչպիսիք են օրինակ string, vector, Matrix, Motor_controller և Orc_warrior) կարող են սահմանվել, որպեսզի անուղղակի կերպով ստանան սկզբնական արժեքներ (§4.2.1)։

Երբ հայտարարում ենք որևէ փոփոխական և կարիքը չկա հստակ հաղորդել նրա տիպը when it can be deduced from the initializer:

````c++
auto b = true;		//a bool
auto ch = 'x';		//a char
auto i = 123; 		// an int
auto d = 1.2;		//a double
auto z = sqrt(y);	//z has the type of whatever sqrt(y) returns
````

`auto` բառի հետ օգտագործում ենք `=` նշանը With auto , we use the = because there is no potentially troublesome type conversion involved.

`auto` բառն օգտագործվում է այն դեպքում, երբ հատուկ պատճառ չկա բացահայտորեն նշելու փոփոխականի տիպը։ Հատուկ պատճառ կարող է համարվել այն, որ

* սահմանումը, որտեղ նշում ենք տիպը, որպեսզի այն պարզ և տեսանելի լինի կարդացողին, զբաղեցնում է մեր կոդի մեծ տարածք։
* ցանկանում ենք, որ պարզ լինի փոփոխականի շրջակայքը կամ ճշտությունը (օր․ `double` թե՞ `float`)։

Օգտագործելով `auto` բառը, շատ անգամ խուսափում ենք ավելորդություններից և տիպերի երկար անուններ գրելուց։ Սա հատկապես կարևոր է ընդհանրացված ծրագրավորման մեջ, որտեղ օբյեկտի հստակ տիպը ծրագրավորողը կարող է չիմանալ և նաև տիպերի անունները կարող են շատ երկար լինել (§10.2)։

Բացի հիմնական (սովորական) թվաբանությունից և տրամաբանական օպերատորներից C++ լեզուն առաջարկում է ևս մի քանի օպերատոր՝ փոփոխականների հետ փոփոխություններ կատարելու համար (նպատակով).

````c++
x+=y	//x = x+y
++x	//ավելացում․ x = x+1
x-=y	//x = x-y
--x	//նվազում․ x = x-1
x*=y	//x=x*y 
x/=y	//x=x/y
x%=y	//x=x%y
````

Այս օպերատորները հակիրճ են, ընդունված և շատ հաճախ են օգտագործվում։


## 1.6 Տեսանելիության տիրույթ և կյանքի տևողություն

Հայտարարութունը ներկայացնում է անունը տեսանելիության տիրույթում․

* _Տեսանելիության լոկալ տիրույթ_։ Այն անունը, որը հայտարարվել է Ֆունկցիայի (§1.4) կամ լյամբդայի (§5.5) մեջ, կոչվում է _լոկալ անուն_։ Վերջինիս տեսանելիության տիրույթը տարածվում է նրա հայտարարության կետից մինչև այն բլոկի վերջը, որտեղ գործում է այդ հայտարարությունը։ _Բլոկը_ սահմանափակված է մեկ զույգ `{}` ձևավոր փակագծերի միջև։ Ֆունկցիայի արգումենտների անունները համարվում են լոկալ անուններ։
* _Դասի տեսանելիության տիրույթ_։ Անունը կոչվում է _անդամ անուն_ (կամ _դասի անդամ անուն_), եթե այն սահմանվել է դասի ներսում (§2.2, §2.3, գլուխ 4)՝ որևէ ֆունկցիայի (§1.4), լյամբդայի (§5.5) կամ `enum class`-ի (§2.5) սահմաններից դուրս։ Նրա տեսանելիության տիրույթը տարածվում է իր հայտարարությունն ընդգրկող բլոկի `{`բացող փակագծից սկսած մինչև այդ հայտարարության վերջը։
* _Անունների տիրույթի տեսանելիության տիրույթ_։ Անունը կոչվում է _անունների տիրույթի անդամ անուն_, եթե այն սահմանվել է այդ անունների տիրությում (§3.3)՝ դուրս ցանկացած ֆունկցիայի, լյամբդայի (§5.5), դասի (§2.2, §2.3, գլուխ 4) կամ `enum class`֊ի սահմաններից (§2.5)։ Նրա տեսանելիության տիրույթը տարածվում է նրա հայտարարության կետից սկսած մինչև այդ անունների տիրույթի վերջը։ 

Այն անունը, որը չի հայտարարվել որևէ կառուցվածքի ներսում, կոչվում է _գլոբալ անուն_, և ասում են, որ այն գտնվում է _անունների գլոբալ տիրույթում_։

Ի հավելումն ասեմ, որ մենք կարող ենք ունենալ օբյեկտներ առանց անունների, ինչպիսիք են օրինակ ժամանակավոր փոփոխականները և այն օբյեկտները, որոնք ստեղծվել են օգտագործելով `new` օպերատորը (§4.2.2): Օրինակ․

````c++
   vector<int> vec; // vec-ը գլոբալ փոփոխական է (ամբողջ թվերի գլոբալ վեկտոր)
   struct Record {
      string name; // name-ը անդամ անուն է (string տիպի անդամ)
      //...
   };

   void fct(int arg) // fct-ն գլոբալ անուն է (գլոբալ ֆունկցիա)
                  // arg֊ը լոկալ անուն է (ամբողջ տիպի արգումենտ)
   {
      string motto{"Who dares win"}; // motto֊ն լոկալ անուն է
      auto p = new Record{"Hume"}; // p֊ն անանուն Record֊ի ցուցիչ է (որն ստեղծվել է new֊ի միջոցով)
      // ...
   }
````

Օբյեկտը պետք է ստեղծվի (այսինքն ստանա սկզբնական արժեք) մինչև նրա օգտագործելը և պետք է վերանա իր տեսանելիության տիրույթի վերջում։ Անունների տիրույթի օբյեկտի համար ոչնչացման կետը ծրագրի ավարտն է։ Անդամ անունների համար ոչնչացման կետը որոշվում է այն օբյեկտի ոչնչացման կետով, որի անդամն է համարվում տվյալ անունը։ `new` օպերատորի միջոցով ստեղծված օբյեկտներն «ապրում են» այնքան, մինչև չեն ոչնչացվում `delete` (§4.2.2) օպերատորի միջոցով։


## 1.7 Հաստատուններ

C++ լեզվում օբյեկտի չփոփոխվող լինելը նշելու համար կա երկու գրառում.

* `const`։ որը, կոպիտ ասած նշանակում է․ «Ես խոստանում եմ չփոփոխել այս արժեքը»։ Սա հատկապես օգտագործվում է տվյալները ֆունկցիաներին փոխանցելիս, որպեսզի վստահ լինենք, որ փոխանցվող տվյալները չեն փոփոխվում։ Դա կատարվում է `const` բառի միջոցով։
* `constexpr`։ որը կոպիտ ասած նշանակում է «գնահատել կոմպիլյացաիայի ժամանակ»։ Սա օգտագործվում է նշելու համար այն հաստատունները specify constants, to allow placement of data in read-only memory (where it is unlikely to be corrupted) and for performance.

Օրինակ․

````c++
const int dmv = 17; // dmv-ն անվանված հաստատուն է
int var = 17; // var-ը հաստատուն չէ

constexpr double max1 = 1.4*square(dmv); // ճիշտ է, եթե square(17)֊ը հաստատուն արտահայտություն է
constexpr double max2 = 1.4*square(var); //սխալ է, քանի որ var-ը հաստատուն արտահայտություն չէ
constexpr double max3 = 1.4*square(var); //
````


## 1.8 Ցուցիչներ, զանգվածներ և հղումներ

`char` տիպի տարրերի զանգվածը կարելի է հայտարարել հետևյալ կերպ․

````c++
char v[6]; // 6 նիշերի զանգված 
````

Նույն ձևով կարելի է հայտարարել նաև ցուցիչ․

````c++
char* p; // նիշի ցուցիչ
````

Հայտարարություններում `[]` փակագծերը ցույց են տալիս զանգված, իսկ `*`-ը՝ ցուցիչ։ Բոլոր զանգվածների ինդեքսների ստորին սահմանը `0`֊ն է, հետևաբար `v`֊ն ունի վեց տարր՝ `v[]0`֊ից `v[5]`։ Զանգվածի  չափը պետք է լինի հաստատուն արտահայտություն (§1.7)։ Ցուցիչ փոփոխականը կարող է պահել հայտարարությամբ նշված տիպի օբյեկտի հասցեն․

````c++
char* p = &v[3]; // p-ն ցույց է տալիս v֊ի չորրորդ էլեմենտին
char x = *p; // *p-ն այն օբյեկտն է, որին ցույց է տալիս p-ն
````

Արտահայտության մեջ ունար `*`֊ը ցույց է տալիս օբյեկտի «պարունակությունը», իսկ ունար `&`֊ը ցույց է տալիս «հասցեն»։ Կարող ենք վերը կատարված ինիցիալիզացիան ներկայացնել գրաֆիկորեն․

նկար 1.8

Դիտարկենք մի զանգվածի տարրերը մյուսի մեջ պատճենող ծրագիրը․

````c++
void copy_fct()
{
    int v1[10] = {0,1,2,3,4,5,6,7,8,9};
    int v2[10]; // դառնալու է v1-ի պատճենը

    for( auto i = 0; i != 10; ++i ) // պատճենել տարրերը
        v2[i] = v1[i];
    //...
}
````

`for`-արտահայտությունը կարելի է կարդալ հետևյալ կերպ․ «`i`֊ին վերագրում ենք զրո, քանի դեռ `i`֊ն `10` չէ, պատճենել `i`֊րդ տարրը և ավելացնել `i`֊ն»։ Ամբողջ տիպի փոփոխականի համար կիրառելիս աճի `++` օպերատորը պարզապես ավելացնում է `1`։ C++ լեզուն առաջարկում է նաև `for`-արտահայտության ավելի պարզ տարբերակ, որը կոչվում է range-`for`-արտահայտություն, և for loops that traverse a sequence in the simplest way:

````c++
void print()
{
    int v[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    for( auto x : v ) // յուրաքանչկուր x֊ի համար v֊ից
        cout << x << '\n';

    for( auto x: {10, 21, 32, 43, 54, 65} )
        cout << x << '\n';
    //....
}
````

Առաջին range-`for`-արտահայտությունը կարդում ենք հետևյալ ձևով․ «`v`֊ի յուրաքանչյուր էլեմենտի համար, սկզբից մինչև վերջ, տեղադրիր կրկնօրինակը `x`-ի մեջ և տպիր այն»։ Հաշվի առեք, որ կարող ենք չնշել զանգվածի չափը, երբ նրան տալիս ենք սկզբնական արժեքներ ցուցակի միջոցով։ range-`for`֊արտահայտությունը կարող է օգտագործվել էլեմենտների ցանկացած հաջորդականության համար (§10.1):

Եթե չենք ցանկանում պատճենել արժեքները `v`֊ից `x` փոփոխականի մեջ, այլ ուղղակի ցանկանում ենք հղել `x`֊ը որևէ տարրի վրա, կարող ենք գրել․

````c++
   void increment()
   {
	int v[] = {0,1,2,3,4,5,6,7,8,9};

	for (auto& x:v)
		++x;
	// ...
   }
````

Հայտարարության մեջ ունար `&` օպերացիան նշանակում է «հղել»։ Հղումը նման է ցուցիչին, այն տարբերությամբ, որ կարիք չկա օգտագործել `*` նշանը այն արժեքին հասնելու համար, որի վրա ցույց է տալիս հղումը։ Հղումը սկզբնական արժեք ստանալուց հետո, այլևս չի կարող փոխվել՝ ուրիշ օբյեկտի վրա ցույց տալու համար։

Հղումները հատկապես օգտակար են ֆունկցիայի արգումենտներ նշելիս։ Օրինակ․

````c++
void sort(vector<double>& v);	//sort v
````

Արգումենտի մեջ հղում օգտագործելով, վստահեցնում ենք, որ `sort(my_vec)` կանչի ժամանակ չի ստեղծվում `my_vec`֊ի պատճենը, այլ իրական `my_vec`֊ն է, որը դասակարգվում է, այլ ոչ նրա պատճենը։

Երբ չենք ցանկանում փոփոխել ֆունկցիայի արգումենտը, բայց նաև միաժամանակ չենք ցանկանում, որ ստեղծվի նրա պատճենը, այդ ժամանակ օգտագործում ենք `const` հղումը։ Օրինակ․

````c++
   double sum(const vector<double>&)
````

`const` հղումը ստացող ֆունկցիաները շատ կիրառելի են։

Հայտարարությունների մեջ օգտագործվող օպերատորները (ինչպիսիք են `&`, `*` և `[]`) կոչվում են *հայտարարող օպերատորներ*։

````c++
   T a[n];	//T[n]; n հատ T֊երի զանգված
   T* p;	//T*; ցուցիչ T֊ի վրա
   T& r;	//T&; հղում T֊ի վրա
   T f(A);	//T(A): ֆունկցիա, որը վերցնում է A տիպի արգումենտ և վերադարձնում է T տիպի արդյունք
````

Մենք միշտ վստահեցնում ենք, որ ցուցիչը միշտ ցույց է տալիս որևէ օբյեկտի վրա, այսինքն ապահասցեավորումը հիմնավոր է։ Երբ չկա որևէ օբյեկտ ցույց տալու համար կամ ուզում ենք ներկայացնել «ոչ մի օբյեկտ հասանելի չէ» գրառումը (օր․ երբ հասել ենք ցանկի վերջին), այդ դեպքում ցուցիչին տալիս ենք `nullptr`(«զրոյական ցուցիչ») արժեքը։ Բոլոր տիպերի ցուցիչների համար կա մեկ `nullptr`.

````c++
   double* pd = nullptr;
   Link<Record>* lst = nullptr;	//ցուցիչ Record֊ի Link֊ի վրա
   int x = nullptr;		//սխալ է․ nullptr֊ն ցուցիչ է, ոչ թե ամբողջ տիպ
````

Հաճախ կարևոր է ստուգել, որ ցուցիչի արգումենտը, որը ենթադրում է, որ պետք է ցույց տա որևէ օբյեկտի վրա, իսկապես ցույց է տալիս․

````c++
   int count_x(char* p,char x)
	//հաշվում է x-ի՝ p[]-ի մեջ հանդիպելու քանակը
	//ենթադրվում է, որ p֊ն ցուցիչ է զրոյով ավարտվող սիմվոլների զանգվածի վրա (կամ ոչ մի բանի վրա)
   {
   	if (p == nullptr) return 0;
	int count = 0;
	for (;p!=nullptr;++p)
		if (*p == x)
		   ++count;
	return count
   }
````

Ուշադիր նայենք, թե ինչպես կարող ենք տեղաշարժել ցուցիչը զանգվածի հաջորդ տարրի վրա՝ օգտագործելով `++` նշանը և թե ինչպես կարող ենք բաց թողնել սկզբնական արժեքների վերագրումը `for`֊արտահայտության մեջ, եթե դրա կարիքը չկա։

`count_x()`֊ի սահմանումից ենթադրվում է, որ `char*`֊ը C֊ոճով գրված տող է, դա նշանակում է, որ ցուցիչը ցույց է տալիս զրոյով ավարտվող `char`֊երի զանգվածի վրա։

Հին կոդերում `nullptr`֊ի փոխարեն օգտագործվում էր `0` կամ `NULL`։ Ինչևէ `nullptr`֊ի կիրառումը վերացնում է հնարավոր շփոթմունքը ամբողջ թվերի (ինչպիսիք են օրինակ `0`֊ն կամ `NULL`֊ը) և ցուցիչների (ինչպիսին է օրինակ `nullptr`֊ը) միջև։

`count_if()`֊ի օրինակը անտեղի բարդեցված է։ Մենք կարող ենք այն պարզեցնել՝ ստուգելով `nullptr`֊ը միայն մի տեղ։ Քանի որ `for`֊արտահայտության մեջ ինիցիալիզացիան բացակայում է, կարող ենք օգտագործել `while`֊արտահայտությունը․

````c++
   int count_x(char* p, char x)
	//
	//
   {
	int count = 0;
	while (p) {
	   if (*p == x)
		++count;
	   ++p;
         }
	return count;
   }
````

`while`-ցիկլը կատարվում է, մինչև նրա պայմանը դառնում է `false`:

Ցուցիչը ստուգող պայմանը (օր․ `while(p)`) համարժեք է ցուցիչը զրոյական ցուցիչի հետ համեմատելու պայմանին (`while(p!=nullptr)`)։


## 1.9 Պայմանների ստուգում

C++-լեզուն ապահովում է պայմանական արտահայտությունների շարք, որոնք ներկայացնում են ընտրություն և ցիկլ։ Օրինակ, here is a simple function that prompts the user and returns a Boolean indicating the response:

````c++
bool accept()
{
    cout<<"Do you want to proceed (y or n)?\n"; 	//գրում ենք հարցը

    char answer = 0;
    cin>>answer;    //կարդում ենք պատասխանը

    if(answer == 'y')
        return true;
    return false;
}
````

`<<` (տեղադրել) արտածման օպերատորին պատասխանելու համար օգտագործվել է `>>` (ստանալ) ներմուծման օպերատորը; `cin`֊ը ներմուծման ստանդարտ հոսքն է (գլուխ 8)։ `>>` օպերատորի աջակողմյան օպերանդը որոշում է, թե ինչ է պետք ներմուծել և այդ աջակողմյան օպերանդը նշան է ներմուծման գործողության համար։ `\n` սիմվոլը արտածվող տողի վերջում ցույց է տալիս նոր տող (§1.3)։

Ուշադրություն դաձրեք, որ `answer` փոփոխականի սահմանումը appears where it is needed (and not before that). A declaration can appear anywhere a statement can.

Օրինակը ավելի լավը կդառնա ստանանք նաև `n` («ոչ»֊ համար) պատասխանը․

````c++
bool accept2()
{
    cout<<"Ցանկանու՞մ եք շարունակել (y կամ n)?\n";    //գրում ենք հարցը
    char answer = 0;
    cin>>answer;

    switch(answer){
    case 'y':
        return true;
    case 'n':
        return false;
    default:
        cout<<"Այս պատասխանն ընդունվում է որպես «ոչ»։\n";
        return false;
    }
}
````
 
`switch`-արտահայտությունը ստուգում է արժեքը մի քանի հաստատունների հետ։ Հաստատունների տարբերակները տարբեր են, և եթե ստուգվող արժեքը չի համընկնում ոչ մեկի հետ, ընտրվում է `default` մասը։ Եթե `default` մասը բացակայում է, ոչ մի գործողություն չի կատարվում արժեքի և հաստատունների չհամընկնելու դեպքում։

Կարիք չկա ավարտել `case`֊ը `switch`֊արտահայտությունից վերադարձնելով արժեք։ Հաճախ ցանկանում ենք շարունակել `switch`֊արտահայտությանը հետևող արտահայտությունը։ Դա անում ենք `break` հրամանի միջոցով։ Որպես օրինակ եկեք դիտարկենք չափազանց խելացի, բայց դեռ պրիմիտիվ փարսերի ծրագիր մի վիդեո֊խաղի շատ փոքր հրամանի համար․

````c++
void action()
{
    while(true){
        cout<<"enter action:\n";    //սպասում ենք գործողության
        string act;
        cin>>act;            //
        Point delta{0,0};    //

        for(char ch:act) {
        switch (ch){
        case 'u':    //
        case 'n':    //
            ++delta.y;
            break;
        case 'r':    //
        case 'e':    //
            ++delta.x;
            break;
        //
       default:
            cout<<"I freeaze!\n";
       }
        move(current+delta*scale);
        update_display();
      }
    }

}
````


## 1.10 Խորհուրդներ

1. Այս գլխում շարադրված նյութը մոտավորապես համապատասխանում է այն նյութին, որը շատ ավելի մանրամասնորեն նկարագրված է  «Stroustrup, 2013» գրքի, 5-6, 9-10 և 12 գլուխներում։
2. Խուճապի մի՛ մատնվեք։ Ամեն ինչ ավելի հասկանալի կլինի ժամանակի ընթացքում, §1.1։
3. C++ լեզվով լավ ծրագրեր գրելու համար պարտադիր չէ իմանալ բոլոր մանրուքները։
4. Կենտրոնացե՛ք ծրագրավորման մեթոդների (տեխնիկական հնարքների) և ոչ թե լեզվական առանձնահատկությունների վրա։
5. Լեզվի սահմանման հարցերի (տարաձայնությունների) մասին վերջնական խոսքի համար նայեք ISO C++ ստանդարտը, §14.1.3։
6. «Փաթեթի» իմաստ ունեցող գործողությունները անվանվել են ֆունկցիաներ, §1.4։
7. Ֆունկցիան պետք է իրականացնի ընդամենը մեկ տրամաբանական գործողություն, §1.4։
8. Ֆունկցիաները պահպանեք կարճ տեսքով, §1.4։
9. Օգտագործե՛ք գերբեռնման հնարավորությունը, երբ ֆունկցիաներն իրականացնում եմ գաղափարային նույն խնդիրը տարբեր տիպերի համար, §1.4։
10. Եթե ֆունկցիան պետք է հաշվարկվի կոմպիլյացիայի ժամանակ, հայտարարեք այն `constexpr`, §1.7։ 
11. Avoid ‘‘magic constants;’’ use symbolic constants; §1.7.
12․ Յուրաքանչյուր հայտարարությունում հայտարարեք մեկ անուն (միայն)։
13. Ընթացիկ և լոկալ անունները պահպանեք կարճ տեսքով, իսկ ոչ սովորական և ոչ լոկալ անունները՝ ավելի երկար տեսքերով։
14. Խուսափեք իրար նման անուններից։
15. Խուսափեք մեծատառերով անուններից։
16. Նախընտրեք `{}`-ինիցիալիզատորը այն հայտարարություններում, որտեղ տիպը անվանված է, §1.5։
17. Նախընտրեք `=` սինտաքսիսը ինիցիալիզացիայի համար այն հայտարարություններում, որտեղ օգտագործվում է `auto` բառը,§1.5։
18. Խուսափեք ոչ ինիցիալիզացված փոփոխականներից, §1.5։
19. Պահեք փոքր տեսանելիության տիրույթներ, §1.6։
20. Ցուցիչների օգտագործումը թող լինի պարզ և բաց,§1.8։
21. Օգտագործեք `nullptr` ավելի հաճախ, քան `0` կամ `NULL`, §1.8։
22. Պետք չէ հայտարարել փոփոխական, քանի դեռ չունեք սկզբնական արժեք նրա համար, §1.8, §1.9։
23. Պետք չէ մեկնաբանության մեջ գրել այնպիսի բան, որը կոդում հստակ երևում է։
24. State intent in comments.
25. Maintain a consistent indentation style.
26. Խուսափեք բարդ արտահայտություններից։
27. Խուսափեք նեղացող ձևափոխումներից, §1.5։




























