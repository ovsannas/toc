#Modularity

Don't interrupt me while I'm interrupting.
-Winston S. Churchill

 
* Ներածություն
* Առանձնացված կոմպիլյացիա
* Անունների տիրույթներ (Անվանատարծքներ)
* Սխալների մշակում
        Բացառություններ; Ինվարիանտներ; Ստատիկ պնդումներ
* Խորհուրդներ 


## 3.1 Ներածություն 

C++ լեզվով գրված ծրագիրը բաղկացած է բազմաթիվ առանձին կառուցված մասերից, այնպիսիք, ինչպիսիք են օրինակ ֆունկցիաները (§1.3), օգտագործողի սահմանած տիպերը (Գլուխ 2), դասերի հիերարխիան (§4.5) և շաբլոնները (Գլուխ 5)։ Այդ բոլոր մասերը կառավարելու բանալին նրա մեջ է, որ հստակորեն սահմանվի համագործակցությունը այդ մասերի միջև։ Առաջին և ամենակարևոր քայլն այն է, որ լինի տարբերություն ինտերֆեյսի և իրականացման միջև։ Լեզվական մակարդակի վրա C++֊ը ինտերֆեյսերը ներկայացնում է հայտարարությունների միջոցով։ *Հայտարարությունը* նշում է այն բոլոր տվյալները, որոնք անհրաժեշտ են ֆունկցիային կամ տիպին օգտագործելու համար։ Օրինակ․

````c++
   double sqrt(double);  // քառակուսի արմատի ֆունկցիան ստանում է double արժեք և վերադարձնում է նույնպես double
````

````c++
   class Vector {
   public:
       Vector(int s);
       double& operator[] (int i);
       int size();
   private:
       double* elem;      // elem֊ը ցույց է տալիս sz քանակի double արժեքներով զանգվածի վրա
       int sz;
   };
````
Այստեղ կարևոր պահն այն է, որ ֆունկցիաների մարմինները, ֆունկցիաների *սահմանումները* գտնվում են «մեկ այլ տեղում»։ Այս օրինակի համար մեզ միգուցե դուր կգար, որպեսզի  `Vector`֊ի ներկայացումը նույնպես լիներ «մեկ ուրիշ տեղ», բայց մենք կքննարկենք այս հարցը մի քիչ ուշ (աբստրակտ տիպեր; §4.3)։ `sqrt()`֊ի սահմանումը կունենա հետևյալ տեսքը․

````c++
   double sqrt(double d)         // sqrt()֊ի սահմանումը
   { 
         // ․․․մաթեմատիկայի դասագրքում գրված ալգորիթմը․․․
   }
````
`Vector`֊ի համար մենք պետք է սահմանենք բոլոր երեք ֆունկցիա֊անդամները․

````c++
   Vector::Vector(int s)                           // կոնստրուկտորի սահմանումը
          :elem{new double[s]}, sz{s}      // արժեքներ տալ տվյալ անդամներին
   {
   }

   double& Vector::operator[] (int i)      // ինդեքսավորման օպերատորի սահմանումը
   {
       return elem[i];
   }

   int Vector::size()                                // size()֊ի սահմանումը
   {
       return sz;
   }
````
Մենք պետք է սահմանենք `Vector`֊ի ֆունկցիաները, բայց ոչ `sqrt()` ֆունկցիան, քանի որ այն ստանդարտ գրադարանի մասն է։ Ինչևէ, ոչ մի իրական տարբերություն չի տալիս․ գրադարանը պարզ ասած «մեկ ուրիշ կոդ է, որը մենք որոշել ենք օգտագործել»՝ գրված լեզվի նույն գործիքներով, որոնք մենք օգտագործում ենք։


## 3.2 Առանձնացված կոմպիլյացիա

C++ լեզուն հենվում է առանձնացված կոմպիլյացիայի հասկացության վրա, որտեղ օգտագործողի կոդը տեսնում է միայն օգտագործված տիպերի և ֆունկցիաների հայտարարությունները։ Այդ տիպերի և ֆունկցիաների սահմանումները գտնվում են այլ սկզբնային ֆայլերում և կոմպիլացվում են առանձին։ Սա կարող է օգտագործվել, որպեսզի ծրագիրը կազմակերպվի կիսաանկախ կոդի հատվածների բազմության մեջ։ Այսպիսի առանձնացումը կարող է օգտագործվել կոմպիլյացիայի ժամանակը մինիմալի հասցնելու համար և ծրագիրը խստորեն տրամաբանական մասերի բաժանելու համար (որը մինիմալի է հասցնում սխալների հավանականությունը)։ Գրադարանը հաճախ առանձին կոմպիլացված կոդերի (օր․ ֆունցիաների) հավաքածու է։

Սովորաբար հայտարարությունները, որոնք ցույց են տալիս ինտերֆեյսը, տեղադրում ենք դրանց նախատեսվող օգտագործումը նկարագրող անվամբ ֆայլի՝ մոդուլի մեջ։ Օրինակ․

````c++
   // Vector.h:

   class Vector {
   public:
       Vector(int s); 
       double& operator[] (int i);
       int size();
   private:
       double* elem;         // elem֊ը ցույց է տալիս double տիպի sz տարրերի զանգվածի վրա
       int sz;
   };
````

Ենթադրվում է, որ այս հայտարարությունը պետք է տեղադրվի `Vector.h` ֆայլում, և օգտագործողները պետք է *ներառեն* այդ ֆայլը, որը կոչվում է *վերնագրային ֆայլ*, որպեսզի հասանելի լինի տվյալ ինտերֆեյսը։ Օրինակ․


````C++
   // user.cpp:


   #include "Vector.h"  // ստանալ Vector֊ի ինտերֆեյսը
   #include <cmath>     // ստանալ ստանդարտ գրադարանի մաթեմատիկական ֆունկցիաների ինտերֆեյսը՝ ներառյալ sqrt() ֆունկցիայինը

   using namespace std;  // std անունների տիրույթի անդամները դարձնում ենք տեսանելի (§3.3)

   double sqrt_sum(Vector& v)
   {
       double sum = 0;
       for (int i = 0; i != v.size(); ++i)
           sum += sqrt(v[i]);   // քառակուսի արմատների գումարը
       return sum;
   }
````

Որպեսզի օգնենք կոմպիլյատորին ապահովելու կայունություն, `Vector`֊ի իրականացումն ապահովող `.cpp` ֆայլը նույնպես պետք է ներառի նրա ինտերֆեյսն ապահովող `.h` ֆայլը․


````c++
   // Vector.cpp:

   #include "Vector.h"   // ստանում ենք ինտերֆեյսը

   Vector::Vector (int s)
                 :elem {new double[s]}, sz{s}       // ինիցիալիզացնում ենք անդամները
   {
   }

   double& Vector::operator[] (int i)
   {
            return elem[i];
   }

   int Vector::size()
   {
             return sz;
   }
````

`user.cpp` և `Vector.cpp` ֆայլերի կոդերն օգտագործում են `Vector.h` ֆայլում ներկայացված `Vector`֊ի ինտերֆեյսի ինֆորմացիան, բայց նաև այդ երկու ֆայլերն իրարից անկախ են և կարող են կոմպիլյացվել առանձին։ Գրաֆիկորեն ծրագրի կտորները կարող են ներկայացվել հետևյալ ձևով․

նկար գլուխ 3.2

Կոպիտ ասած, առանձնացված կոմպիլյացիայի կիրառումը լեզվի խնդիրը չէ; այլ այն հարցն է, թե ինչպես ունենալ առավելությունof a particular language implementation. However, it is of great practical importance. The best approach is to maximize modularity, represent that modularity logically through language features, and then exploit the modularity physically through files for effective separate compilation.


## 3.3 Անվանատարծքներ

Որպես լրացում ֆունկցիաներին (§1.4), դասերին (§2.3) և թվարկումներին (§2.5), C++ լեզուն առաջարկում է նաև *անվանատարածքներ*, որպես մեխանիզմ արտահայտելու համար, որ որոշ արտահայտություններ կարող են լինել համատեղ և նրանց անունները չպետք է կրկնվեն։ Որպես օրինակ ուզում եմ ներկայացնել իմ սեփական կոմպլեքս թվերի տիպը․ (§4.2.1, §12.4):

````c++
namespace My_code {
          class complex {
                   // ...
          };

          complex sqrt(complex);
          // ...
          int main();
}

int My_code::main()
{
     complex z{1,2};
     auto z2 = sqrt(z);
     std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
     // ...
}

int main()
{
     return My_code::main();
}
````

Տեղադրելով իմ կոդը `My_code` անվանատարածքի մեջ, ես վստահ եմ լինում, որ իմ անունները կոնֆլիկտի մեջ չեն մտնում ստանդարտ գրադարանի անունների հետ, որոնք գտնվում են `std` անվանատարածքում (§3.3)։ Նախազգուշացումը խոհեմ է, որովհետև ստանդարտ գրադարանը տրամադրում է աջակցություն `complex` թվերի թվաբանության համար (§4.2.1, §12.4)։ 

Մեկ այլ անունների տիրույթում գտնվող անվանը հասնելու ամենապարզ ճանապարհը նրան անվանատարածքի անվան հետ դիմելն է (օր․ `std::cout` և `My_code::main`)։ «Իրական `main()֊ը`» սահմանված է անունների գլոբալ տիրույթում, այսինքն ոչ լոկալ անվանատարածքում, դասում կամ ֆունկցիայում։ Որպեսզի ստանանք դիմելու կարողություն ստանդարտ գրադարանի անվանատարածքի անուններին, մենք կարող ենք օգտագործել `using`- դիրեկտիվը․

````c++
   using namespace std;
````
`using`֊ դիրեկտիվը անվանված անունների տիրույթի անունները դարձնում է հասանելի, կարծես թե նրանք լոկալ են տեսանելիության այն տիրույթում, որտեղ, որ տեղադրել ենք դիրեկտիվը։ Այսպիսով `std` անվանատարածքի համար `using` - դիրեկտիվն օգտագործելուց հետո, մենք կարող ենք `std::cout`֊ի փոխարեն ուղղղակի գրել `cout`։

Անվանատարածքները հիմնականում օգտագործվում են ծրագրային ավելի մեծ բաղկացուցիչներ (կոմպոնենտներ) ստեղծելու համար, ինչպիսիք են օրինակ գրադարանները։ Նրանք պարզեցնում են ծրագրի կազմությունը՝ բաժանելով այն առանձին կազմված մասերի։


## 3.4  Սխալների մշակում

Սխալների մշակումը մտահոգություններով և ճյուղավորումներով մի մեծ և համախմբված նյութ է, որը գնում է հեռու լեզվի հնարավորություններից դուրս դեպի ծրագրավորման տեխնիկան և գործիքները։ Ինչևէ, C++ լեզուն ապահովում է որոշ գործիքներ օգնության համար։ Գլխավոր գործիքը հենց ինքը համակարգն է: Քրտնաջան ձևով ներդրված տիպերով (օր․ `char`, `int`, և `double`) և հրամաններով (օր․ `if`, `while` և `for`) ծրագրեր կազմելու փոխարեն մենք կառուցում ենք մեր ծրագրերի համար հարմար տիպեր (օր․ `string`, `map` և `regex`) և ալգորիթմներ (օր․ `sort()`, `find_if()` և `draw_all()`): Այսպիսի բարձր մակարդակի կառուցվածքը պարզեցնում է մեր ծրագրավորումը, սահմանափակում է մեր՝ սխալների հնարավորությունները (օր․ e.g., you are unlikely to try to apply a tree traversal to a dialog box) և մեծացնում է կոմպիլյատորի հնարավորությունները սխալներ գտնելու մեջ։ C++ լեզվի կառուցվածքների մեծամասնությունը նվիրված է էլեգանտ և որակյալ աբստրակցիաների մեխանիզմների ձևավորմանը և իրագործմանը (օր․ օգտագործողի սահմանած տիպերը և դրանք կիրառող ալգորիթմները)։ Այս մոդուլյարության և աբստրակցիայի էֆեկտներից մեկն այն է, (մասնավորապես գրադարանների կիրառումը) որ այն կետը, որտեղ run-time սխալը կարող է գտնվել առանձին է այն կետից, որտեղ այն կարող է մշակվել։ Քանի որ ծրագրերը մեծանում են, և հատկապես երբ գրադարանները ավելի լայնորեն են կիրառվում, սխալների մշակման ստանդարտները դառնում են կարևոր։ Լավ գաղափար է ձևավորել և հստակեցնել սխալների մշակման ստրատեգիա  ծրագրերի մշակման մեջ ավելի վաղ։ 

### 3.4.1 Բացառություններ

Դիտարկենք նորից `Vector` դասի օրինակը։ Ի՞նչ *կլինի*, երբ փորձենք դիմել այն տարրին, որը §2.3֊ի վեկտորի համար դուրս է սահմաններից։ 
* `Vector` դասի ստեղծողը չգիտի, թե ինչպես կվարվի օգտագործողը նման իրավիճակում (վեկտորն ստեղծողը սովորաբար նույնիսկ չգիտի էլ, թե որ ծրագրում է վեկտորն աշխատելու)։
* Համապատասխանորեն `Vector` դասի օգտագործողը չի կարող հայտնաբերել տվյալ խնդիրը (եթե օգտագործողը կարողանար, սահմանից դուրս դիմումը տեղի չէր ունենա առաջին տեղում)։

Լուծումը հետևյալն է, որ `Vector`֊ը իրականացնողը հայտնաբերի զանգվածի սահմանից դուրս դիմումը և տեղեկացնի օգտագործողին դրա մասին։ Օգտագործողը դրանից հետո կարող է կատարել համապատասխան գործողությունը։ Օրինակ, `Vector::operator[]()` ֆունկցիան կարող է հայտնաբերել փորձված դիմումը շարքից դուրս և դուրս բերել (throw) `out_of_range` բացառությունը․

````c++
   double& Vector::operator[] (int i)
   {
         if (i < 0 || size() <= i)
               throw out_of_range{"Vector::operator[]"};
         return elem[i];
   }
````

`throw` փոխանցումները վերահսկում են `out_of_range` տիպի բացառությունների մշակիչին (handler) այնպիսի ֆունկցիաների մեջ, որոնք ուղղակիորեն կամ անուղղակիորեն կոչվում են `Vector::operator[]()`։ To do that, the implementation will unwind the function call stack as needed to get back to the context of that caller. That is, the exception handling mechanism will exit scopes and function as needed to get back to a caller that has expressed
interest in handling that kind of exception, invoking destructors (§4.2.2) along the way as needed.
For example:

````c++
   void f(Vector& v)
   {
      // ...
      try { // այստեղ բացառությունները մշակվում են ներքևում սահմանված մշակիչի միջոցով

             v[v.size()] = 7;   // փորձել դիմել v֊ից դուրս
      }
      catch (out_of_range) { // oops: out_of_range error
             // ... մշակել սահմաններից դուրս սխալը ...
      }
      // ...
   }
````

Բացառությունների մշակման համար մեր նախատեսած կոդը տեղադրում ենք `try`-բլոկում։ Հավասարությունը, որը փորձել ենք կատարել `v[v.size()]`֊ի հետ վերևում, կձախողվի։ Հետևաբար `catch`- կետը, որն ապահովում է `out_of_range`֊ի համար մշակիչ, կսկսի կատարվել։ `out_of_range` տիպը սահմանված է ստանդարտ գրադարանում (<stdexcept>֊ի մեջ) և փաստացի օգտագործվում է ստանդարտ գրադարանի` կոնտեյներներին դիմող ֆունկցիաների միջոցով։ 

Բացառությունների մշակման մեխանիզմների օգտագործումը կարող է սխալների մշակման գործընթացը դարձնել ավելի պարզ, ավելի համակարգված և ավելի ընթեռնելի։ Այդ նպատակին հասնելու համար պետք չէ չարաշահել `try`֊հրամանները։ Սխալների մշակումը պարզ և համակարգված դարձնելու գլխավոր մեթոդը (որը կոչվում է Resource Aquisition Is Initialization) բացատրված է §4.2.2.-ում։

Այն ֆունկցիան, որը երբեք դուրս չի բերելու որևէ բացառություն կարող է հայտարարվել `noexcept`։ Օրինակ․

````c++
   void user(int sz) noexcept
   {
      Vector v(sz);
      iota(&v[0], &v[sz],1); // լցնել v֊ն 1,2,3,4... ֊ով
   }
````

Եթե բոլոր լավ նպատակներն ու ծրագրերը ձախողվեն, so that user() still throws, այդ դեպքում կանչվում է ստանդարտ գրադարանի `terminate()` ֆունկցիան` ծրագիրն անհապաղ վերջացնելու համար։


### 3.4.2 Ինվարիանտներ

Բացառությունների կիրառումը, որը սահմանից դուրս դիմելու դեպքում տալիս է ազդանշան, մի ֆունկցիայի օրինակ է, որն ստուգում է իր արգումենտը և հրաժարվում է աշխատել, քանի որ հիմնական ենթադրությունը՝ նախապայմանը, չի պահվում։ Մենք պաշտոնապես
նշել ենք `Vector`֊ի ինդեքսավորման օպերատորը, we would have said something like ‘‘the index must be in the [ 0 : siz e() ) range,’’ and that was in fact what we tested in our operator[]() . [`a:b`) գրությունը նշանակում է կիսաբաց շարք, ըստ որի `a`֊ն այդ շարքի մասն է, իսկ `b`֊ն՝ ոչ։ Ամեն անգամ, երբ սահմանում ենք ֆունկցիա, պետք է լավ մտածենք, որոնք են նրա նախապայմանները և հնարավոր է արդյոք դրանք ստուգել։

Ինչևէ, `operator[]()` ֆունկցիան գործում է `Vector` տիպի օբյեկտների հետ and nothing it does makes any sense unless the members of Vector have ‘‘reasonable’’ values. In particular, we did say ‘‘ elem points to an array of sz doubles’’ but we only said that in a comment. Այն արտահայտությունը, որը դասի համար ենթադրվում է, որ պետք է ճիշտ լինի, կոչվում է *դասի ինվարիանտ*, կամ պարզապես *ինվարիանտ*։ Կոնստրուկտորի աշխատանքն է սահմանել ինվարիանտ իր դասի համար (որպեսզի անդամ ֆունկցիաները կարողանան հենվել դրա վրա) և որպեսզի անդամ ֆունկցիաները վստահ լինեն, որ ինվարիանտները մնում են, երբ նրանք ավարտում են իրենց աշխատանքը։ Ցավոք, մեր `Vector` կոնստրուկտորը միայն մասնակի է անում իր աշխատանքը։ Այն ճիշտ ձևով ինիցիալիզացրել է `Vector`֊ի անդամները, բայց չի հաջողվել ստուգել, թե իրեն փոխանցված արգումենտներն իմաստ ունեն թե՞ ոչ։ Դիտարկենք

````c++
   Vector v(-27);
````

դեպքը։ Սա, ամենայն հավանականությամբ կարող է առաջացնել քաոս։

   Այստեղ գրված է ավելի համապատասխան սահմանումը․

````c++
   Vector::Vector(int s)
   {
      if (s < 0)
         throw length_error{};
      elem = new double[s];
      sz = s;
   }
````

Ես օգտագործում եմ ստանդարտ գրադարանի՝ `length_error` բացառությունը, որպեսզի հաղորդեմ տարրերի ոչ դրական քանակ, քանի որ ստանդարտ գարադարանի որոշ գործողություններ կիրառում են այդ բացառությունը՝ այդ տեսակի խնդիրներ հաղորդելու համար։ Եթե `new` օպերատորը չի կարողանում գտնել հիշողության տարածք առանձնացնելու համար, այն դուրս է բերում `std::bad_alloc`։ Այժմ կարող ենք գրել․

````c++
   void test()
   {
      try {
         Vector v(-27);
      }
      catch (std::length_error) {
         // գործածվել է բացասական չափ
      }
      catch (std::bad_alloc) {
         // գործածվել է հիշողության exhaustion
      }
   }
````

Դուք կարող եք սահմանել ձեր սեփական դասերը, որոնք կօգտագործվեն որպես բացառություններ և կիրականացնեն կամայական ինֆորմացիա այն կետից, որտեղ սխալը գտնվել է մինչև այն կետը, որտեղ այն կարող է մշակվել (§3.4.1)։ 

Հաճախ ֆունկցիան ճանապարհ չունի կատարել վերջացնել իրեն հատկացրած խնդիրը բացառության դուրս բերումից հետո։ Այդ դեպքում բացառության «մշակելը» պարզապես նշանակում է կատարել որոշակի փոքրիկ մաքրում (cleanup) և նորից դուրս գրել բացառությունը։ Բացառությունը (նորից) դուրս գրելու համար, որը գտնվել է բացառության մշակիչի կողմից, պարզապես գրում ենք `throw`; Օրինակ․

````c++
   void test()
   {
      try {
               Vector v(-27);
      }
      catch (std::length_error) {
         cout << "test failed: length error\n";
         throw;   // rethrow
      }
      catch (std::bad_alloc){
         // test()֊ը ձևավորված չէ հիշողության արտահոսքը (exhaustion) մշակելու համար
         std::terminate();   // ավարտել ծրագիրը
      }
   }
````

Ինվարիանտների գաղափարը կենտրոնական է դասերի ձևավորման համար, իսկ նախապայմանները նույն դերն են տանում ֆունկցիաների ձևավորման մեջ։ Ինվարիանտները
   * օգնում են մեզ հասկանալ հենց այն, ինչ ուզում ենք
   * ստիպում են մեզ լինել ավելի կոնկրետ, որը մեզ տալիս է հնարավորություն ստանալ ճիշտ կոդ (հարթեցումից (debugging) և տեստավորվումից հետո)։

Ինվարիանտների գաղափարն ընկած է C++ լեզվի ռեսուրսների կառավարման գաղափարների հիմքում, որոնք հենված են կոնստրուկտորների (գլուխ 4) և դեստրուկտորների (§4.2.2, §11.2) վրա։


## 3.4.3 Ստատիկ պնդումներ

Բացառությունները հայտնում են այն սխալների մասին, որոնք գտնվում են ծրագրի կատարման ժամանակ (at run time)։ Եթե սխալը հնարավոր է գտնել կոմպիլյացիայի ժամանակ, ապա սովորաբար նախընտրելի է անել հենց այդպես։ Ահա, թե ինչի համար են համակարգերի տեսակների մեծ մասը և այն գործիքները, որոնք հարմարեցնում են ինտերֆեյսերը օգտագործողի սահմանած տիպերին։ Ինչևէ, մենք կարող ենք ներկայացնել նաև պարզ ստուգումներ ուրիշ հատկությունների վրա նույնպես, որոնք հայտնի են կոմպիլյացիայի ժամանակ և հայտնենք սխալները որպես կոմպիլյացիայի սխալի հաղրդագրություններ։ Օրինակ․

````c++
   static_assert(4 <= sizeof(int)), "ամբողջ փոփոխականները շատ փոքր են"); // ստուգեք ամբողջ տիպի չափը
```` 

Այս պնդումը կգրի `ամբողջ փոփոխականները շատ փոքր են`, եթե չի պահպանվում `4 <= sizeof(int)` պայմանը, սա նշանակում է՝ եթե `int`֊ը այս համակարգում չունի ամենաքիչը 4 բայթ։ Սպասումների այսպիսի հայտարարությունները մենք կոչում ենք *պնդումներ*։

`static_assert` մեխանիզմը կարող է կիրառվել որպես կոնստանտ արտահայտություններ ներկայացրած ցանկացած դեպքերում (§1.7)։ Օրինակ․

````c++
   constexpr double C = 299792.458;      // կմ/վ

   void f(double speed)
   {
      const double local_max = 160.0 / (60*60);   // 160 կմ/վ = 160.0 / (60*60) կմ/վ
      static_assert(speed < C, "հնարավոր չէ գնալ այդքան արագ");   // սխալ․ արագությունը պետք է լինի հաստատուն
      static_assert(local_max < C, "հնարավոր չէ գնալ այդքան արագ");   // ճիշտ է

      //...
   }
````

Ընդհանուր առմամբ `static_assert(A,S)`֊ը տպում է `S`֊ը որպես կոմպիլյացիայի սխալի հաղորդագրություն, եթե `A`֊ն `true` չէ։

`static_assert`֊ի ամենակարևոր կիրառումները գալիս են, երբ մենք անում ենք պնդումներ այն տիպերի մասին, որոնք օգտագործվել են որպես պարամետրեր ընդհանրացված ծրագրավորման մեջ (§5.4, §11.6)։

For runtime-checked assertions, use exceptions.


##3.5 Խորհուրդներ

* Այս գլխի նյութը մոտավորապես համապատասխանում է նրան, ինչ որ ավելի մանրամասնորեն նկարագրված է [Stroustrup,2013] գրքի 13-15 գլուխներում։
* Դրե՛ք տարբերություն հայտարարությունների (որոնք օգտագործվել են որպես ինտերֆեյս) և սահմանումների (որոնք օգտագործվել են որպես իրականացում) միջև; §3.1։
* Օգտագործե՛ք վերնագրային ֆայլեր՝ ինտերֆեյսերը ներկայացնելու և ծրագրի տրամաբանական կառուցվածքն ընդգծելու համար; §3.2։
* `#include` (ներառե՛ք) վերնագրային ֆայլը այն սկզբնական ֆայլի մեջ, որն իրականացնում է իր ֆունկցիաները; §3.2։
* Խուսափե՛ք վերնագրային ֆայլերում ոչ֊ներդրված ֆունկցիաների սահմանումներից; §3.2։
* Օգտագործե՛ք անունների տիրույթներ՝ արտահայտելու համար ծրագրի տրամաբանական կառուցվածքը; §3.3։
* Օգտագործե՛ք `using`֊դիրեկտիվները փոխանցման համար, հիմքային գրադարանների (ինչպիսին է օրինակ `std`֊ն) համար կամ լոկալ տիրույթի ներսում; §3.3։
* Մի՛ տեղադրեք `using`-դիրեկտիվը վերնագրային ֆայլի մեջ; §3.3։
* Դուրս գրե՛ք բացառություններ՝ ցույց տալու համար, որ չեք կարողանում լուծել ձեզ տրամադրված խնդիրը; §3.4։
* Օգտագործե՛ք բացառությունները սխալների մշակման համար; §3.4։
* Զարգացրե՛ք սխալների մշակման ռազմավարությունը ավելի շուտ՝ ծրագրի ձևավորման մեջ; §3.4։
* Օգտագործե՛ք որպես բացառություններ նպատակային ձևավորված օգտագործողի կողմից սահմանված տիպերը (այլ ոչ թե ներդրված տիպերը); §3.4.1։
* Մի՛ փորձեք գտնել բոլոր բացառությունները յուրաքանչյուր ֆունկցիայի մեջ; §3.4։
* Եթե Ձեր ֆունկցիան չի կարող դուրս բերել բացառություններ, հայտարարե՛ք այն որպես `noexcept`; §3.4:
* Թույլ տվեք, որ կոնստրուկտորը հաստատի ինվարիանտը և դուրս բերի այն, եթե չի կարողանում; §3.4.2։
* Ձևավորե՛ք Ձեր սխալների մշակման ռազմավարությունը ինվարիանտների շուրջ; §3.4.2։
* Այն ինչ հնարավոր է ստուգել կոմպիլյացիայի ժամանակ, սովորաբար ամենալավ ձևով ստուգվում է հենց կոմպիլյացիայի ժամանակ (օգտագործելով `static_assert`֊ը); §3.4.3։









   


























