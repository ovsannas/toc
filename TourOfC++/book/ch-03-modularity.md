#Modularity

Don't interrupt me while I'm interrupting.
-Winston S. Churchill

 
* Ներածություն
* Առանձնացված կոմպիլյացիա
* Անվանատարծքներ
* Սխալների մշակում
        Բացառություններ; Ինվարիանտներ; Ստատիկ պնդումներ
* Խորհուրդներ 


## 3.1 Ներածություն 

C++ լեզվով գրված ծրագիրը բաղկացած է բազմաթիվ առանձին կառուցված մասերից, ինչպիսիք են ֆունկցիաները (§1.3), օգտագործողի սահմանած տիպերը (Գլուխ 2), դասերի հիերարխիան (§4.5) և շաբլոնները (Գլուխ 5)։ Այդ բոլոր մասերը կառավարելու հիմքը դրանց միջև փոխազդեցությունների հստակ սահմանումն է։ Առաջին և ամենակարևոր քայլը այդ մասերի ինտերֆեյսի և իրականացման միջև տարբերությունների հաստատումն է։ Լեզվական մակարդակի վրա C++֊ը ինտերֆեյսները ներկայացնում է հայտարարությունների միջոցով։ *Հայտարարությունը* նշում է ֆունկցիայի կամ տիպի օգտագործման համար անհրաժեշտ բոլոր տարրերը։ Օրինակ․

````c++
   double sqrt(double);  // քառակուսի արմատ հաշվող ֆունկցիան ստանում է double տիպի արժեք և վերադարձնում է նույնպես double
````

````c++
   class Vector {
   public:
       Vector(int s);
       double& operator[](int i);
       int size();
   private:
       double* elem;      // elem֊ը ցույց է տալիս sz քանակի double արժեքներով զանգվածի վրա
       int sz;
   };
````

Այստեղ կարևորն այն է, որ ֆունկցիաների մարմինները՝ *սահմանումները*, «այլ տեղում» են։ Այս օրինակում `Vector`֊ի ներկայացումը նույնպես կարող էր լինել «այլ տեղ», բայց մենք դեռ կանդրադառնանք դրան հետագայում (Աբստրակտ տիպեր; §4.3)։ `sqrt()`֊ի սահմանումը կունենա հետևյալ տեսքը․

````c++
   double sqrt(double d)         // sqrt()֊ի սահմանումը
   { 
         // մաթեմատիկայի տետրում գրված ալգորիթմը
   }
````

`Vector`֊ի համար մենք պետք է սահմանենք բոլոր երեք անդամ ֆունկցիաները․

````c++
   Vector::Vector(int s)         //կոնստրուկտորի սահմանումը
       :elem{new double[s]}, sz{s}
   {
   }

   double& Vector::operator[] (int i)      //ինդեքսավորման օպերատորի սահմանումը
   {
       return elem[i];
   }

   int Vector::size()          //size()֊ի սահմանումը
   {
       return sz;
   }
````

Մենք պետք է սահմանենք `Vector`֊ի ֆունկցիաները, բայց ոչ sqrt() ֆունկցիան, քանի որ այն ստանդարտ գրադարանից է։ Ինչևէ, այստեղ մեծ տարբերություն չկա: Գրադարանը պարզապես մեկ այլ կոդ է, գրված մեր օգտագործած լեզվի միջոցներով, որը մենք որոշել ենք օգտագործել։


## 3.2 Առանձնացված կոմպիլյացիա

C++ լեզուն օգտագործում է առանձնացված կոմպիլյացիայի հասկացությունը, որտեղ օգտագործողի կոդը տեսնում է միայն օգտագործված տիպերի և ֆունկցիաների հայտարարությունները։ Այդ տիպերի և ֆունկցիաների սահմանումները գտնվում են այլ սկզբնային ֆայլերում և կոմպիլացվում են առանձին։ Սա կարելի է օգտագործել կիսաանկախ կոդի հատվածների բազմության մեջ ծրագիր կազմակերպելու համար։ Այսպիսի առանձնացումը կարող է օգտագործվել կոմպիլյացիայի ժամանակը մինիմալի հասցնելու համար և ծրագիրը խստորեն տրամաբանական մասերի բաժանելու համար (որը մինիմալի է հասցնում սխալների հավանականությունը)։ Գրադարանը հաճախ առանձին կոմպիլացված կոդերի (օր․ ֆունցիաների) հավաքածու է։

Սովորաբար հայտարարությունները, որոնք ցույց են տալիս ինտերֆեյսը, տեղադրում ենք դրանց նախատեսվող օգտագործումը նկարագրող անվամբ ֆայլի՝ մոդուլի մեջ։ Օրինակ․

````c++
   // Vector.h:

   class Vector {
   public:
       Vector(int s); 
       double& operator[](int i);
       int size();
   private:
       double* elem;         // elem֊ը ցույց է տալիս double տիպի sz տարրերի զանգվածի վրա
       int sz;
   };
````

Այս հայտարարությունը ենթադրվում է, որ պետք է տեղադրվի `Vector.h` ֆայլում, և օգտագործողները պետք է *ներառեն* այդ, *վերնագրային* կոչվող ֆայլը, որպեսզի տվյալ ինտերֆեյսը հասանելի լինի։ Օրինակ․


````c++որը որոշել ենք օգտագործել  
   // user.cpp:


   #include "Vector.h"         // ստանում ենք Vector֊ի ինտերֆեյսը
   #include <cmath>          // ստանում ենք ստանդարտ գրադարանի մաթեմատիկական ֆունկցիաների ինտերֆեյսը՝ ներառյալ sqrt() ֆունկցիայինը

   using namespace std;      // std անդամները դարձնում ենք տեսանելի (§3.3)

   double sqrt_sum(Vector& v)
   {
       double sum = 0;
       for (int i = 0; i != v.size(); ++i)
           sum += sqrt(v[i]);      // քառակուսի արմատների գումարը
       return sum;
   }
````

Որպեսզի օգնենք կոմպիլյատորին ապահովելու կայունություն, `Vector`֊ի իրականացումն ապահովող `.cpp` ֆայլը նույնպես պետք է ներառի նրա ինտերֆեյսն ապահովող `.h` ֆայլը․


````c++
   // Vector.cpp:

   #include "Vector.h"   // ստանում ենք ինտերֆեյսը

   Vector::Vector (int s)
                 :elem {new double[s]}, sz{s}       // ինիցիալիզացնում ենք անդամները
   {
   }

   double& Vector::operator[] (int i)
   {
            return elem[i];
   }

   int Vector::size()
   {
             return sz;
   }
````

`user.cpp` և `Vector.cpp` ֆայլերի կոդերը կիսում են `Vector.h` ֆայլում ներկայացված `Vector`֊ի ինտերֆեյսի ինֆորմացիան, բայց նաև այդ երկու ֆայլերը իրարից անկախ են և կարող են կոմպիլյացվել առանձին։ Գրաֆիկորեն ծրագրի մասերը կարող են ներկայացվել հետևյալ ձևով․

նկար գլուխ 3.2


## 3.3 Անվանատարծքներ

Որպես լրացում ֆունկցիաներին (§1.4), դասերին (§2.3) և թվարկումներին (§2.5), C++ լեզուն առաջարկում է նաև *անվանատարածքներ* as a
mechanism for expressing that some declarations belong together and that their names shouldn’t clash with other names. For example, I might want to experiment with my own complex number type (§4.2.1, §12.4):


````c++
   namespace My_code {
             class complex {
                      // ...
             };

             complex sqrt(complex);
             // ...

             int main();
   {

   int My_code::main()
   {
           complex z{1,2};
           auto z2 = sqrt(z);
            std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
            // ...
};
````


Տեղադրելով իմ կոդը `My_code` անվանատարածքի մեջ, ես վստահ եմ լինում, որ իմ անունները կոնֆլիկտի մեջ չեն մտնում ստանդարտ գրադարանի անունների հետ, որոնք գտնվում են `std` անվանատարածքում (§3.3)։ Նախազգուշացումը խոհեմ է, որովհետև ստանդարտ գրադարանը տրամադրում է աջակցություն `complex` թվերի թվաբանության համար (§4.2.1, §12.4)։ 

Մեկ այլ անունների տիրույթում գտնվող անվանը հասնելու ամենապարզ ճանապարհը նրան անվանատարածքի անվան հետ սահմանելն է (օր․ `std::cout` և `My_code::main`)։ «Իրական `main()֊ը`» սահմանված է անունների գլոբալ տիրույթում, այսինքն not local to a defined namespace, class, or function։ Որպեսզի ստանանք դիմելու կարողություն ստանդարտ գրադարանի անվանատարածքի անուններին, մենք կարող ենք օգտագործել `using`- դիրեկտիվը․

````c++
   using namespace std;
````


`using`֊ դիրեկտիվը անվանված անունների տիրույթի անունները դարձնում է հասանելի, կարծես թե նրանք լոկալ են տեսանելիության այն տիրույթում, որտեղ, որ տեղադրել ենք դիրեկտիվը։ Այսպիսով `std` անվանատարածքի համար `using` - դիրեկտիվն օգտագործելուց հետո, մենք կարող ենք ուղղղակի գրել `cout` քան թե `std::std`։

Անունների տիրույթները հիմնականում օգտագործվում են ծրագրային ավելի մեծ բաղկացուցիչներ (կոմպոնենտներ ?) ստեղծելու համար, ինչպիսիք են օրինակ գրադարանները։ Նրանք պարզեցնում են ծրագրի կազմությունը՝ բաժանելով այն առանձին կազմված մասերի։


## 3.4  Սխալների մշակում

Սխալների մշակումը մտահոգություններով և ճյուղավորումներով մի մեծ և համախմբված նյութ է, որը գնում է հեռու լեզվի հնարավորություններից դուրս դեպի ծրագրավորման տեխնիկան և գործիքները։ Ինչևէ, C++ լեզուն ապահովում է որոշ գործիքներ օգնության համար։ Գլխավոր գործիքը հենց ինքը համակարգն է: Քրտնաջան ձևով ներդրված տիպերով (օր․ `char`, `int`, և `double`) և հրամաններով (օր․ `if`, `while` և `for`) ծրագրեր կազմելու փոխարեն մենք կառուցում ենք մեր ծրագրերի համար հարմար տիպեր (օր․ `string`, `map` և `regex`) և ալգորիթմներ (օր․ `sort()`, `find_if()` և `draw_all()`): Այսպիսի բարձր մակարդակի կառուցվածքը պարզեցնում է մեր ծրագրավորումը, սահմանափակում է մեր՝ սխալների հնարավորությունները (օր․ e.g., you are unlikely to try to apply a tree traversal to a dialog box) և մեծացնում է կոմպիլյատորի հնարավորությունները սխալներ գտնելու մեջ։ C++ լեզվի կառուցվածքների մեծամասնությունը նվիրված է էլեգանտ և որակյալ աբստրակցիաների մեխանիզմների ձևավորմանը և իրագործմանը (օր․ օգտագործողի սահմանած տիպերը և դրանք կիրառող ալգորիթմները)։ Այս մոդուլյարության և աբստրակցիայի էֆեկտներից մեկն այն է, (մասնավորապես գրադարանների կիրառումը) որ այն կետը, որտեղ run-time սխալը կարող է գտնվել առանձին է այն կետից, որտեղ այն կարող է մշակվել։ Քանի որ ծրագրերը մեծանում են, և հատկապես երբ գրադարանները ավելի լայնորեն են կիրառվում, սխալների մշակման ստանդարտները դառնում են կարևոր։ Լավ գաղափար է ձևավորել և հստակեցնել սխալների մշակման ստրատեգիա  ծրագրերի մշակման մեջ ավելի վաղ։ 

### 3.4.1 Բացառություններ

Դիտարկենք նորից `Vector` դասի օրինակը։ Ի՞նչ *կլինի*, երբ փորձենք դիմել այն տարրին, որը §2.3֊ի վեկտորի համար դուրս է սահմաններից։ 
* `Vector` դասի ստեղծողը չգիտի, թե ինչպես կվարվի օգտագործողը նման իրավիճակում (վեկտորն ստեղծողը սովորաբար նույնիսկ չգիտի էլ, թե որ ծրագրում է վեկտորն աշխատելու)։
* Համապատասխանորեն `Vector` դասի օգտագործողը չի կարող հայտնաբերել տվյալ խնդիրը (եթե օգտագործողը կարողանար, սահմանից դուրս դիմումը տեղի չէր ունենա առաջին տեղում)։

Լուծումը հետևյալն է, որ `Vector`֊ը իրականացնողը հայտնաբերի զանգվածի սահմանից դուրս դիմումը և տեղեկացնի օգտագործողին դրա մասին։ Օգտագործողը դրանից հետո կարող է կատարել համապատասխան գործողությունը։ Օրինակ, `Vector::operator[]()` ֆունկցիան կարող է հայտնաբերել փորձված դիմումը շարքից դուրս և դուրս բերել (throw) `out_of_range` բացառությունը․

````c++
   double& Vector::operator[] (int i)
   {
         if (i < 0 || size() <= i)
               throw out_of_range{"Vector::operator[]"};
         return elem[i];
   }
````

`throw` փոխանցումները վերահսկում են `out_of_range` տիպի բացառությունների մշակիչին (handler) այնպիսի ֆունկցիաների մեջ, որոնք ուղղակիորեն կամ անուղղակիորեն կոչվում են `Vector::operator[]()`։ To do that, the implementation will unwind the function call stack as needed to get back to the context of that caller. That is, the exception handling mechanism will exit scopes and function as needed to get back to a caller that has expressed
interest in handling that kind of exception, invoking destructors (§4.2.2) along the way as needed.
For example:

````c++
   void f(Vector& v)
   {
      // ...
      try { // այստեղ բացառությունները մշակվում են ներքևում սահմանված մշակիչի միջոցով

             v[v.size()] = 7;   // փորձել դիմել v֊ից դուրս
      }
      catch (out_of_range) { // oops: out_of_range error
             // ... մշակել սահմաններից դուրս սխալը ...
      }
      // ...
   }
````

Բացառությունների մշակման համար մեր նախատեսած կոդը տեղադրում ենք `try`-բլոկում։ Հավասարությունը, որը փորձել ենք կատարել `v[v.size()]`֊ի հետ վերևում, կձախողվի։ Հետևաբար `catch`- կետը, որն ապահովում է `out_of_range`֊ի համար մշակիչ, կսկսի կատարվել։ `out_of_range` տիպը սահմանված է ստանդարտ գրադարանում (<stdexcept>֊ի մեջ) և փաստացի օգտագործվում է ստանդարտ գրադարանի` կոնտեյներներին դիմող ֆունկցիաների միջոցով։ 

Բացառությունների մշակման մեխանիզմների օգտագործումը կարող է սխալների մշակման գործընթացը դարձնել ավելի պարզ, ավելի համակարգված և ավելի ընթեռնելի։ Այդ նպատակին հասնելու համար պետք չէ չարաշահել `try`֊հրամանները։ Սխալների մշակումը պարզ և համակարգված դարձնելու գլխավոր մեթոդը (որը կոչվում է Resource Aquisition Is Initialization) բացատրված է §4.2.2.-ում։

Այն ֆունկցիան, որը երբեք դուրս չի բերելու որևէ բացառություն կարող է հայտարարվել `noexcept`։ Օրինակ․

````c++
   void user(int sz) noexcept
   {
      Vector v(sz);
      iota(&v[0], &v[sz],1); // լցնել v֊ն 1,2,3,4... ֊ով
   }
````

Եթե բոլոր լավ նպատակներն ու ծրագրերը ձախողվեն, so that user() still throws, այդ դեպքում կանչվում է ստանդարտ գրադարանի `terminate()` ֆունկցիան` ծրագիրն անհապաղ վերջացնելու համար։


### 3.4.2 Ինվարիանտներ

Բացառությունների կիրառումը, որը սահմանից դուրս դիմելու դեպքում տալիս է ազդանշան, մի ֆունկցիայի օրինակ է, որն ստուգում է իր արգումենտը և հրաժարվում է աշխատել, քանի որ հիմնական ենթադրությունը՝ նախապայմանը, չի պահվում։ Մենք պաշտոնապես
նշել ենք `Vector`֊ի ինդեքսավորման օպերատորը, we would have said something like ‘‘the index must be in the [ 0 : siz e() ) range,’’ and that was in fact what we tested in our operator[]() . [`a:b`) գրությունը նշանակում է կիսաբաց շարք, ըստ որի `a`֊ն այդ շարքի մասն է, իսկ `b`֊ն՝ ոչ։ Ամեն անգամ, երբ սահմանում ենք ֆունկցիա, պետք է լավ մտածենք, որոնք են նրա նախապայմանները և հնարավոր է արդյոք դրանք ստուգել։

Ինչևէ, `operator[]()` ֆունկցիան գործում է `Vector` տիպի օբյեկտների հետ and nothing it does makes any sense unless the members of Vector have ‘‘reasonable’’ values. In particular, we did say ‘‘ elem points to an array of sz doubles’’ but we only said that in a comment. Այն արտահայտությունը, որը դասի համար ենթադրվում է, որ պետք է ճիշտ լինի, կոչվում է *դասի ինվարիանտ*, կամ պարզապես *ինվարիանտ*։ Կոնստրուկտորի աշխատանքն է սահմանել ինվարիանտ իր դասի համար (որպեսզի անդամ ֆունկցիաները կարողանան հենվել դրա վրա) և որպեսզի անդամ ֆունկցիաները վստահ լինեն, որ ինվարիանտները մնում են, երբ նրանք ավարտում են իրենց աշխատանքը։ Ցավոք, մեր `Vector` կոնստրուկտորը միայն մասնակի է անում իր աշխատանքը։ Այն ճիշտ ձևով ինիցիալիզացրել է `Vector`֊ի անդամները, բայց չի հաջողվել ստուգել, թե իրեն փոխանցված արգումենտներն իմաստ ունեն թե՞ ոչ։ Դիտարկենք

````c++
   Vector v(-27);
````

դեպքը։ Սա, ամենայն հավանականությամբ կարող է առաջացնել քաոս։

   Այստեղ գրված է ավելի համապատասխան սահմանումը․

````c++
   Vector::Vector(int s)
   {
      if (s < 0)
         throw length_error{};
      elem = new double[s];
      sz = s;
   }
````

Ես օգտագործում եմ ստանդարտ գրադարանի՝ `length_error` բացառությունը, որպեսզի հաղորդեմ տարրերի ոչ դրական քանակ, քանի որ ստանդարտ գարադարանի որոշ գործողություններ կիրառում են այդ բացառությունը՝ այդ տեսակի խնդիրներ հաղորդելու համար։ Եթե `new` օպերատորը չի կարողանում գտնել հիշողության տարածք առանձնացնելու համար, այն դուրս է բերում `std::bad_alloc`։ Այժմ կարող ենք գրել․

````c++
   void test()
   {
      try {
         Vector v(-27);
      }
      catch (std::length_error) {
         // գործածվել է բացասական չափ
      }
      catch (std::bad_alloc) {
         // գործածվել է հիշողության exhaustion
      }
   }
````

Դուք կարող եք սահմանել ձեր սեփական դասերը, որոնք կօգտագործվեն որպես բացառություններ և կիրականացնեն կամայական ինֆորմացիա այն կետից, որտեղ սխալը գտնվել է մինչև այն կետը, որտեղ այն կարող է մշակվել (§3.4.1)։ 

Հաճախ ֆունկցիան ճանապարհ չունի կատարել վերջացնել իրեն հատկացրած խնդիրը բացառության դուրս բերումից հետո։ Այդ դեպքում բացառության «մշակելը» պարզապես նշանակում է կատարել որոշակի փոքրիկ մաքրում (cleanup) և նորից դուրս գրել բացառությունը։ Բացառությունը (նորից) դուրս գրելու համար, որը գտնվել է բացառության մշակիչի կողմից, պարզապես գրում ենք `throw`; Օրինակ․

````c++
   void test()
   {
      try {
               Vector v(-27);
      }
      catch (std::length_error) {
         cout << "test failed: length error\n";
         throw;   // rethrow
      }
      catch (std::bad_alloc){
         // test()֊ը ձևավորված չէ հիշողության արտահոսքը (exhaustion) մշակելու համար
         std::terminate();   // ավարտել ծրագիրը
      }
   }
````

Ինվարիանտների գաղափարը կենտրոնական է դասերի ձևավորման համար, իսկ նախապայմանները նույն դերն են տանում ֆունկցիաների ձևավորման մեջ։ Ինվարիանտները
   * օգնում են մեզ հասկանալ հենց այն, ինչ ուզում ենք
   * ստիպում են մեզ լինել ավելի կոնկրետ, որը մեզ տալիս է հնարավորություն ստանալ ճիշտ կոդ (հարթեցումից (debugging) և տեստավորվումից հետո)։

Ինվարիանտների գաղափարն ընկած է C++ լեզվի ռեսուրսների կառավարման գաղափարների հիմքում, որոնք հենված են կոնստրուկտորների (գլուխ 4) և դեստրուկտորների (§4.2.2, §11.2) վրա։


## 3.4.3 Ստատիկ պնդումներ

Բացառությունները հայտնում են այն սխալների մասին, որոնք գտնվում են ծրագրի կատարման ժամանակ (at run time)։ Եթե սխալը հնարավոր է գտնել կոմպիլյացիայի ժամանակ, ապա սովորաբար նախընտրելի է անել հենց այդպես։ Ահա, թե ինչի համար են համակարգերի տեսակների մեծ մասը և այն գործիքները, որոնք հարմարեցնում են ինտերֆեյսերը օգտագործողի սահմանած տիպերին։ Ինչևէ, մենք կարող ենք ներկայացնել նաև պարզ ստուգումներ ուրիշ հատկությունների վրա նույնպես, որոնք հայտնի են կոմպիլյացիայի ժամանակ և հայտնենք սխալները որպես կոմպիլյացիայի սխալի հաղրդագրություններ։ Օրինակ․

````c++
   static_assert(4 <= sizeof(int)), "ամբողջ փոփոխականները շատ փոքր են"); // ստուգեք ամբողջ տիպի չափը
```` 

Այս պնդումը կգրի `ամբողջ փոփոխականները շատ փոքր են`, եթե չի պահպանվում `4 <= sizeof(int)` պայմանը, սա նշանակում է՝ եթե `int`֊ը այս համակարգում չունի ամենաքիչը 4 բայթ։ Սպասումների այսպիսի հայտարարությունները մենք կոչում ենք *պնդումներ*։

`static_assert` մեխանիզմը կարող է կիրառվել 








   


























