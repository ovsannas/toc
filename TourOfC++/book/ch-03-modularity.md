#Modularity

Don't interrupt me while I'm interrupting.
-Winston S. Churchill

 
* Ներածություն
* Առանձնացված կոմպիլյացիա
* Անվանատարծքներ
* Սխալների մշակում
        Բացառություններ; Invariants; Ստատիկ պնդումներ
* Խորհուրդներ 


## 3.1 Ներածություն

C++ լեզվով գրված ծրագիրը բաղկացած է առանձին կառուցված մասերից, ինչպիսիք են օրինակ ֆունկցիաները (§1.3), օգտագործողի սահմանած տիպերը (Գլուխ 2), դասերի հիերարխիան (§4.5) և շաբլոնները (Գլուխ 5)։ Այդ ամենը ղեկավարելու բանալին այդ մասերի միջև փոխազդեցությունների հստակ սահմանումն է։ Առաջին և ամենակարևոր քայլը տարբերումն է (առանձնացումն է) այդ մասի ինտերֆեյսի և նրա իրականացման միջև։ Լեզվի մակարդակի վրա C++ լեզուն ներկայացնում է ինտերֆեյսերը հայտարարությունների միջոցով։ *Հայտարարությունը* նշում է ֆունկցիայի կամ տիպի օգտագործման համար անհրաժեշտ բոլոր տարրերը։ Օրինակ․

````c++
   double sqrt(double);      // քառակուսի արմատ հաշվող ֆունկցիան ստանում է double արժեք և վերադարձնում է double արժեք
````

````c++
   class Vector {
   public:
            Vector(int s);
             double& operator[](int i);
             int size();
   private:
             double* elem;      // elem֊ը ցույց է տալիս sz double արժեքներով զանգվածի վրա
};
````

Կարևոր կետն այստեղ այն է, որ ֆունկցիաների մարմինները, սահմանումները այլ տեղում են։ For this example, we might like for the representation of Vector to be ‘‘elsewhere’’ also, but we will deal
with that later (abstract types; §4.3). `sqrt()`֊ի սահմանումը կունենա հետևյալ տեսքը․

````c++
   double sqrt(double d)         // sqrt()֊ի սահմանումը
   { 
         // մաթեմատիկայի տետրում գրված ալգորիթմը
   }
````

`Vector`֊ի համար մենք պետք է սահմանենք բոլոր երեք անդամ ֆունկցիաները․

````c++
   Vector::Vector(int s)         //կոնստրուկտորի սահմանումը
         :elem{new double[s]}, sz{s}
   {
   }

   double& Vector::operator[] (int i)      //subscripting սահմանումը
   {
         return elem[i];
   }

   int Vector::size()          //size()֊ի սահմանումը
   {
         return sz;
   }
````

Մենք պետք է սահմանենք `Vector`֊ի ֆունկցիաները , բայց sqrt() ֆունկցիան՝ ոչ, որովհետև այն ստանդարտ գրադարանի մասն է (ֆունկցիաներից է?)։ Ինչևէ, այստեղ մեծ տարբերություն չկա: գրադարանը պարզապես մեկ այլ կոդ է, որը որոշել ենք օգտագործել՝ գրված լեզվի նույն գործիքներով, որոնք ինքներս ենք օգտագործում։


## 3.2 Առանձնացված կոմպիլյացիա

C++ լեզուն օգտագործում է առանձնացված կոմպիլյացիայի հասկացությունը, որտեղ օգտագործողի կոդը տեսնում է օգտագործված տիպերի և ֆունկցիաների հայտարարությունները միայն։ Այդ տիպերի և ֆունկցիաների սահմանումները գտնվում են այլ սկզբնային ֆայլերում և առանձին են կոմպիլացվում։ This can be used to organize a program into a set of semi-independent code fragments. Այսպիսի առանձնացումը կարող է օգտագործվել կոմպիլյացիայի ժամանակը մինիմալի հասցնելու համար և խստորեն կիրառելու համար ծրագիրը տրամաբանական մասերի բաժանումը (որը մինիմալի է հասցնում սխալների հավանականությունը)։ Գրադարանը հաճախ առանձին կոմպիլացված կոդերի (օր․ ֆունցիաների) հավաքածու է։

Սովորաբար հայտարարությունները, որոնք ցույց են տալիս ինտերֆեյսը, տեղադրում ենք ֆայլի՝ դրանց նախատեսվող օգտագործումը նշող անվամբ մոդուլի մեջ։ Օրինակ․

````c++
   // Vector.h:

   class Vector {
   public:
            Vector(int s);
            double& operator[](int i);
            int size();
   private:
            double* elem;         // elem֊ը ցույց է տալիս double տիպի sz տարրերի զանգվածի վրա
            int sz;
   };
````

Այս հայտարարությունը ենթադրվում է, որ պետք է տեղադրվի `Vector.h` ֆայլում, և օգտագործողները պետք է *ներառեն* այդ, *վերնագրային* կոչվող ֆայլը, որպեսզի տվյալ ինտերֆեյսը հասանելի լինի։ Օրինակ․


````c++
   // user.cpp:


   #include "Vector.h"         // ստանում ենք Vector֊ի ինտերֆեյսը
   #include <cmath>          // ստանում ենք ստանդարտ գրադարանի մաթեմատիկական ֆունկցիաների ինտերֆեյսը՝ ներառյալ sqrt() ֆունկցիայինը

   using namespace std;      // std անդամները դարձնում ենք տեսանելի (§3.3)

   double sqrt_sum(Vector& v)
   {
         double sum = 0;
         for (int i = 0; i != v.size(); ++i)
                  sum += sqrt(v[i]);      // քառակուսի արմատների գումարը
          return sum;
   }
````

Որպեսզի օգնենք կոմպիլյատորին ապահովելու կայունություն, `Vector`֊ի իրականացումն ապահովող `.cpp` ֆայլը նույնպես պետք է ներառի նրա ինտերֆեյսն ապահովող `.h` ֆայլը․


````c++
   // Vector.cpp:

   #include "Vector.h"   // ստանում ենք ինտերֆեյսը

   Vector::Vector (int s)
                 :elem {new double[s]}, sz{s}       // ինիցիալիզացնում ենք անդամները
   {
   }

   double& Vector::operator[] (int i)
   {
            return elem[i];
   }

   int Vector::size()
   {
             return sz;
   }
````

`user.cpp` և `Vector.cpp` ֆայլերի կոդերը կիսում են `Vector.h` ֆայլում ներկայացված `Vector`֊ի ինտերֆեյսի ինֆորմացիան, բայց նաև այդ երկու ֆայլերը իրարից անկախ են և կարող են կոմպիլյացվել առանձին։ Գրաֆիկորեն ծրագրի մասերը կարող են ներկայացվել հետևյալ ձևով․

նկար գլուխ 3.2


## 3.3 Անվանատարծքներ


Որպես լրացում ֆունկցիաներին (§1.4), դասերին (§2.3) և թվարկումներին (§2.5), C++ լեզուն առաջարկում է նաև *անվանատարածքներ* as a
mechanism for expressing that some declarations belong together and that their names shouldn’t clash with other names. For example, I might want to experiment with my own complex number type (§4.2.1, §12.4):


````c++
   namespace My_code {
             class complex {
                      // ...
             };

             complex sqrt(complex);
             // ...

             int main();
   {

   int My_code::main()
   {
           complex z{1,2};
           auto z2 = sqrt(z);
            std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
            // ...
};
````


Տեղադրելով իմ կոդը `My_code` անվանատարածքի մեջ, ես վստահ եմ լինում, որ իմ անունները կոնֆլիկտի մեջ չեն մտնում ստանդարտ գրադարանի անունների հետ, որոնք գտնվում են `std` անվանատարածքում (§3.3)։ Նախազգուշացումը խոհեմ է, որովհետև ստանդարտ գրադարանը տրամադրում է աջակցություն `complex` թվերի թվաբանության համար (§4.2.1, §12.4)։ 

Մեկ այլ անունների տիրույթում գտնվող անվանը հասնելու ամենապարզ ճանապարհը նրան անվանատարածքի անվան հետ սահմանելն է (օր․ `std::cout` և `My_code::main`)։ «Իրական `main()֊ը`» սահմանված է անունների գլոբալ տիրույթում, այսինքն not local to a defined namespace, class, or function։ Որպեսզի ստանանք դիմելու կարողություն ստանդարտ գրադարանի անվանատարածքի անուններին, մենք կարող ենք օգտագործել `using`- դիրեկտիվը․

````c++
   using namespace std;
````


`using`֊ դիրեկտիվը անվանված անունների տիրույթի անունները դարձնում է հասանելի, կարծես թե նրանք լոկալ են տեսանելիության այն տիրույթում, որտեղ, որ տեղադրել ենք դիրեկտիվը։ Այսպիսով `std` անվանատարածքի համար `using` - դիրեկտիվն օգտագործելուց հետո, մենք կարող ենք ուղղղակի գրել `cout` քան թե `std::std`։

Անունների տիրույթները հիմնականում օգտագործվում են ծրագրային ավելի մեծ բաղկացուցիչներ (կոմպոնենտներ ?) ստեղծելու համար, ինչպիսիք են օրինակ գրադարանները։ Նրանք պարզեցնում են ծրագրի կազմությունը՝ բաժանելով այն առանձին կազմված մասերի։


## 3.4  Սխալների մշակում


Սխալների մշակումը մտահոգություններով և ճյուղավորումներով մի մեծ և համախմբված նյութ է, որը գնում է հեռու լեզվի հնարավորություններից դուրս դեպի ծրագրավորման տեխնիկան և գործիքները։ Ինչևէ, C++ լեզուն ապահովում է որոշ գործիքներ օգնության համար։ Գլխավոր գործիքը հենց ինքը համակարգն է: Քրտնաջան ձևով ներդրված տիպերով (օր․ `char`, `int`, և `double`) և հրամաններով (օր․ `if`, `while` և `for`) ծրագրեր կազմելու փոխարեն մենք կառուցում ենք մեր ծրագրերի համար հարմար տիպեր (օր․ `string`, `map` և `regex`) և ալգորիթմներ (օր․ `sort()`, `find_if()` և `draw_all()`): Այսպիսի բարձր մակարդակի կառուցվածքը պարզեցնում է մեր ծրագրավորումը, սահմանափակում է մեր՝ սխալների հնարավորությունները (օր․ e.g., you are unlikely to try to apply a tree traversal to a dialog box) և մեծացնում է կոմպիլյատորի հնարավորությունները սխալներ գտնելու մեջ։ C++ լեզվի կառուցվածքների մեծամասնությունը նվիրված է էլեգանտ և որակյալ աբստրակցիաների մեխանիզմների ձևավորմանը և իրագործմանը (օր․ օգտագործողի սահմանած տիպերը և դրանք կիրառող ալգորիթմները)։ Այս մոդուլյարության և աբստրակցիայի էֆեկտներից մեկն այն է, (մասնավորապես գրադարանների կիրառումը) որ այն կետը, որտեղ run-time սխալը կարող է գտնվել առանձին է այն կետից, որտեղ այն կարող է մշակվել։ Քանի որ ծրագրերը մեծանում են, և հատկապես երբ գրադարանները ավելի լայնորեն են կիրառվում, սխալների մշակման ստանդարտները դառնում են կարևոր։ Լավ գաղափար է ձևավորել և հստակեցնել սխալների մշակման ստրատեգիա  ծրագրերի մշակման մեջ ավելի վաղ։ 


### 3.4.1 Բացառություններ



















