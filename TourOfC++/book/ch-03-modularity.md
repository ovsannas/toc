#Modularity

Don't interrupt me while I'm interrupting.
-Winston S. Churchill

 
* Ներածություն
* Առանձնացված կոմպիլյացիա
* Անվանատարծքներ
* Սխալների մշակում
        Բացառություններ; Ինվարիանտներ; Ստատիկ պնդումներ
* Խորհուրդներ 


## 3.1 Ներածություն 

C++ լեզվով գրված ծրագիրը բաղկացած է բազմաթիվ առանձին կառուցված մասերից, ինչպիսիք են ֆունկցիաները (§1.3), օգտագործողի սահմանած տիպերը (Գլուխ 2), դասերի հիերարխիան (§4.5) և շաբլոնները (Գլուխ 5)։ Այդ բոլոր մասերը կառավարելու հիմքը դրանց միջև փոխազդեցությունների հստակ սահմանումն է։ Առաջին և ամենակարևոր քայլը այդ մասերի ինտերֆեյսի և իրականացման միջև տարբերությունների հաստատումն է։ Լեզվական մակարդակի վրա C++֊ը ինտերֆեյսները ներկայացնում է հայտարարությունների միջոցով։ *Հայտարարությունը* նշում է ֆունկցիայի կամ տիպի օգտագործման համար անհրաժեշտ բոլոր տարրերը։ Օրինակ․

````c++
   double sqrt(double);  // քառակուսի արմատ հաշվող ֆունկցիան ստանում է double տիպի արժեք և վերադարձնում է նույնպես double
````

````c++
   class Vector {
   public:
       Vector(int s);
       double& operator[](int i);
       int size();
   private:
       double* elem;      // elem֊ը ցույց է տալիս sz քանակի double արժեքներով զանգվածի վրա
       int sz;
   };
````

Այստեղ կարևորն այն է, որ ֆունկցիաների մարմինները՝ *սահմանումները*, «այլ տեղում» են։ Այս օրինակում `Vector`֊ի ներկայացումը նույնպես կարող էր լինել «այլ տեղ», բայց մենք դեռ կանդրադառնանք դրան հետագայում (Աբստրակտ տիպեր; §4.3)։ `sqrt()`֊ի սահմանումը կունենա հետևյալ տեսքը․

````c++
   double sqrt(double d)         // sqrt()֊ի սահմանումը
   { 
         // մաթեմատիկայի տետրում գրված ալգորիթմը
   }
````

`Vector`֊ի համար մենք պետք է սահմանենք բոլոր երեք անդամ ֆունկցիաները․

````c++
   Vector::Vector(int s)         //կոնստրուկտորի սահմանումը
       :elem{new double[s]}, sz{s}
   {
   }

   double& Vector::operator[] (int i)      //ինդեքսավորման օպերատորի սահմանումը
   {
       return elem[i];
   }

   int Vector::size()          //size()֊ի սահմանումը
   {
       return sz;
   }
````

Մենք պետք է սահմանենք `Vector`֊ի ֆունկցիաները, բայց ոչ sqrt() ֆունկցիան, քանի որ այն ստանդարտ գրադարանից է։ Ինչևէ, այստեղ մեծ տարբերություն չկա: Գրադարանը պարզապես մեկ այլ կոդ է, գրված մեր օգտագործած լեզվի միջոցներով, որը մենք որոշել ենք օգտագործել։


## 3.2 Առանձնացված կոմպիլյացիա

C++ լեզուն օգտագործում է առանձնացված կոմպիլյացիայի հասկացությունը, որտեղ օգտագործողի կոդը տեսնում է միայն օգտագործված տիպերի և ֆունկցիաների հայտարարությունները։ Այդ տիպերի և ֆունկցիաների սահմանումները գտնվում են այլ սկզբնային ֆայլերում և կոմպիլացվում են առանձին։ Սա կարելի է օգտագործել կիսաանկախ կոդի հատվածների բազմության մեջ ծրագիր կազմակերպելու համար։ Այսպիսի առանձնացումը կարող է օգտագործվել կոմպիլյացիայի ժամանակը մինիմալի հասցնելու համար և ծրագիրը խստորեն տրամաբանական մասերի բաժանելու համար (որը մինիմալի է հասցնում սխալների հավանականությունը)։ Գրադարանը հաճախ առանձին կոմպիլացված կոդերի (օր․ ֆունցիաների) հավաքածու է։

Սովորաբար հայտարարությունները, որոնք ցույց են տալիս ինտերֆեյսը, տեղադրում ենք դրանց նախատեսվող օգտագործումը նկարագրող անվամբ ֆայլի՝ մոդուլի մեջ։ Օրինակ․

````c++
   // Vector.h:

   class Vector {
   public:
       Vector(int s); 
       double& operator[](int i);
       int size();
   private:
       double* elem;         // elem֊ը ցույց է տալիս double տիպի sz տարրերի զանգվածի վրա
       int sz;
   };
````

Այս հայտարարությունը ենթադրվում է, որ պետք է տեղադրվի `Vector.h` ֆայլում, և օգտագործողները պետք է *ներառեն* այդ, *վերնագրային* կոչվող ֆայլը, որպեսզի տվյալ ինտերֆեյսը հասանելի լինի։ Օրինակ․


````c++որը որոշել ենք օգտագործել  
   // user.cpp:


   #include "Vector.h"         // ստանում ենք Vector֊ի ինտերֆեյսը
   #include <cmath>          // ստանում ենք ստանդարտ գրադարանի մաթեմատիկական ֆունկցիաների ինտերֆեյսը՝ ներառյալ sqrt() ֆունկցիայինը

   using namespace std;      // std անդամները դարձնում ենք տեսանելի (§3.3)

   double sqrt_sum(Vector& v)
   {
       double sum = 0;
       for (int i = 0; i != v.size(); ++i)
           sum += sqrt(v[i]);      // քառակուսի արմատների գումարը
       return sum;
   }
````

Որպեսզի օգնենք կոմպիլյատորին ապահովելու կայունություն, `Vector`֊ի իրականացումն ապահովող `.cpp` ֆայլը նույնպես պետք է ներառի նրա ինտերֆեյսն ապահովող `.h` ֆայլը․


````c++
   // Vector.cpp:

   #include "Vector.h"   // ստանում ենք ինտերֆեյսը

   Vector::Vector (int s)
                 :elem {new double[s]}, sz{s}       // ինիցիալիզացնում ենք անդամները
   {
   }

   double& Vector::operator[] (int i)
   {
            return elem[i];
   }

   int Vector::size()
   {
             return sz;
   }
````

`user.cpp` և `Vector.cpp` ֆայլերի կոդերը կիսում են `Vector.h` ֆայլում ներկայացված `Vector`֊ի ինտերֆեյսի ինֆորմացիան, բայց նաև այդ երկու ֆայլերը իրարից անկախ են և կարող են կոմպիլյացվել առանձին։ Գրաֆիկորեն ծրագրի մասերը կարող են ներկայացվել հետևյալ ձևով․

նկար գլուխ 3.2


## 3.3 Անվանատարծքներ

Որպես լրացում ֆունկցիաներին (§1.4), դասերին (§2.3) և թվարկումներին (§2.5), C++ լեզուն առաջարկում է նաև *անվանատարածքներ* as a
mechanism for expressing that some declarations belong together and that their names shouldn’t clash with other names. For example, I might want to experiment with my own complex number type (§4.2.1, §12.4):


````c++
   namespace My_code {
             class complex {
                      // ...
             };

             complex sqrt(complex);
             // ...

             int main();
   {

   int My_code::main()
   {
           complex z{1,2};
           auto z2 = sqrt(z);
            std::cout << '{' << z2.real() << ',' << z2.imag() << "}\n";
            // ...
};
````


Տեղադրելով իմ կոդը `My_code` անվանատարածքի մեջ, ես վստահ եմ լինում, որ իմ անունները կոնֆլիկտի մեջ չեն մտնում ստանդարտ գրադարանի անունների հետ, որոնք գտնվում են `std` անվանատարածքում (§3.3)։ Նախազգուշացումը խոհեմ է, որովհետև ստանդարտ գրադարանը տրամադրում է աջակցություն `complex` թվերի թվաբանության համար (§4.2.1, §12.4)։ 

Մեկ այլ անունների տիրույթում գտնվող անվանը հասնելու ամենապարզ ճանապարհը նրան անվանատարածքի անվան հետ սահմանելն է (օր․ `std::cout` և `My_code::main`)։ «Իրական `main()֊ը`» սահմանված է անունների գլոբալ տիրույթում, այսինքն not local to a defined namespace, class, or function։ Որպեսզի ստանանք դիմելու կարողություն ստանդարտ գրադարանի անվանատարածքի անուններին, մենք կարող ենք օգտագործել `using`- դիրեկտիվը․

````c++
   using namespace std;
````


`using`֊ դիրեկտիվը անվանված անունների տիրույթի անունները դարձնում է հասանելի, կարծես թե նրանք լոկալ են տեսանելիության այն տիրույթում, որտեղ, որ տեղադրել ենք դիրեկտիվը։ Այսպիսով `std` անվանատարածքի համար `using` - դիրեկտիվն օգտագործելուց հետո, մենք կարող ենք ուղղղակի գրել `cout` քան թե `std::std`։

Անունների տիրույթները հիմնականում օգտագործվում են ծրագրային ավելի մեծ բաղկացուցիչներ (կոմպոնենտներ ?) ստեղծելու համար, ինչպիսիք են օրինակ գրադարանները։ Նրանք պարզեցնում են ծրագրի կազմությունը՝ բաժանելով այն առանձին կազմված մասերի։


## 3.4  Սխալների մշակում

Սխալների մշակումը մտահոգություններով և ճյուղավորումներով մի մեծ և համախմբված նյութ է, որը գնում է հեռու լեզվի հնարավորություններից դուրս դեպի ծրագրավորման տեխնիկան և գործիքները։ Ինչևէ, C++ լեզուն ապահովում է որոշ գործիքներ օգնության համար։ Գլխավոր գործիքը հենց ինքը համակարգն է: Քրտնաջան ձևով ներդրված տիպերով (օր․ `char`, `int`, և `double`) և հրամաններով (օր․ `if`, `while` և `for`) ծրագրեր կազմելու փոխարեն մենք կառուցում ենք մեր ծրագրերի համար հարմար տիպեր (օր․ `string`, `map` և `regex`) և ալգորիթմներ (օր․ `sort()`, `find_if()` և `draw_all()`): Այսպիսի բարձր մակարդակի կառուցվածքը պարզեցնում է մեր ծրագրավորումը, սահմանափակում է մեր՝ սխալների հնարավորությունները (օր․ e.g., you are unlikely to try to apply a tree traversal to a dialog box) և մեծացնում է կոմպիլյատորի հնարավորությունները սխալներ գտնելու մեջ։ C++ լեզվի կառուցվածքների մեծամասնությունը նվիրված է էլեգանտ և որակյալ աբստրակցիաների մեխանիզմների ձևավորմանը և իրագործմանը (օր․ օգտագործողի սահմանած տիպերը և դրանք կիրառող ալգորիթմները)։ Այս մոդուլյարության և աբստրակցիայի էֆեկտներից մեկն այն է, (մասնավորապես գրադարանների կիրառումը) որ այն կետը, որտեղ run-time սխալը կարող է գտնվել առանձին է այն կետից, որտեղ այն կարող է մշակվել։ Քանի որ ծրագրերը մեծանում են, և հատկապես երբ գրադարանները ավելի լայնորեն են կիրառվում, սխալների մշակման ստանդարտները դառնում են կարևոր։ Լավ գաղափար է ձևավորել և հստակեցնել սխալների մշակման ստրատեգիա  ծրագրերի մշակման մեջ ավելի վաղ։ 

### 3.4.1 Բացառություններ

Դիտարկենք նորից `Vector` դասի օրինակը։ Ի՞նչ *կլինի*, երբ փորձենք դիմել այն տարրին, որը §2.3֊ի վեկտորի համար դուրս է սահմաններից։ 
* `Vector` դասի ստեղծողը չգիտի, թե ինչպես կվարվի օգտագործողը նման իրավիճակում (վեկտորն ստեղծողը սովորաբար նույնիսկ չգիտի էլ, թե որ ծրագրում է վեկտորն աշխատելու)։
* Համապատասխանորեն `Vector` դասի օգտագործողը չի կարող հայտնաբերել տվյալ խնդիրը (եթե օգտագործողը կարողանար, սահմանից դուրս դիմումը տեղի չէր ունենա առաջին տեղում)։

Լուծումը հետևյալն է, որ `Vector`֊ը իրականացնողը հայտնաբերի զանգվածի սահմանից դուրս դիմումը և տեղեկացնի օգտագործողին դրա մասին։ Օգտագործողը դրանից հետո կարող է կատարել համապատասխան գործողությունը։ Օրինակ, `Vector::operator[]()` ֆունկցիան կարող է հայտնաբերել փորձված դիմումը շարքից դուրս և դուրս բերել (throw) `out_of_range` բացառությունը․

````c++
   double& Vector::operator[] (int i)
   {
         if (i < 0 || size() <= i)
               throw out_of_range{"Vector::operator[]"};
         return elem[i];
   }
````

`throw` փոխանցումները ստուգում են `out_of_range` բացառությունները այնպիսի ֆունկցիաներում, որոնք ուղղակի կամ անուղղակի կոչվում են `Vector::operator[]()`???։ 





















