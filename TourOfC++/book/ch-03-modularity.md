#Modularity

Don't interrupt me while I'm interrupting.
-Winston S. Churchill

 
* Ներածություն
* Առանձնացված կոմպիլյացիա
* Անվանատարծքներ
* Սխալների մշակում
        Բացառություններ; Invariants; Ստատիկ պնդումներ
* Խորհուրդներ 


## 3.1 Ներածություն

C++ լեզվով գրված ծրագիրը բաղկացած է առանձին կառուցված մասերից, ինչպիսիք են օրինակ ֆունկցիաները (§1.3), օգտագործողի սահմանած տիպերը (Գլուխ 2), դասերի հիերարխիան (§4.5) և շաբլոնները (Գլուխ 5)։ Այդ ամենը ղեկավարելու բանալին այդ մասերի միջև փոխազդեցությունների հստակ սահմանումն է։ Առաջին և ամենակարևոր քայլը տարբերումն է (առանձնացումն է) այդ մասի ինտերֆեյսի և նրա իրականացման միջև։ Լեզվի մակարդակի վրա C++ լեզուն ներկայացնում է ինտերֆեյսերը հայտարարությունների միջոցով։ *Հայտարարությունը* նշում է ֆունկցիայի կամ տիպի օգտագործման համար անհրաժեշտ բոլոր տարրերը։ Օրինակ․

````c++
   double sqrt(double);      // քառակուսի արմատ հաշվող ֆունկցիան ստանում է double արժեք և վերադարձնում է double արժեք
````

````c++
   class Vector {
   public:
            Vector(int s);
             double& operator[](int i);
             int size();
   private:
             double* elem;      // elem֊ը ցույց է տալիս sz double արժեքներով զանգվածի վրա
};
````

Կարևոր կետն այստեղ այն է, որ ֆունկցիաների մարմինները, սահմանումները այլ տեղում են։ For this example, we might like for the representation of Vector to be ‘‘elsewhere’’ also, but we will deal
with that later (abstract types; §4.3). `sqrt()`֊ի սահմանումը կունենա հետևյալ տեսքը․

````c++
   double sqrt(double d)         // sqrt()֊ի սահմանումը
   { 
         // մաթեմատիկայի տետրում գրված ալգորիթմը
   }
````

`Vector`֊ի համար մենք պետք է սահմանենք բոլոր երեք անդամ ֆունկցիաները․

````c++
   Vector::Vector(int s)         //կոնստրուկտորի սահմանումը
         :elem{new double[s]}, sz{s}
   {
   }

   double& Vector::operator[] (int i)      //subscripting սահմանումը
   {
         return elem[i];
   }

   int Vector::size()          //size()֊ի սահմանումը
   {
         return sz;
   }
````

Մենք պետք է սահմանենք `Vector`֊ի ֆունկցիաները , բայց sqrt() ֆունկցիան՝ ոչ, որովհետև այն ստանդարտ գրադարանի մասն է (ֆունկցիաներից է?)։ Ինչևէ, այստեղ մեծ տարբերություն չկա: գրադարանը պարզապես մեկ այլ կոդ է, որը որոշել ենք օգտագործել՝ գրված լեզվի նույն գործիքներով, որոնք ինքներս ենք օգտագործում։


## 3.2 Առանձնացված կոմպիլյացիա

C++ լեզուն օգտագործում է առանձնացված կոմպիլյացիայի հասկացությունը, որտեղ օգտագործողի կոդը տեսնում է օգտագործված տիպերի և ֆունկցիաների հայտարարությունները միայն։ Այդ տիպերի և ֆունկցիաների սահմանումները գտնվում են այլ սկզբնային ֆայլերում և առանձին են կոմպիլացվում։ This can be used to organize a program into a set of semi-independent code fragments. Այսպիսի առանձնացումը կարող է օգտագործվել կոմպիլյացիայի ժամանակը մինիմալի հասցնելու համար և խստորեն կիրառելու համար ծրագիրը տրամաբանական մասերի բաժանումը (որը մինիմալի է հասցնում սխալների հավանականությունը)։ Գրադարանը հաճախ առանձին կոմպիլացված կոդերի (օր․ ֆունցիաների) հավաքածու է։

Սովորաբար հայտարարությունները, որոնք ցույց են տալիս ինտերֆեյսը, տեղադրում ենք ֆայլի՝ դրանց նախատեսվող օգտագործումը նշող անվամբ մոդուլի մեջ։ Օրինակ․

````c++
   // Vector.h:

   class Vector {
   public:
            Vector(int s);
            double& operator[](int i);
            int size();
   private:
            double* elem;         // elem֊ը ցույց է տալիս double տիպի sz տարրերի զանգվածի վրա
            int sz;
   };
````

Այս հայտարարությունը ենթադրվում է, որ պետք է տեղադրվի `Vector.h` ֆայլում, և օգտագործողները պետք է *ներառեն* այդ, *վերնագրային* կոչվող ֆայլը, որպեսզի տվյալ ինտերֆեյսը հասանելի լինի։ Օրինակ․


````c++
   // user.cpp:


   #include "Vector.h"         // ստանում ենք Vector֊ի ինտերֆեյսը
   #include <cmath>          // ստանում ենք ստանդարտ գրադարանի մաթեմատիկական ֆունկցիաների ինտերֆեյսը՝ ներառյալ sqrt() ֆունկցիայինը

   using namespace std;      // std անդամները դարձնում ենք տեսանելի (§3.3)

   double sqrt_sum(Vector& v)
   {
         double sum = 0;
         for (int i = 0; i != v.size(); ++i)
                  sum += sqrt(v[i]);      // քառակուսի արմատների գումարը
          return sum;
   }
````

Որպեսզի օգնենք կոմպիլյատորին ապահովելու կայունություն, `Vector`֊ի իրականացումն ապահովող `.cpp` ֆայլը նույնպես պետք է ներառի նրա ինտերֆեյսն ապահովող `.h` ֆայլը․


````c++
   // Vector.cpp:

   #include "Vector.h"   // ստանում ենք ինտերֆեյսը

   Vector::Vector (int s)
                 :elem {new double[s]}, sz{s}       // ինիցիալիզացնում ենք անդամները
   {
   }

   double& Vector::operator[] (int i)
   {
            return elem[i];
   }

   int Vector::size()
   {
             return sz;
   }
````

`user.cpp` և `Vector.cpp` ֆայլերի կոդերը կիսում են `Vector.h` ֆայլում ներկայացված `Vector`֊ի ինտերֆեյսի ինֆորմացիան, բայց նաև այդ երկու ֆայլերը իրարից անկախ են և կարող են կոմպիլյացվել առանձին։ Գրաֆիկորեն ծրագրի մասերը կարող են ներկայացվել հետևյալ ձևով․

նկար գլուխ 3.2


## 3.3 Անվանատարծքներ












